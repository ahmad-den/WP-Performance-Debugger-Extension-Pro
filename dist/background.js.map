{"version":3,"file":"background.js","mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;;AAEA;;AAYA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzVA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAUA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC5NA;AACA;AACA;;AAEA;AACA;AACA;AAOA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AACA;;AAEA;AACA;AAAA;AAAA;AAAA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACnoBA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC5DA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACtIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACNA;AACA;AACA;;AAEA;AACA;AAMA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA","sources":["webpack://new-bs-helper-extension/./src/background/window-manager.js","webpack://new-bs-helper-extension/./src/utils/window-state.js","webpack://new-bs-helper-extension/./src/background/message-handler.js","webpack://new-bs-helper-extension/./src/background/tab-manager.js","webpack://new-bs-helper-extension/./src/background/parameter-manager.js","webpack://new-bs-helper-extension/webpack/bootstrap","webpack://new-bs-helper-extension/webpack/runtime/define property getters","webpack://new-bs-helper-extension/webpack/runtime/hasOwnProperty shorthand","webpack://new-bs-helper-extension/webpack/runtime/make namespace object","webpack://new-bs-helper-extension/./src/background/index.js"],"sourcesContent":["/**\n * Module for managing detachable popup windows - Enhanced bounds validation\n */\n\nimport {\n  getWindowState,\n  setWindowState,\n  getDetachedWindowId,\n  setDetachedWindowId,\n  getWindowBounds,\n  setWindowBounds,\n  setOriginalTabId,\n  WINDOW_STATES,\n  DEFAULT_WINDOW_CONFIG,\n} from \"../utils/window-state.js\"\n\n// Declare the chrome variable\nconst chrome = globalThis.chrome || self.chrome\n\n// Track the current detached window\nlet detachedWindow = null\n\n/**\n * Validates and corrects window bounds to ensure they're within screen limits\n * @param {Object} bounds - Window bounds to validate\n * @returns {Promise<Object>} Validated bounds\n */\nasync function validateWindowBounds(bounds) {\n  try {\n    // Get all available displays\n    const displays = await new Promise((resolve) => {\n      if (chrome.system && chrome.system.display) {\n        chrome.system.display.getInfo((displays) => {\n          if (chrome.runtime.lastError) {\n            resolve([])\n          } else {\n            resolve(displays || [])\n          }\n        })\n      } else {\n        resolve([])\n      }\n    })\n\n    // If we can't get display info, use safe defaults\n    if (!displays || displays.length === 0) {\n      console.log(\"No display info available, using safe defaults\")\n      return {\n        left: 100,\n        top: 100,\n        width: Math.min(bounds.width || DEFAULT_WINDOW_CONFIG.width, 1200),\n        height: Math.min(bounds.height || DEFAULT_WINDOW_CONFIG.height, 800),\n      }\n    }\n\n    // Find the primary display or the largest one\n    const primaryDisplay = displays.find((d) => d.isPrimary) || displays[0]\n    const screenBounds = primaryDisplay.bounds\n\n    console.log(\"Screen bounds:\", screenBounds)\n    console.log(\"Requested bounds:\", bounds)\n\n    // Calculate safe bounds\n    const safeWidth = Math.min(bounds.width || DEFAULT_WINDOW_CONFIG.width, screenBounds.width - 100)\n    const safeHeight = Math.min(bounds.height || DEFAULT_WINDOW_CONFIG.height, screenBounds.height - 100)\n\n    // Ensure window is at least 50% within screen bounds\n    const minLeft = screenBounds.left - Math.floor(safeWidth * 0.5)\n    const maxLeft = screenBounds.left + screenBounds.width - Math.floor(safeWidth * 0.5)\n    const minTop = screenBounds.top - Math.floor(safeHeight * 0.5)\n    const maxTop = screenBounds.top + screenBounds.height - Math.floor(safeHeight * 0.5)\n\n    let safeLeft = bounds.left || 100\n    let safeTop = bounds.top || 100\n\n    // Clamp to safe ranges\n    safeLeft = Math.max(minLeft, Math.min(maxLeft, safeLeft))\n    safeTop = Math.max(minTop, Math.min(maxTop, safeTop))\n\n    // Additional safety check - ensure window is mostly visible\n    if (safeLeft + safeWidth < screenBounds.left + 100) {\n      safeLeft = screenBounds.left + 100\n    }\n    if (safeTop + safeHeight < screenBounds.top + 100) {\n      safeTop = screenBounds.top + 100\n    }\n\n    const validatedBounds = {\n      left: safeLeft,\n      top: safeTop,\n      width: safeWidth,\n      height: safeHeight,\n    }\n\n    console.log(\"Validated bounds:\", validatedBounds)\n    return validatedBounds\n  } catch (error) {\n    console.error(\"Error validating window bounds:\", error)\n    // Return safe fallback bounds\n    return {\n      left: 100,\n      top: 100,\n      width: Math.min(bounds.width || DEFAULT_WINDOW_CONFIG.width, 1000),\n      height: Math.min(bounds.height || DEFAULT_WINDOW_CONFIG.height, 700),\n    }\n  }\n}\n\n/**\n * Creates a detached popup window with validated bounds\n * @param {number} originalTabId - The ID of the original tab\n * @returns {Promise<chrome.windows.Window>} Created window\n */\nexport async function createDetachedWindow(originalTabId) {\n  try {\n    console.log(\"Creating detached window for tab:\", originalTabId)\n\n    // Get saved bounds or use defaults\n    const savedBounds = await getWindowBounds()\n    console.log(\"Saved bounds:\", savedBounds)\n\n    // Use saved bounds or defaults\n    const requestedBounds = savedBounds || {\n      left: 100,\n      top: 100,\n      width: DEFAULT_WINDOW_CONFIG.width,\n      height: DEFAULT_WINDOW_CONFIG.height,\n    }\n\n    // Validate bounds to ensure they're within screen limits\n    const validatedBounds = await validateWindowBounds(requestedBounds)\n\n    // Include original tab ID in the URL\n    const popupUrl = originalTabId\n      ? `${chrome.runtime.getURL(\"popup.html\")}?originalTabId=${originalTabId}`\n      : chrome.runtime.getURL(\"popup.html\")\n\n    const windowConfig = {\n      url: popupUrl,\n      type: \"popup\",\n      focused: true,\n      ...validatedBounds,\n    }\n\n    console.log(\"Creating window with config:\", windowConfig)\n\n    const window = await chrome.windows.create(windowConfig)\n    detachedWindow = window\n\n    await setDetachedWindowId(window.id)\n    await setWindowState(WINDOW_STATES.DETACHED)\n\n    // Store the original tab ID in storage as backup\n    if (originalTabId) {\n      await setOriginalTabId(originalTabId)\n    }\n\n    console.log(\"Successfully created detached window with ID:\", window.id)\n    return window\n  } catch (error) {\n    console.error(\"Error creating detached window:\", error)\n\n    // Try with minimal safe bounds as fallback\n    try {\n      console.log(\"Attempting fallback window creation with minimal bounds\")\n\n      const fallbackConfig = {\n        url: originalTabId\n          ? `${chrome.runtime.getURL(\"popup.html\")}?originalTabId=${originalTabId}`\n          : chrome.runtime.getURL(\"popup.html\"),\n        type: \"popup\",\n        focused: true,\n        left: 100,\n        top: 100,\n        width: 600,\n        height: 500,\n      }\n\n      const window = await chrome.windows.create(fallbackConfig)\n      detachedWindow = window\n\n      await setDetachedWindowId(window.id)\n      await setWindowState(WINDOW_STATES.DETACHED)\n\n      if (originalTabId) {\n        await setOriginalTabId(originalTabId)\n      }\n\n      console.log(\"Fallback window creation successful:\", window.id)\n      return window\n    } catch (fallbackError) {\n      console.error(\"Fallback window creation also failed:\", fallbackError)\n      throw fallbackError\n    }\n  }\n}\n\n/**\n * Focuses the detached window if it exists\n * @returns {Promise<boolean>} True if window was focused successfully\n */\nexport async function focusDetachedWindow() {\n  try {\n    const windowId = await getDetachedWindowId()\n    console.log(\"Attempting to focus detached window ID:\", windowId)\n\n    if (windowId) {\n      try {\n        // Check if window still exists\n        const window = await chrome.windows.get(windowId)\n        if (window) {\n          console.log(\"Window found, focusing...\")\n\n          // Bring window to front and focus it\n          await chrome.windows.update(windowId, {\n            focused: true,\n            state: \"normal\", // Ensure it's not minimized\n          })\n\n          // Additional focus attempt for better visibility\n          setTimeout(async () => {\n            try {\n              await chrome.windows.update(windowId, { focused: true })\n            } catch (e) {\n              console.debug(\"Secondary focus attempt failed:\", e)\n            }\n          }, 100)\n\n          console.log(\"Successfully focused detached window\")\n          return true\n        }\n      } catch (error) {\n        console.log(\"Window doesn't exist, cleaning up:\", error)\n        // Window doesn't exist, clean up\n        await handleDetachedWindowClosed()\n        return false\n      }\n    }\n\n    console.log(\"No detached window ID found\")\n    return false\n  } catch (error) {\n    console.debug(\"Error focusing detached window:\", error)\n    return false\n  }\n}\n\n/**\n * Handles cleanup when detached window is closed\n */\nexport async function handleDetachedWindowClosed() {\n  console.log(\"Cleaning up detached window state\")\n  detachedWindow = null\n  await setDetachedWindowId(null)\n  await setWindowState(WINDOW_STATES.ATTACHED)\n}\n\n/**\n * Saves current window bounds before closing with validation\n * @param {number} windowId - Window ID to save bounds for\n */\nexport async function saveWindowBounds(windowId) {\n  try {\n    const window = await chrome.windows.get(windowId)\n\n    // Only save bounds if they seem reasonable\n    if (\n      window.left >= -1000 &&\n      window.top >= -1000 &&\n      window.width >= 300 &&\n      window.height >= 200 &&\n      window.width <= 2000 &&\n      window.height <= 1500\n    ) {\n      const bounds = {\n        left: window.left,\n        top: window.top,\n        width: window.width,\n        height: window.height,\n      }\n\n      await setWindowBounds(bounds)\n      console.log(\"Saved window bounds:\", bounds)\n    } else {\n      console.log(\"Window bounds seem invalid, not saving:\", {\n        left: window.left,\n        top: window.top,\n        width: window.width,\n        height: window.height,\n      })\n    }\n  } catch (error) {\n    console.debug(\"Error saving window bounds:\", error)\n  }\n}\n\n/**\n * Attaches the popup back to the extension icon\n */\nexport async function attachPopup() {\n  const windowId = await getDetachedWindowId()\n  console.log(\"Attaching popup, current detached window ID:\", windowId)\n\n  if (windowId) {\n    try {\n      // Save bounds before closing\n      await saveWindowBounds(windowId)\n      await chrome.windows.remove(windowId)\n      console.log(\"Closed detached window\")\n    } catch (error) {\n      console.debug(\"Error closing detached window:\", error)\n    }\n  }\n\n  await handleDetachedWindowClosed()\n}\n\n/**\n * Gets the current window state\n * @returns {Promise<string>} Current window state\n */\nexport async function getCurrentWindowState() {\n  return await getWindowState()\n}\n\n/**\n * Checks if a window ID matches our detached window\n * @param {number} windowId - Window ID to check\n * @returns {Promise<boolean>} True if it's our detached window\n */\nexport async function isDetachedWindow(windowId) {\n  const detachedWindowId = await getDetachedWindowId()\n  return detachedWindowId === windowId\n}\n\n/**\n * Resets stored window bounds (useful for debugging)\n */\nexport async function resetWindowBounds() {\n  try {\n    await setWindowBounds(null)\n    console.log(\"Window bounds reset\")\n  } catch (error) {\n    console.error(\"Error resetting window bounds:\", error)\n  }\n}\n","/**\n * Utility module for managing popup window state - Enhanced with bounds validation\n */\n\n// Window state constants\nexport const WINDOW_STATES = {\n  ATTACHED: \"attached\",\n  DETACHED: \"detached\",\n}\n\n// Storage keys\nexport const STORAGE_KEYS = {\n  WINDOW_STATE: \"popup_window_state\",\n  DETACHED_WINDOW_ID: \"detached_window_id\",\n  WINDOW_BOUNDS: \"detached_window_bounds\",\n}\n\n// Default window dimensions - Conservative sizes for better compatibility\nexport const DEFAULT_WINDOW_CONFIG = {\n  width: 700, // Reduced from 800\n  height: 600, // Reduced from 700\n  type: \"popup\",\n  focused: true,\n}\n\n// Declare chrome variable\nconst chrome = globalThis.chrome || self.chrome\n\n/**\n * Gets the current window state from storage\n * @returns {Promise<string>} Current window state\n */\nexport async function getWindowState() {\n  try {\n    const result = await chrome.storage.local.get(STORAGE_KEYS.WINDOW_STATE)\n    return result[STORAGE_KEYS.WINDOW_STATE] || WINDOW_STATES.ATTACHED\n  } catch (error) {\n    console.debug(\"Error getting window state:\", error)\n    return WINDOW_STATES.ATTACHED\n  }\n}\n\n/**\n * Sets the window state in storage\n * @param {string} state - The window state to set\n */\nexport async function setWindowState(state) {\n  try {\n    await chrome.storage.local.set({ [STORAGE_KEYS.WINDOW_STATE]: state })\n  } catch (error) {\n    console.debug(\"Error setting window state:\", error)\n  }\n}\n\n/**\n * Gets the detached window ID from storage\n * @returns {Promise<number|null>} Window ID or null\n */\nexport async function getDetachedWindowId() {\n  try {\n    const result = await chrome.storage.local.get(STORAGE_KEYS.DETACHED_WINDOW_ID)\n    return result[STORAGE_KEYS.DETACHED_WINDOW_ID] || null\n  } catch (error) {\n    console.debug(\"Error getting detached window ID:\", error)\n    return null\n  }\n}\n\n/**\n * Sets the detached window ID in storage\n * @param {number|null} windowId - The window ID to store\n */\nexport async function setDetachedWindowId(windowId) {\n  try {\n    if (windowId === null) {\n      await chrome.storage.local.remove(STORAGE_KEYS.DETACHED_WINDOW_ID)\n    } else {\n      await chrome.storage.local.set({ [STORAGE_KEYS.DETACHED_WINDOW_ID]: windowId })\n    }\n  } catch (error) {\n    console.debug(\"Error setting detached window ID:\", error)\n  }\n}\n\n/**\n * Gets saved window bounds from storage with validation\n * @returns {Promise<Object|null>} Window bounds or null\n */\nexport async function getWindowBounds() {\n  try {\n    const result = await chrome.storage.local.get(STORAGE_KEYS.WINDOW_BOUNDS)\n    const bounds = result[STORAGE_KEYS.WINDOW_BOUNDS]\n\n    // Validate bounds before returning\n    if (bounds && typeof bounds === \"object\") {\n      // Check if bounds seem reasonable\n      if (\n        bounds.width >= 300 &&\n        bounds.height >= 200 &&\n        bounds.width <= 2000 &&\n        bounds.height <= 1500 &&\n        typeof bounds.left === \"number\" &&\n        typeof bounds.top === \"number\"\n      ) {\n        return bounds\n      } else {\n        console.log(\"Stored bounds seem invalid, ignoring:\", bounds)\n        // Clear invalid bounds\n        await setWindowBounds(null)\n        return null\n      }\n    }\n\n    return null\n  } catch (error) {\n    console.debug(\"Error getting window bounds:\", error)\n    return null\n  }\n}\n\n/**\n * Saves window bounds to storage with validation\n * @param {Object|null} bounds - Window bounds object\n */\nexport async function setWindowBounds(bounds) {\n  try {\n    if (bounds === null) {\n      await chrome.storage.local.remove(STORAGE_KEYS.WINDOW_BOUNDS)\n      console.log(\"Window bounds cleared\")\n    } else {\n      // Validate bounds before saving\n      if (\n        bounds &&\n        typeof bounds === \"object\" &&\n        bounds.width >= 300 &&\n        bounds.height >= 200 &&\n        bounds.width <= 2000 &&\n        bounds.height <= 1500 &&\n        typeof bounds.left === \"number\" &&\n        typeof bounds.top === \"number\"\n      ) {\n        await chrome.storage.local.set({ [STORAGE_KEYS.WINDOW_BOUNDS]: bounds })\n        console.log(\"Window bounds saved:\", bounds)\n      } else {\n        console.log(\"Invalid bounds not saved:\", bounds)\n      }\n    }\n  } catch (error) {\n    console.debug(\"Error setting window bounds:\", error)\n  }\n}\n\n/**\n * Gets the original tab ID from storage\n * @returns {Promise<number|null>} Original tab ID or null\n */\nexport async function getOriginalTabId() {\n  try {\n    const result = await chrome.storage.local.get(\"originalTabId\")\n    return result.originalTabId || null\n  } catch (error) {\n    console.debug(\"Error getting original tab ID:\", error)\n    return null\n  }\n}\n\n/**\n * Sets the original tab ID in storage\n * @param {number|null} tabId - The tab ID to store\n */\nexport async function setOriginalTabId(tabId) {\n  try {\n    if (tabId === null) {\n      await chrome.storage.local.remove(\"originalTabId\")\n    } else {\n      await chrome.storage.local.set({ originalTabId: tabId })\n    }\n  } catch (error) {\n    console.debug(\"Error setting original tab ID:\", error)\n  }\n}\n\n/**\n * Clears the original tab ID from storage\n */\nexport async function clearOriginalTabId() {\n  try {\n    await chrome.storage.local.remove(\"originalTabId\")\n  } catch (error) {\n    console.debug(\"Error clearing original tab ID:\", error)\n  }\n}\n\n/**\n * Checks if current window is the detached popup window\n * @returns {Promise<boolean>} True if this is the detached window\n */\nexport async function isCurrentWindowDetached() {\n  try {\n    const currentWindowId = await getCurrentWindowId()\n    const detachedWindowId = await getDetachedWindowId()\n    return currentWindowId === detachedWindowId\n  } catch (error) {\n    console.debug(\"Error checking if current window is detached:\", error)\n    return false\n  }\n}\n\n/**\n * Gets the current window ID\n * @returns {Promise<number|null>} Current window ID or null\n */\nexport async function getCurrentWindowId() {\n  try {\n    const currentWindow = await chrome.windows.getCurrent()\n    return currentWindow.id\n  } catch (error) {\n    console.debug(\"Error getting current window ID:\", error)\n    return null\n  }\n}\n","/**\n * Module for handling extension messages - Enhanced for all PSI metrics including Lab data\n */\n\nimport { storeTabResults, getTabResults } from \"./tab-manager.js\"\nimport { getTabParameters, addTabParameter, removeTabParameter, applyParametersToTab } from \"./parameter-manager.js\"\nimport {\n  createDetachedWindow,\n  attachPopup,\n  getCurrentWindowState,\n  focusDetachedWindow,\n  handleDetachedWindowClosed,\n} from \"./window-manager.js\"\nimport { getWindowState, WINDOW_STATES } from \"../utils/window-state.js\"\n\n// Storage for throttling timestamps (replaces window usage in service worker)\nconst throttleStorage = new Map()\n\n// Declare chrome variable\nconst chrome = globalThis.chrome || self.chrome\n\n/**\n * Sets up message handlers for the extension\n * @param {Object} chrome - The Chrome API object\n */\nexport function setupMessageHandlers(chrome) {\n  chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {\n    if (request.action === \"updateBadge\") {\n      handleUpdateBadge(request, sender, chrome)\n    } else if (request.action === \"analysisResults\") {\n      handleAnalysisResults(request, sender)\n    } else if (request.action === \"updateINP\") {\n      handleINPUpdate(request, sender)\n    } else if (request.action === \"storePSIResults\") {\n      handleStorePSIResults(request, sender)\n    } else if (request.action === \"getPSIResults\") {\n      handleGetPSIResults(request, sendResponse)\n      return true\n    } else if (request.action === \"updatePSICLS\") {\n      handlePSIMetricUpdate(request, sender, \"cls\")\n    } else if (request.action === \"updatePSILCP\") {\n      handlePSIMetricUpdate(request, sender, \"lcp\")\n    } else if (request.action === \"updatePSIINP\") {\n      handlePSIMetricUpdate(request, sender, \"inp\")\n    } else if (request.action === \"updatePSITTFB\") {\n      handlePSIMetricUpdate(request, sender, \"ttfb\")\n    } else if (request.action === \"updatePSILabCLS\") {\n      handlePSILabMetricUpdate(request, sender, \"cls\")\n    } else if (request.action === \"updatePSILabLCP\") {\n      handlePSILabMetricUpdate(request, sender, \"lcp\")\n    } else if (request.action === \"updatePSIStatus\") {\n      handlePSIStatusUpdate(request, sender)\n    } else if (request.action === \"getAnalysisResults\") {\n      handleGetAnalysisResults(request, sendResponse)\n      return true\n    } else if (request.action === \"updateParameters\") {\n      handleUpdateParameters(request, sendResponse, chrome)\n      return true\n    } else if (request.action === \"getParameters\") {\n      handleGetParameters(sendResponse, chrome, request)\n      return true\n    } else if (request.action === \"detachPopup\") {\n      handleDetachPopup(sendResponse, chrome)\n      return true\n    } else if (request.action === \"attachPopup\") {\n      handleAttachPopup(sendResponse)\n      return true\n    } else if (request.action === \"getWindowState\") {\n      handleGetWindowState(sendResponse)\n      return true\n    } else if (request.action === \"tabUrlChanged\") {\n      handleTabUrlChanged(request, sendResponse)\n      return true\n    } else if (request.action === \"getTabUrl\") {\n      handleGetTabUrl(request, sendResponse)\n      return true\n    } else if (request.action === \"completePSIResults\") {\n      handleCompletePSIResults(request, sender)\n    }\n    return true\n  })\n\n  // Add listener for tab URL changes\n  chrome.tabs.onUpdated.addListener((tabId, changeInfo, tab) => {\n    if (changeInfo.url) {\n      // Check if domain changed\n      import(\"./tab-manager.js\").then(({ getTabResults, getPSIResults, storeTabResults, storePSIResults }) => {\n        const existingResults = getTabResults(tabId)\n        const existingPSI = getPSIResults(tabId)\n\n        if (existingResults && existingResults.url) {\n          try {\n            const oldDomain = new URL(existingResults.url).hostname\n            const newDomain = new URL(changeInfo.url).hostname\n\n            if (oldDomain !== newDomain) {\n              console.log(\"ðŸ”„ [Domain Change] Clearing data for tab:\", tabId, \"from\", oldDomain, \"to\", newDomain)\n              // Clear stored data for this tab\n              storeTabResults(tabId, null)\n              storePSIResults(tabId, null)\n            }\n          } catch (error) {\n            console.log(\"Error parsing URLs for domain comparison:\", error)\n          }\n        }\n\n        if (existingPSI && existingPSI.url) {\n          try {\n            const oldDomain = new URL(existingPSI.url).hostname\n            const newDomain = new URL(changeInfo.url).hostname\n\n            if (oldDomain !== newDomain) {\n              console.log(\n                \"ðŸ”„ [PSI Domain Change] Clearing PSI data for tab:\",\n                tabId,\n                \"from\",\n                oldDomain,\n                \"to\",\n                newDomain,\n              )\n              storePSIResults(tabId, null)\n            }\n          } catch (error) {\n            console.log(\"Error parsing URLs for PSI domain comparison:\", error)\n          }\n        }\n      })\n\n      // Broadcast URL change to all extension contexts\n      chrome.runtime\n        .sendMessage({\n          action: \"tabUrlChanged\",\n          tabId: tabId,\n          url: changeInfo.url,\n        })\n        .catch(() => {\n          // Ignore errors if no receivers\n        })\n    }\n  })\n}\n\n/**\n * Handles PSI results storage\n * @param {Object} request - The request object\n * @param {Object} sender - The sender object\n */\nfunction handleStorePSIResults(request, sender) {\n  const tabId = sender.tab.id\n  const tabUrl = sender.tab.url\n  console.log(\"ðŸ“Š [PSI] Storing complete PSI results for tab:\", tabId, \"URL:\", tabUrl)\n\n  // Add URL to PSI data for verification\n  const psiDataWithUrl = {\n    ...request.psiData,\n    url: tabUrl,\n    timestamp: Date.now(),\n    // Store the complete data for insights restoration\n    completeData: request.psiData,\n  }\n\n  import(\"./tab-manager.js\").then(({ storePSIResults }) => {\n    storePSIResults(tabId, psiDataWithUrl)\n  })\n\n  // Forward to detached windows\n  forwardToDetachedWindows({ ...request, psiData: psiDataWithUrl })\n}\n\n/**\n * Handles PSI metric updates (CLS, LCP, INP, TTFB) - Field Data\n * @param {Object} request - The request object\n * @param {Object} sender - The sender object\n * @param {string} metric - The metric type (cls, lcp, inp, ttfb)\n */\nfunction handlePSIMetricUpdate(request, sender, metric) {\n  const tabId = sender.tab?.id\n  console.log(`ðŸŒ [PSI Field Data] Processing ${metric.toUpperCase()} for tab:`, tabId)\n\n  // Store field data in PSI results\n  if (tabId && request.fieldData) {\n    import(\"./tab-manager.js\").then(({ getPSIResults, storePSIResults }) => {\n      const existingPSI = getPSIResults(tabId) || { allFieldData: {}, allLabData: {} }\n\n      // Store field data\n      if (!existingPSI.allFieldData) existingPSI.allFieldData = {}\n      existingPSI.allFieldData[metric] = request.fieldData\n\n      storePSIResults(tabId, existingPSI)\n      console.log(`ðŸŒ [PSI Field Data] Stored ${metric.toUpperCase()} field data for tab:`, tabId)\n    })\n  }\n\n  // Forward to detached windows immediately\n  forwardToDetachedWindows(request)\n\n  // Log the field data for debugging\n  if (request.fieldData) {\n    console.log(`ðŸŒ [PSI Field Data] ${metric.toUpperCase()} metrics:`, {\n      percentile: `${request.fieldData.percentile}th percentile`,\n      category: request.fieldData.category,\n      value: request.fieldData.value,\n      dataSource: \"Real User Monitoring (CrUX)\",\n    })\n  }\n}\n\n/**\n * Handles PSI Lab metric updates (CLS, LCP only) - Lab Data\n * Note: TTFB is not available in lab data as it's a server-side metric\n * @param {Object} request - The request object\n * @param {Object} sender - The sender object\n * @param {string} metric - The metric type (cls, lcp)\n */\nfunction handlePSILabMetricUpdate(request, sender, metric) {\n  const tabId = sender.tab?.id\n  console.log(`ðŸ§ª [PSI Lab Data] Processing ${metric.toUpperCase()} for tab:`, tabId)\n\n  // Store lab data in PSI results\n  if (tabId && request.labData) {\n    import(\"./tab-manager.js\").then(({ getPSIResults, storePSIResults }) => {\n      const existingPSI = getPSIResults(tabId) || { allFieldData: {}, allLabData: {} }\n\n      // Store lab data with correct key format\n      if (!existingPSI.allLabData) existingPSI.allLabData = {}\n      existingPSI.allLabData[`lab${metric.toUpperCase()}`] = request.labData\n\n      storePSIResults(tabId, existingPSI)\n      console.log(`ðŸ§ª [PSI Lab Data] Stored ${metric.toUpperCase()} lab data for tab:`, tabId)\n    })\n  }\n\n  // Forward to detached windows immediately\n  forwardToDetachedWindows(request)\n\n  // Log the lab data for debugging\n  if (request.labData) {\n    console.log(`ðŸ§ª [PSI Lab Data] ${metric.toUpperCase()} metrics:`, {\n      numericValue: request.labData.numericValue,\n      displayValue: request.labData.displayValue,\n      score: request.labData.score,\n      dataSource: \"Lighthouse Lab Environment\",\n    })\n  }\n}\n\n/**\n * Handles PSI status updates\n * @param {Object} request - The request object\n * @param {Object} sender - The sender object\n */\nfunction handlePSIStatusUpdate(request, sender) {\n  const tabId = sender.tab?.id\n  const statusIcon =\n    request.status === \"loading\" ? \"â³\" : request.status === \"success\" ? \"âœ…\" : request.status === \"error\" ? \"âŒ\" : \"â„¹ï¸\"\n\n  console.log(`${statusIcon} [PSI Status] ${request.status.toUpperCase()} for tab:`, tabId)\n\n  // Forward to detached windows\n  forwardToDetachedWindows(request)\n}\n\n/**\n * Handles complete PSI results for insights processing\n * @param {Object} request - The request object\n * @param {Object} sender - The sender object\n */\nfunction handleCompletePSIResults(request, sender) {\n  const tabId = sender.tab?.id\n  console.log(\"ðŸ“Š [PSI Complete] Processing complete PSI results for insights, tab:\", tabId)\n\n  // Store the complete PSI data for insights restoration\n  if (tabId && request.psiData) {\n    import(\"./tab-manager.js\").then(({ getPSIResults, storePSIResults }) => {\n      const existingPSI = getPSIResults(tabId) || { allFieldData: {}, allLabData: {} }\n\n      // Store complete data for insights\n      existingPSI.completeData = request.psiData\n      existingPSI.timestamp = Date.now()\n\n      storePSIResults(tabId, existingPSI)\n      console.log(\"ðŸ“Š [PSI Complete] Stored complete PSI data for insights restoration\")\n    })\n  }\n\n  // Forward complete PSI data to detached windows for insights processing\n  forwardToDetachedWindows(request)\n}\n\n/**\n * Handles requests for PSI results\n * @param {Object} request - The request object\n * @param {Function} sendResponse - The response callback\n */\nfunction handleGetPSIResults(request, sendResponse) {\n  import(\"./tab-manager.js\").then(({ getPSIResults }) => {\n    const results = getPSIResults(request.tabId)\n    console.log(\"ðŸ“Š [PSI] Retrieving PSI results for tab:\", request.tabId, results ? \"âœ… found\" : \"âŒ not found\")\n    sendResponse(results)\n  })\n}\n\n// Add this new handler function to get a tab's URL\nfunction handleGetTabUrl(request, sendResponse) {\n  if (!request.tabId) {\n    sendResponse({ success: false, error: \"No tab ID provided\" })\n    return\n  }\n\n  chrome.tabs.get(request.tabId, (tab) => {\n    if (chrome.runtime.lastError) {\n      sendResponse({ success: false, error: chrome.runtime.lastError.message })\n      return\n    }\n\n    if (tab) {\n      sendResponse({ success: true, url: tab.url, tab: tab })\n    } else {\n      sendResponse({ success: false, error: \"Tab not found\" })\n    }\n  })\n}\n\n/**\n * Handles tab URL changes\n * @param {Object} request - The request object\n * @param {Function} sendResponse - The response callback\n */\nfunction handleTabUrlChanged(request, sendResponse) {\n  console.log(\"ðŸ”„ [Tab] URL changed:\", request.tabId, request.url)\n  // Forward to any open detached windows\n  forwardToDetachedWindows({\n    action: \"tabUrlChanged\",\n    tabId: request.tabId,\n    url: request.url,\n  })\n\n  if (sendResponse) {\n    sendResponse({ success: true })\n  }\n}\n\n/**\n * Handles extension icon clicks based on current window state\n */\nexport async function handleExtensionIconClick() {\n  const currentState = await getWindowState()\n  console.log(\"ðŸ–±ï¸ [Extension] Icon clicked, current state:\", currentState)\n\n  if (currentState === WINDOW_STATES.DETACHED) {\n    console.log(\"ðŸªŸ [Window] In detached mode, attempting to focus window\")\n    const focused = await focusDetachedWindow()\n    if (!focused) {\n      console.log(\"âŒ [Window] Failed to focus detached window, resetting to attached state\")\n      // Window was closed, reset to attached state\n      await handleDetachedWindowClosed()\n      return false // Allow default popup behavior\n    }\n    console.log(\"âœ… [Window] Successfully focused detached window\")\n    return true // Prevent default popup behavior\n  }\n\n  console.log(\"ðŸ“Ž [Window] In attached mode, allowing default popup behavior\")\n  // For attached state, Chrome handles the default popup behavior\n  return false\n}\n\n/**\n * Handles badge update requests\n * @param {Object} request - The request object\n * @param {Object} sender - The sender object\n * @param {Object} chrome - The Chrome API object\n */\nfunction handleUpdateBadge(request, sender, chrome) {\n  const hostedBy = request.hostedBy ? request.hostedBy.toLowerCase() : \"\"\n  const cacheStatus = request.cacheStatus ? request.cacheStatus.toLowerCase() : \"\"\n\n  const isHostedByBigScoots = hostedBy === \"bigscoots\"\n  const isCacheHit = cacheStatus === \"hit\"\n\n  let badgeColor\n\n  if (isHostedByBigScoots && isCacheHit) {\n    // Both conditions met - blue badge\n    badgeColor = \"#1a73e8\"\n    console.log(\"ðŸ”µ [Badge] BigScoots + Cache Hit - Blue badge\")\n  } else if (isHostedByBigScoots) {\n    // Only BigScoots hosting - green badge\n    badgeColor = \"#4CAF50\"\n    console.log(\"ðŸŸ¢ [Badge] BigScoots hosting - Green badge\")\n  } else {\n    // Neither condition met - red badge\n    badgeColor = \"#F44336\"\n    console.log(\"ðŸ”´ [Badge] Other hosting - Red badge\")\n  }\n\n  chrome.action.setBadgeText({ text: \"â—\", tabId: sender.tab.id })\n  chrome.action.setBadgeBackgroundColor({ color: [0, 0, 0, 0], tabId: sender.tab.id })\n  chrome.action.setBadgeTextColor({ color: badgeColor, tabId: sender.tab.id })\n}\n\n/**\n * Handles analysis results storage\n * @param {Object} request - The request object\n * @param {Object} sender - The sender object\n */\nfunction handleAnalysisResults(request, sender) {\n  const tabId = sender.tab.id\n  const tabUrl = sender.tab.url\n  const now = Date.now()\n\n  // Throttle logging to reduce noise (max once per 2 seconds per tab)\n  const lastLogKey = `lastAnalysisLog_${tabId}`\n  const lastLogTime = throttleStorage.get(lastLogKey) || 0\n\n  if (now - lastLogTime > 2000) {\n    console.log(\"ðŸ’» [Local Analysis] Storing local performance results for tab:\", tabId, \"URL:\", tabUrl)\n    throttleStorage.set(lastLogKey, now)\n  }\n\n  // Clean up old throttling entries (older than 1 hour)\n  const oneHourAgo = now - 60 * 60 * 1000\n  for (const [key, timestamp] of throttleStorage.entries()) {\n    if (timestamp < oneHourAgo) {\n      throttleStorage.delete(key)\n    }\n  }\n\n  // Add URL to the request data for verification\n  const dataWithUrl = { ...request, url: tabUrl, timestamp: now }\n  storeTabResults(tabId, dataWithUrl)\n\n  // Forward to any open detached windows\n  forwardToDetachedWindows(request)\n}\n\n// Add this new function after handleAnalysisResults\nfunction handleINPUpdate(request, sender) {\n  const tabId = sender.tab.id\n  const now = Date.now()\n\n  // Throttle logging for INP updates (max once per 3 seconds per tab)\n  const lastLogKey = `lastINPLog_${tabId}`\n  const lastLogTime = throttleStorage.get(lastLogKey) || 0\n\n  if (now - lastLogTime > 3000) {\n    console.log(\"âš¡ [Local INP] Storing local INP measurement for tab:\", tabId, \"value:\", request.value + \"ms\")\n    throttleStorage.set(lastLogKey, now)\n  }\n\n  // Get existing results and update INP data\n  const existingResults = getTabResults(tabId) || {}\n  existingResults.inp = {\n    value: request.value,\n    entries: request.entries,\n    rating: request.rating,\n    status: request.status,\n  }\n\n  storeTabResults(tabId, existingResults)\n\n  // Forward to detached windows\n  forwardToDetachedWindows(request)\n}\n\n/**\n * Forwards messages to detached windows\n * @param {Object} message - Message to forward\n */\nasync function forwardToDetachedWindows(message) {\n  try {\n    const currentState = await getWindowState()\n    if (currentState === WINDOW_STATES.DETACHED) {\n      // Send message to all extension contexts (including detached windows)\n      chrome.runtime.sendMessage(message).catch(() => {\n        // Ignore errors if no receivers\n      })\n    }\n  } catch (error) {\n    console.debug(\"âš ï¸ [Window] Error forwarding to detached windows:\", error)\n  }\n}\n\n/**\n * Handles requests for analysis results\n * @param {Object} request - The request object\n * @param {Function} sendResponse - The response callback\n */\nfunction handleGetAnalysisResults(request, sendResponse) {\n  const results = getTabResults(request.tabId)\n  console.log(\n    \"ðŸ’» [Local Analysis] Retrieving local analysis results for tab:\",\n    request.tabId,\n    results ? \"âœ… found\" : \"âŒ not found\",\n  )\n  sendResponse(results)\n}\n\n/**\n * Handles parameter update requests\n * @param {Object} request - The request object\n * @param {Function} sendResponse - The response callback\n * @param {Object} chrome - The Chrome API object\n */\nfunction handleUpdateParameters(request, sendResponse, chrome) {\n  // If a specific tab ID is provided, use it; otherwise fall back to active tab\n  if (request.tabId) {\n    console.log(\"âš™ï¸ [Parameters] Updating parameters for specific tab:\", request.tabId)\n\n    chrome.tabs.get(request.tabId, (tab) => {\n      if (chrome.runtime.lastError || !tab) {\n        console.error(\"âŒ [Parameters] Tab not found:\", request.tabId, chrome.runtime.lastError)\n        sendResponse({ urlChanged: false, error: \"Tab not found\" })\n        return\n      }\n\n      let changed = false\n\n      if (request.add) {\n        changed = addTabParameter(tab.id, request.parameter)\n      } else {\n        changed = removeTabParameter(tab.id, request.parameter)\n      }\n\n      if (changed) {\n        applyParametersToTab(tab.id, chrome)\n      }\n\n      sendResponse({ urlChanged: changed })\n    })\n  } else {\n    // Fallback to active tab behavior\n    chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {\n      if (chrome.runtime.lastError || !tabs || tabs.length === 0) {\n        sendResponse({ urlChanged: false, error: \"No active tab found\" })\n        return\n      }\n\n      const activeTab = tabs[0]\n      let changed = false\n\n      if (request.add) {\n        changed = addTabParameter(activeTab.id, request.parameter)\n      } else {\n        changed = removeTabParameter(activeTab.id, request.parameter)\n      }\n\n      if (changed) {\n        applyParametersToTab(activeTab.id, chrome)\n      }\n\n      sendResponse({ urlChanged: changed })\n    })\n  }\n}\n\n/**\n * Handles requests for parameters\n * @param {Function} sendResponse - The response callback\n * @param {Object} chrome - The Chrome API object\n */\nfunction handleGetParameters(sendResponse, chrome) {\n  // If a specific tab ID is provided in the request, use it\n  const request = arguments[2] // Get the original request object\n\n  if (request && request.tabId) {\n    console.log(\"âš™ï¸ [Parameters] Getting parameters for specific tab:\", request.tabId)\n    const params = getTabParameters(request.tabId)\n    sendResponse(Array.from(params))\n    return\n  }\n\n  // Fallback to active tab behavior\n  chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {\n    if (chrome.runtime.lastError || !tabs || tabs.length === 0) {\n      sendResponse([])\n      return\n    }\n\n    const activeTab = tabs[0]\n    const params = getTabParameters(activeTab.id)\n    sendResponse(Array.from(params))\n  })\n}\n\n/**\n * Handles popup detachment requests\n * @param {Function} sendResponse - The response callback\n * @param {Object} chrome - The Chrome API object\n */\nasync function handleDetachPopup(sendResponse, chrome) {\n  try {\n    console.log(\"ðŸªŸ [Window] Creating detached popup window\")\n\n    // Get the current active tab ID to pass to the detached window\n    const tabs = await new Promise((resolve) => {\n      chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {\n        if (chrome.runtime.lastError) {\n          resolve([])\n        } else {\n          resolve(tabs || [])\n        }\n      })\n    })\n\n    const originalTabId = tabs.length > 0 ? tabs[0].id : null\n\n    console.log(\"ðŸªŸ [Window] Original tab ID for detached window:\", originalTabId)\n\n    const window = await createDetachedWindow(originalTabId)\n    sendResponse({ success: true, windowId: window.id, originalTabId })\n  } catch (error) {\n    console.error(\"âŒ [Window] Failed to create detached window:\", error)\n    sendResponse({ success: false, error: error.message })\n  }\n}\n\n/**\n * Handles popup attachment requests\n * @param {Function} sendResponse - The response callback\n */\nasync function handleAttachPopup(sendResponse) {\n  try {\n    console.log(\"ðŸ“Ž [Window] Attaching popup to extension icon\")\n    await attachPopup()\n    sendResponse({ success: true })\n  } catch (error) {\n    console.error(\"âŒ [Window] Failed to attach popup:\", error)\n    sendResponse({ success: false, error: error.message })\n  }\n}\n\n/**\n * Handles window state requests\n * @param {Function} sendResponse - The response callback\n */\nasync function handleGetWindowState(sendResponse) {\n  try {\n    const state = await getCurrentWindowState()\n    sendResponse({ state })\n  } catch (error) {\n    sendResponse({ state: \"attached\", error: error.message })\n  }\n}\n","/**\n * Module for managing tab-specific data\n */\n\n// Store analysis results per tab\nconst tabResults = new Map()\n// Store PSI results per tab\nconst tabPSIResults = new Map()\n\n/**\n * Stores analysis results for a specific tab\n * @param {number} tabId - The ID of the tab\n * @param {Object} results - The analysis results to store\n */\nexport function storeTabResults(tabId, results) {\n  tabResults.set(tabId, results)\n}\n\n/**\n * Gets analysis results for a specific tab\n * @param {number} tabId - The ID of the tab\n * @returns {Object|null} The analysis results or null if not found\n */\nexport function getTabResults(tabId) {\n  return tabResults.get(tabId) || null\n}\n\n/**\n * Stores PSI results for a specific tab\n * @param {number} tabId - The ID of the tab\n * @param {Object} psiResults - The PSI results to store\n */\nexport function storePSIResults(tabId, psiResults) {\n  tabPSIResults.set(tabId, psiResults)\n}\n\n/**\n * Gets PSI results for a specific tab\n * @param {number} tabId - The ID of the tab\n * @returns {Object|null} The PSI results or null if not found\n */\nexport function getPSIResults(tabId) {\n  return tabPSIResults.get(tabId) || null\n}\n\n/**\n * Removes stored PSI data for a tab\n * @param {number} tabId - The ID of the tab to clean up\n */\nexport function cleanupPSIResults(tabId) {\n  tabPSIResults.delete(tabId)\n}\n\n/**\n * Removes stored data for a tab\n * @param {number} tabId - The ID of the tab to clean up\n */\nexport function cleanupTab(tabId) {\n  tabResults.delete(tabId)\n  cleanupPSIResults(tabId) // Also cleanup PSI results\n}\n","/**\n * Module for managing URL parameters\n */\n\n// Store query parameters per tab\nconst tabParameters = new Map()\n\n/**\n * Updates URL with parameters\n * @param {string} url - The original URL\n * @param {Set} parameters - Set of parameters to add\n * @returns {string} The updated URL\n */\nexport function updateUrlWithParameters(url, parameters) {\n  try {\n    const urlObj = new URL(url)\n    urlObj.searchParams.forEach((value, key) => {\n      if (!parameters.has(key)) {\n        urlObj.searchParams.delete(key)\n      }\n    })\n    parameters.forEach((param) => {\n      urlObj.searchParams.set(param, \"\")\n    })\n    return urlObj.toString()\n  } catch (error) {\n    return url // Return original URL if there's an error\n  }\n}\n\n/**\n * Gets parameters from a URL\n * @param {string} url - The URL to extract parameters from\n * @returns {Set} Set of parameter names\n */\nexport function getParametersFromUrl(url) {\n  try {\n    const urlObj = new URL(url)\n    return new Set(urlObj.searchParams.keys())\n  } catch (error) {\n    return new Set()\n  }\n}\n\n/**\n * Stores parameters for a specific tab\n * @param {number} tabId - The ID of the tab\n * @param {Set} parameters - The parameters to store\n */\nexport function storeTabParameters(tabId, parameters) {\n  tabParameters.set(tabId, parameters)\n}\n\n/**\n * Gets parameters for a specific tab\n * @param {number} tabId - The ID of the tab\n * @returns {Set} The stored parameters or an empty Set if not found\n */\nexport function getTabParameters(tabId) {\n  return tabParameters.get(tabId) || new Set()\n}\n\n/**\n * Adds a parameter to a tab\n * @param {number} tabId - The ID of the tab\n * @param {string} parameter - The parameter to add\n * @returns {boolean} True if the parameter was added, false if it was already present\n */\nexport function addTabParameter(tabId, parameter) {\n  let params = tabParameters.get(tabId)\n  if (!params) {\n    params = new Set()\n    tabParameters.set(tabId, params)\n  }\n\n  if (params.has(parameter)) {\n    return false\n  }\n\n  params.add(parameter)\n  return true\n}\n\n/**\n * Removes a parameter from a tab\n * @param {number} tabId - The ID of the tab\n * @param {string} parameter - The parameter to remove\n * @returns {boolean} True if the parameter was removed, false if it wasn't present\n */\nexport function removeTabParameter(tabId, parameter) {\n  const params = tabParameters.get(tabId)\n  if (!params || !params.has(parameter)) {\n    return false\n  }\n\n  params.delete(parameter)\n  return true\n}\n\n/**\n * Removes stored parameters for a tab\n * @param {number} tabId - The ID of the tab to clean up\n */\nexport function cleanupTabParameters(tabId) {\n  tabParameters.delete(tabId)\n}\n\n/**\n * Applies stored parameters to a tab's URL\n * @param {number} tabId - The ID of the tab\n * @param {Object} chrome - The Chrome API object\n */\nexport function applyParametersToTab(tabId, chrome) {\n  chrome.tabs.get(tabId, (tab) => {\n    if (chrome.runtime.lastError) {\n      return\n    }\n    const params = getTabParameters(tabId)\n    const currentUrlParams = getParametersFromUrl(tab.url)\n    const newUrl = updateUrlWithParameters(tab.url, params)\n    if (newUrl !== tab.url && !setsEqual(params, currentUrlParams)) {\n      chrome.tabs.update(tabId, { url: newUrl })\n    }\n  })\n}\n\n/**\n * Compares two sets for equality\n * @param {Set} a - First set\n * @param {Set} b - Second set\n * @returns {boolean} True if sets are equal\n */\nfunction setsEqual(a, b) {\n  return a.size === b.size && [...a].every((value) => b.has(value))\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * Background service worker for the BigScoots Performance Debugger extension\n */\n\nimport { cleanupTab } from \"./tab-manager.js\"\nimport {\n  cleanupTabParameters,\n  getParametersFromUrl,\n  updateUrlWithParameters,\n  getTabParameters,\n} from \"./parameter-manager.js\"\nimport { setupMessageHandlers, handleExtensionIconClick } from \"./message-handler.js\"\nimport { handleDetachedWindowClosed, saveWindowBounds, isDetachedWindow } from \"./window-manager.js\"\n\n// Declare chrome variable\n\n// Set up message handlers\nsetupMessageHandlers(chrome)\n\n// Handle extension icon clicks with proper async handling\nchrome.action.onClicked.addListener(async (tab) => {\n  console.log(\"Extension icon clicked for tab:\", tab.id)\n  const handled = await handleExtensionIconClick()\n  console.log(\"Icon click handled:\", handled)\n\n  // If handled is true, we focused a detached window and should prevent default popup\n  // If handled is false, Chrome will show the default popup\n})\n\n// Handle tab removal\nchrome.tabs.onRemoved.addListener((tabId) => {\n  cleanupTab(tabId)\n  cleanupTabParameters(tabId)\n})\n\n// Handle navigation events\nchrome.webNavigation.onBeforeNavigate.addListener((details) => {\n  if (details.frameId === 0) {\n    try {\n      // Only handle main frame navigation\n      const currentParams = getTabParameters(details.tabId)\n      if (currentParams && currentParams.size > 0) {\n        const urlParams = getParametersFromUrl(details.url)\n        const mergedParams = new Set([...urlParams, ...currentParams])\n\n        // Update URL only if new parameters were added\n        if (mergedParams.size > urlParams.size) {\n          const newUrl = updateUrlWithParameters(details.url, mergedParams)\n          if (newUrl !== details.url) {\n            chrome.tabs.update(details.tabId, { url: newUrl })\n          }\n        }\n      }\n    } catch (error) {\n      // Silent error handling\n    }\n  }\n})\n\n// Handle window removal (for detached popup cleanup)\nchrome.windows.onRemoved.addListener(async (windowId) => {\n  // Check if this is our detached window\n  const isOurWindow = await isDetachedWindow(windowId)\n  if (isOurWindow) {\n    console.log(\"Detached window closed, cleaning up\")\n    await handleDetachedWindowClosed()\n  }\n})\n\n// Handle window bounds changes (save position when user moves/resizes)\nchrome.windows.onBoundsChanged.addListener(async (window) => {\n  const isOurWindow = await isDetachedWindow(window.id)\n  if (isOurWindow) {\n    await saveWindowBounds(window.id)\n  }\n})\n\nconsole.log(\"BigScoots Performance Debugger background service worker initialized\")\n"],"names":[],"sourceRoot":""}