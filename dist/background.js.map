{"version":3,"file":"background.js","mappings":"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","sources":["webpack://new-bs-helper-extension/./src/background/tab-manager.js","webpack://new-bs-helper-extension/webpack/bootstrap","webpack://new-bs-helper-extension/webpack/runtime/define property getters","webpack://new-bs-helper-extension/webpack/runtime/hasOwnProperty shorthand","webpack://new-bs-helper-extension/webpack/runtime/make namespace object","webpack://new-bs-helper-extension/./src/background/parameter-manager.js","webpack://new-bs-helper-extension/./src/utils/window-state.js","webpack://new-bs-helper-extension/./src/background/window-manager.js","webpack://new-bs-helper-extension/./src/background/message-handler.js","webpack://new-bs-helper-extension/./src/background/index.js"],"sourcesContent":["/**\n * Module for managing tab-specific data\n */\n\n// Store analysis results per tab\nconst tabResults = new Map()\n// Store PSI results per tab\nconst tabPSIResults = new Map()\n\n/**\n * Stores analysis results for a specific tab\n * @param {number} tabId - The ID of the tab\n * @param {Object} results - The analysis results to store\n */\nexport function storeTabResults(tabId, results) {\n  tabResults.set(tabId, results)\n}\n\n/**\n * Gets analysis results for a specific tab\n * @param {number} tabId - The ID of the tab\n * @returns {Object|null} The analysis results or null if not found\n */\nexport function getTabResults(tabId) {\n  return tabResults.get(tabId) || null\n}\n\n/**\n * Stores PSI results for a specific tab\n * @param {number} tabId - The ID of the tab\n * @param {Object} psiResults - The PSI results to store\n */\nexport function storePSIResults(tabId, psiResults) {\n  tabPSIResults.set(tabId, psiResults)\n}\n\n/**\n * Gets PSI results for a specific tab\n * @param {number} tabId - The ID of the tab\n * @returns {Object|null} The PSI results or null if not found\n */\nexport function getPSIResults(tabId) {\n  return tabPSIResults.get(tabId) || null\n}\n\n/**\n * Removes stored PSI data for a tab\n * @param {number} tabId - The ID of the tab to clean up\n */\nexport function cleanupPSIResults(tabId) {\n  tabPSIResults.delete(tabId)\n}\n\n/**\n * Removes stored data for a tab\n * @param {number} tabId - The ID of the tab to clean up\n */\nexport function cleanupTab(tabId) {\n  tabResults.delete(tabId)\n  cleanupPSIResults(tabId) // Also cleanup PSI results\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * Module for managing URL parameters\n */\n\n// Store query parameters per tab\nconst tabParameters = new Map()\n\n/**\n * Updates URL with parameters\n * @param {string} url - The original URL\n * @param {Set} parameters - Set of parameters to add\n * @returns {string} The updated URL\n */\nexport function updateUrlWithParameters(url, parameters) {\n  try {\n    const urlObj = new URL(url)\n    urlObj.searchParams.forEach((value, key) => {\n      if (!parameters.has(key)) {\n        urlObj.searchParams.delete(key)\n      }\n    })\n    parameters.forEach((param) => {\n      urlObj.searchParams.set(param, \"\")\n    })\n    return urlObj.toString()\n  } catch (error) {\n    return url // Return original URL if there's an error\n  }\n}\n\n/**\n * Gets parameters from a URL\n * @param {string} url - The URL to extract parameters from\n * @returns {Set} Set of parameter names\n */\nexport function getParametersFromUrl(url) {\n  try {\n    const urlObj = new URL(url)\n    return new Set(urlObj.searchParams.keys())\n  } catch (error) {\n    return new Set()\n  }\n}\n\n/**\n * Stores parameters for a specific tab\n * @param {number} tabId - The ID of the tab\n * @param {Set} parameters - The parameters to store\n */\nexport function storeTabParameters(tabId, parameters) {\n  tabParameters.set(tabId, parameters)\n}\n\n/**\n * Gets parameters for a specific tab\n * @param {number} tabId - The ID of the tab\n * @returns {Set} The stored parameters or an empty Set if not found\n */\nexport function getTabParameters(tabId) {\n  return tabParameters.get(tabId) || new Set()\n}\n\n/**\n * Adds a parameter to a tab\n * @param {number} tabId - The ID of the tab\n * @param {string} parameter - The parameter to add\n * @returns {boolean} True if the parameter was added, false if it was already present\n */\nexport function addTabParameter(tabId, parameter) {\n  let params = tabParameters.get(tabId)\n  if (!params) {\n    params = new Set()\n    tabParameters.set(tabId, params)\n  }\n\n  if (params.has(parameter)) {\n    return false\n  }\n\n  params.add(parameter)\n  return true\n}\n\n/**\n * Removes a parameter from a tab\n * @param {number} tabId - The ID of the tab\n * @param {string} parameter - The parameter to remove\n * @returns {boolean} True if the parameter was removed, false if it wasn't present\n */\nexport function removeTabParameter(tabId, parameter) {\n  const params = tabParameters.get(tabId)\n  if (!params || !params.has(parameter)) {\n    return false\n  }\n\n  params.delete(parameter)\n  return true\n}\n\n/**\n * Removes stored parameters for a tab\n * @param {number} tabId - The ID of the tab to clean up\n */\nexport function cleanupTabParameters(tabId) {\n  tabParameters.delete(tabId)\n}\n\n/**\n * Applies stored parameters to a tab's URL\n * @param {number} tabId - The ID of the tab\n * @param {Object} chrome - The Chrome API object\n */\nexport function applyParametersToTab(tabId, chrome) {\n  chrome.tabs.get(tabId, (tab) => {\n    if (chrome.runtime.lastError) {\n      return\n    }\n    const params = getTabParameters(tabId)\n    const currentUrlParams = getParametersFromUrl(tab.url)\n    const newUrl = updateUrlWithParameters(tab.url, params)\n    if (newUrl !== tab.url && !setsEqual(params, currentUrlParams)) {\n      chrome.tabs.update(tabId, { url: newUrl })\n    }\n  })\n}\n\n/**\n * Compares two sets for equality\n * @param {Set} a - First set\n * @param {Set} b - Second set\n * @returns {boolean} True if sets are equal\n */\nfunction setsEqual(a, b) {\n  return a.size === b.size && [...a].every((value) => b.has(value))\n}\n","/**\n * Utility module for managing popup window state - Enhanced with bounds validation\n */\n\n// Window state constants\nexport const WINDOW_STATES = {\n  ATTACHED: \"attached\",\n  DETACHED: \"detached\",\n}\n\n// Storage keys\nexport const STORAGE_KEYS = {\n  WINDOW_STATE: \"popup_window_state\",\n  DETACHED_WINDOW_ID: \"detached_window_id\",\n  WINDOW_BOUNDS: \"detached_window_bounds\",\n}\n\n// Default window dimensions - Conservative sizes for better compatibility\nexport const DEFAULT_WINDOW_CONFIG = {\n  width: 700, // Reduced from 800\n  height: 600, // Reduced from 700\n  type: \"popup\",\n  focused: true,\n}\n\n// Declare chrome variable\nconst chrome = globalThis.chrome || self.chrome\n\n/**\n * Gets the current window state from storage\n * @returns {Promise<string>} Current window state\n */\nexport async function getWindowState() {\n  try {\n    const result = await chrome.storage.local.get(STORAGE_KEYS.WINDOW_STATE)\n    return result[STORAGE_KEYS.WINDOW_STATE] || WINDOW_STATES.ATTACHED\n  } catch (error) {\n    console.debug(\"Error getting window state:\", error)\n    return WINDOW_STATES.ATTACHED\n  }\n}\n\n/**\n * Sets the window state in storage\n * @param {string} state - The window state to set\n */\nexport async function setWindowState(state) {\n  try {\n    await chrome.storage.local.set({ [STORAGE_KEYS.WINDOW_STATE]: state })\n  } catch (error) {\n    console.debug(\"Error setting window state:\", error)\n  }\n}\n\n/**\n * Gets the detached window ID from storage\n * @returns {Promise<number|null>} Window ID or null\n */\nexport async function getDetachedWindowId() {\n  try {\n    const result = await chrome.storage.local.get(STORAGE_KEYS.DETACHED_WINDOW_ID)\n    return result[STORAGE_KEYS.DETACHED_WINDOW_ID] || null\n  } catch (error) {\n    console.debug(\"Error getting detached window ID:\", error)\n    return null\n  }\n}\n\n/**\n * Sets the detached window ID in storage\n * @param {number|null} windowId - The window ID to store\n */\nexport async function setDetachedWindowId(windowId) {\n  try {\n    if (windowId === null) {\n      await chrome.storage.local.remove(STORAGE_KEYS.DETACHED_WINDOW_ID)\n    } else {\n      await chrome.storage.local.set({ [STORAGE_KEYS.DETACHED_WINDOW_ID]: windowId })\n    }\n  } catch (error) {\n    console.debug(\"Error setting detached window ID:\", error)\n  }\n}\n\n/**\n * Gets saved window bounds from storage with validation\n * @returns {Promise<Object|null>} Window bounds or null\n */\nexport async function getWindowBounds() {\n  try {\n    const result = await chrome.storage.local.get(STORAGE_KEYS.WINDOW_BOUNDS)\n    const bounds = result[STORAGE_KEYS.WINDOW_BOUNDS]\n\n    // Validate bounds before returning\n    if (bounds && typeof bounds === \"object\") {\n      // Check if bounds seem reasonable\n      if (\n        bounds.width >= 300 &&\n        bounds.height >= 200 &&\n        bounds.width <= 2000 &&\n        bounds.height <= 1500 &&\n        typeof bounds.left === \"number\" &&\n        typeof bounds.top === \"number\"\n      ) {\n        return bounds\n      } else {\n        console.log(\"Stored bounds seem invalid, ignoring:\", bounds)\n        // Clear invalid bounds\n        await setWindowBounds(null)\n        return null\n      }\n    }\n\n    return null\n  } catch (error) {\n    console.debug(\"Error getting window bounds:\", error)\n    return null\n  }\n}\n\n/**\n * Saves window bounds to storage with validation\n * @param {Object|null} bounds - Window bounds object\n */\nexport async function setWindowBounds(bounds) {\n  try {\n    if (bounds === null) {\n      await chrome.storage.local.remove(STORAGE_KEYS.WINDOW_BOUNDS)\n      console.log(\"Window bounds cleared\")\n    } else {\n      // Validate bounds before saving\n      if (\n        bounds &&\n        typeof bounds === \"object\" &&\n        bounds.width >= 300 &&\n        bounds.height >= 200 &&\n        bounds.width <= 2000 &&\n        bounds.height <= 1500 &&\n        typeof bounds.left === \"number\" &&\n        typeof bounds.top === \"number\"\n      ) {\n        await chrome.storage.local.set({ [STORAGE_KEYS.WINDOW_BOUNDS]: bounds })\n        console.log(\"Window bounds saved:\", bounds)\n      } else {\n        console.log(\"Invalid bounds not saved:\", bounds)\n      }\n    }\n  } catch (error) {\n    console.debug(\"Error setting window bounds:\", error)\n  }\n}\n\n/**\n * Gets the original tab ID from storage\n * @returns {Promise<number|null>} Original tab ID or null\n */\nexport async function getOriginalTabId() {\n  try {\n    const result = await chrome.storage.local.get(\"originalTabId\")\n    return result.originalTabId || null\n  } catch (error) {\n    console.debug(\"Error getting original tab ID:\", error)\n    return null\n  }\n}\n\n/**\n * Sets the original tab ID in storage\n * @param {number|null} tabId - The tab ID to store\n */\nexport async function setOriginalTabId(tabId) {\n  try {\n    if (tabId === null) {\n      await chrome.storage.local.remove(\"originalTabId\")\n    } else {\n      await chrome.storage.local.set({ originalTabId: tabId })\n    }\n  } catch (error) {\n    console.debug(\"Error setting original tab ID:\", error)\n  }\n}\n\n/**\n * Clears the original tab ID from storage\n */\nexport async function clearOriginalTabId() {\n  try {\n    await chrome.storage.local.remove(\"originalTabId\")\n  } catch (error) {\n    console.debug(\"Error clearing original tab ID:\", error)\n  }\n}\n\n/**\n * Checks if current window is the detached popup window\n * @returns {Promise<boolean>} True if this is the detached window\n */\nexport async function isCurrentWindowDetached() {\n  try {\n    const currentWindowId = await getCurrentWindowId()\n    const detachedWindowId = await getDetachedWindowId()\n    return currentWindowId === detachedWindowId\n  } catch (error) {\n    console.debug(\"Error checking if current window is detached:\", error)\n    return false\n  }\n}\n\n/**\n * Gets the current window ID\n * @returns {Promise<number|null>} Current window ID or null\n */\nexport async function getCurrentWindowId() {\n  try {\n    const currentWindow = await chrome.windows.getCurrent()\n    return currentWindow.id\n  } catch (error) {\n    console.debug(\"Error getting current window ID:\", error)\n    return null\n  }\n}\n","/**\n * Module for managing detachable popup windows - Enhanced bounds validation\n */\n\nimport {\n  getWindowState,\n  setWindowState,\n  getDetachedWindowId,\n  setDetachedWindowId,\n  getWindowBounds,\n  setWindowBounds,\n  setOriginalTabId,\n  WINDOW_STATES,\n  DEFAULT_WINDOW_CONFIG,\n} from \"../utils/window-state.js\"\n\n// Declare the chrome variable\nconst chrome = globalThis.chrome || self.chrome\n\n// Track the current detached window\nlet detachedWindow = null\n\n/**\n * Validates and corrects window bounds to ensure they're within screen limits\n * @param {Object} bounds - Window bounds to validate\n * @returns {Promise<Object>} Validated bounds\n */\nasync function validateWindowBounds(bounds) {\n  try {\n    // Get all available displays\n    const displays = await new Promise((resolve) => {\n      if (chrome.system && chrome.system.display) {\n        chrome.system.display.getInfo((displays) => {\n          if (chrome.runtime.lastError) {\n            resolve([])\n          } else {\n            resolve(displays || [])\n          }\n        })\n      } else {\n        resolve([])\n      }\n    })\n\n    // If we can't get display info, use safe defaults\n    if (!displays || displays.length === 0) {\n      console.log(\"No display info available, using safe defaults\")\n      return {\n        left: 100,\n        top: 100,\n        width: Math.min(bounds.width || DEFAULT_WINDOW_CONFIG.width, 1200),\n        height: Math.min(bounds.height || DEFAULT_WINDOW_CONFIG.height, 800),\n      }\n    }\n\n    // Find the primary display or the largest one\n    const primaryDisplay = displays.find((d) => d.isPrimary) || displays[0]\n    const screenBounds = primaryDisplay.bounds\n\n    console.log(\"Screen bounds:\", screenBounds)\n    console.log(\"Requested bounds:\", bounds)\n\n    // Calculate safe bounds\n    const safeWidth = Math.min(bounds.width || DEFAULT_WINDOW_CONFIG.width, screenBounds.width - 100)\n    const safeHeight = Math.min(bounds.height || DEFAULT_WINDOW_CONFIG.height, screenBounds.height - 100)\n\n    // Ensure window is at least 50% within screen bounds\n    const minLeft = screenBounds.left - Math.floor(safeWidth * 0.5)\n    const maxLeft = screenBounds.left + screenBounds.width - Math.floor(safeWidth * 0.5)\n    const minTop = screenBounds.top - Math.floor(safeHeight * 0.5)\n    const maxTop = screenBounds.top + screenBounds.height - Math.floor(safeHeight * 0.5)\n\n    let safeLeft = bounds.left || 100\n    let safeTop = bounds.top || 100\n\n    // Clamp to safe ranges\n    safeLeft = Math.max(minLeft, Math.min(maxLeft, safeLeft))\n    safeTop = Math.max(minTop, Math.min(maxTop, safeTop))\n\n    // Additional safety check - ensure window is mostly visible\n    if (safeLeft + safeWidth < screenBounds.left + 100) {\n      safeLeft = screenBounds.left + 100\n    }\n    if (safeTop + safeHeight < screenBounds.top + 100) {\n      safeTop = screenBounds.top + 100\n    }\n\n    const validatedBounds = {\n      left: safeLeft,\n      top: safeTop,\n      width: safeWidth,\n      height: safeHeight,\n    }\n\n    console.log(\"Validated bounds:\", validatedBounds)\n    return validatedBounds\n  } catch (error) {\n    console.error(\"Error validating window bounds:\", error)\n    // Return safe fallback bounds\n    return {\n      left: 100,\n      top: 100,\n      width: Math.min(bounds.width || DEFAULT_WINDOW_CONFIG.width, 1000),\n      height: Math.min(bounds.height || DEFAULT_WINDOW_CONFIG.height, 700),\n    }\n  }\n}\n\n/**\n * Creates a detached popup window with validated bounds\n * @param {number} originalTabId - The ID of the original tab\n * @returns {Promise<chrome.windows.Window>} Created window\n */\nexport async function createDetachedWindow(originalTabId) {\n  try {\n    console.log(\"Creating detached window for tab:\", originalTabId)\n\n    // Get saved bounds or use defaults\n    const savedBounds = await getWindowBounds()\n    console.log(\"Saved bounds:\", savedBounds)\n\n    // Use saved bounds or defaults\n    const requestedBounds = savedBounds || {\n      left: 100,\n      top: 100,\n      width: DEFAULT_WINDOW_CONFIG.width,\n      height: DEFAULT_WINDOW_CONFIG.height,\n    }\n\n    // Validate bounds to ensure they're within screen limits\n    const validatedBounds = await validateWindowBounds(requestedBounds)\n\n    // Include original tab ID in the URL\n    const popupUrl = originalTabId\n      ? `${chrome.runtime.getURL(\"popup.html\")}?originalTabId=${originalTabId}`\n      : chrome.runtime.getURL(\"popup.html\")\n\n    const windowConfig = {\n      url: popupUrl,\n      type: \"popup\",\n      focused: true,\n      ...validatedBounds,\n    }\n\n    console.log(\"Creating window with config:\", windowConfig)\n\n    const window = await chrome.windows.create(windowConfig)\n    detachedWindow = window\n\n    await setDetachedWindowId(window.id)\n    await setWindowState(WINDOW_STATES.DETACHED)\n\n    // Store the original tab ID in storage as backup\n    if (originalTabId) {\n      await setOriginalTabId(originalTabId)\n    }\n\n    console.log(\"Successfully created detached window with ID:\", window.id)\n    return window\n  } catch (error) {\n    console.error(\"Error creating detached window:\", error)\n\n    // Try with minimal safe bounds as fallback\n    try {\n      console.log(\"Attempting fallback window creation with minimal bounds\")\n\n      const fallbackConfig = {\n        url: originalTabId\n          ? `${chrome.runtime.getURL(\"popup.html\")}?originalTabId=${originalTabId}`\n          : chrome.runtime.getURL(\"popup.html\"),\n        type: \"popup\",\n        focused: true,\n        left: 100,\n        top: 100,\n        width: 600,\n        height: 500,\n      }\n\n      const window = await chrome.windows.create(fallbackConfig)\n      detachedWindow = window\n\n      await setDetachedWindowId(window.id)\n      await setWindowState(WINDOW_STATES.DETACHED)\n\n      if (originalTabId) {\n        await setOriginalTabId(originalTabId)\n      }\n\n      console.log(\"Fallback window creation successful:\", window.id)\n      return window\n    } catch (fallbackError) {\n      console.error(\"Fallback window creation also failed:\", fallbackError)\n      throw fallbackError\n    }\n  }\n}\n\n/**\n * Focuses the detached window if it exists\n * @returns {Promise<boolean>} True if window was focused successfully\n */\nexport async function focusDetachedWindow() {\n  try {\n    const windowId = await getDetachedWindowId()\n    console.log(\"Attempting to focus detached window ID:\", windowId)\n\n    if (windowId) {\n      try {\n        // Check if window still exists\n        const window = await chrome.windows.get(windowId)\n        if (window) {\n          console.log(\"Window found, focusing...\")\n\n          // Bring window to front and focus it\n          await chrome.windows.update(windowId, {\n            focused: true,\n            state: \"normal\", // Ensure it's not minimized\n          })\n\n          // Additional focus attempt for better visibility\n          setTimeout(async () => {\n            try {\n              await chrome.windows.update(windowId, { focused: true })\n            } catch (e) {\n              console.debug(\"Secondary focus attempt failed:\", e)\n            }\n          }, 100)\n\n          console.log(\"Successfully focused detached window\")\n          return true\n        }\n      } catch (error) {\n        console.log(\"Window doesn't exist, cleaning up:\", error)\n        // Window doesn't exist, clean up\n        await handleDetachedWindowClosed()\n        return false\n      }\n    }\n\n    console.log(\"No detached window ID found\")\n    return false\n  } catch (error) {\n    console.debug(\"Error focusing detached window:\", error)\n    return false\n  }\n}\n\n/**\n * Handles cleanup when detached window is closed\n */\nexport async function handleDetachedWindowClosed() {\n  console.log(\"Cleaning up detached window state\")\n  detachedWindow = null\n  await setDetachedWindowId(null)\n  await setWindowState(WINDOW_STATES.ATTACHED)\n}\n\n/**\n * Saves current window bounds before closing with validation\n * @param {number} windowId - Window ID to save bounds for\n */\nexport async function saveWindowBounds(windowId) {\n  try {\n    const window = await chrome.windows.get(windowId)\n\n    // Only save bounds if they seem reasonable\n    if (\n      window.left >= -1000 &&\n      window.top >= -1000 &&\n      window.width >= 300 &&\n      window.height >= 200 &&\n      window.width <= 2000 &&\n      window.height <= 1500\n    ) {\n      const bounds = {\n        left: window.left,\n        top: window.top,\n        width: window.width,\n        height: window.height,\n      }\n\n      await setWindowBounds(bounds)\n      console.log(\"Saved window bounds:\", bounds)\n    } else {\n      console.log(\"Window bounds seem invalid, not saving:\", {\n        left: window.left,\n        top: window.top,\n        width: window.width,\n        height: window.height,\n      })\n    }\n  } catch (error) {\n    console.debug(\"Error saving window bounds:\", error)\n  }\n}\n\n/**\n * Attaches the popup back to the extension icon\n */\nexport async function attachPopup() {\n  const windowId = await getDetachedWindowId()\n  console.log(\"Attaching popup, current detached window ID:\", windowId)\n\n  if (windowId) {\n    try {\n      // Save bounds before closing\n      await saveWindowBounds(windowId)\n      await chrome.windows.remove(windowId)\n      console.log(\"Closed detached window\")\n    } catch (error) {\n      console.debug(\"Error closing detached window:\", error)\n    }\n  }\n\n  await handleDetachedWindowClosed()\n}\n\n/**\n * Gets the current window state\n * @returns {Promise<string>} Current window state\n */\nexport async function getCurrentWindowState() {\n  return await getWindowState()\n}\n\n/**\n * Checks if a window ID matches our detached window\n * @param {number} windowId - Window ID to check\n * @returns {Promise<boolean>} True if it's our detached window\n */\nexport async function isDetachedWindow(windowId) {\n  const detachedWindowId = await getDetachedWindowId()\n  return detachedWindowId === windowId\n}\n\n/**\n * Resets stored window bounds (useful for debugging)\n */\nexport async function resetWindowBounds() {\n  try {\n    await setWindowBounds(null)\n    console.log(\"Window bounds reset\")\n  } catch (error) {\n    console.error(\"Error resetting window bounds:\", error)\n  }\n}\n","/**\n * Module for handling extension messages - Enhanced for all PSI metrics including Lab data\n */\n\nimport { storeTabResults, getTabResults } from \"./tab-manager.js\"\nimport { getTabParameters, addTabParameter, removeTabParameter, applyParametersToTab } from \"./parameter-manager.js\"\nimport {\n  createDetachedWindow,\n  attachPopup,\n  getCurrentWindowState,\n  focusDetachedWindow,\n  handleDetachedWindowClosed,\n} from \"./window-manager.js\"\nimport { getWindowState, WINDOW_STATES } from \"../utils/window-state.js\"\n\n// Storage for throttling timestamps (replaces window usage in service worker)\nconst throttleStorage = new Map()\n\n// Declare chrome variable\nconst chrome = globalThis.chrome || self.chrome\n\n/**\n * Sets up message handlers for the extension\n * @param {Object} chrome - The Chrome API object\n */\nexport function setupMessageHandlers(chrome) {\n  chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {\n    if (request.action === \"updateBadge\") {\n      handleUpdateBadge(request, sender, chrome)\n    } else if (request.action === \"analysisResults\") {\n      handleAnalysisResults(request, sender)\n    } else if (request.action === \"updateINP\") {\n      handleINPUpdate(request, sender)\n    } else if (request.action === \"storePSIResults\") {\n      handleStorePSIResults(request, sender)\n    } else if (request.action === \"getPSIResults\") {\n      handleGetPSIResults(request, sendResponse)\n      return true\n    } else if (request.action === \"updatePSICLS\") {\n      handlePSIMetricUpdate(request, sender, \"cls\")\n    } else if (request.action === \"updatePSILCP\") {\n      handlePSIMetricUpdate(request, sender, \"lcp\")\n    } else if (request.action === \"updatePSIINP\") {\n      handlePSIMetricUpdate(request, sender, \"inp\")\n    } else if (request.action === \"updatePSITTFB\") {\n      handlePSIMetricUpdate(request, sender, \"ttfb\")\n    } else if (request.action === \"updatePSILabCLS\") {\n      handlePSILabMetricUpdate(request, sender, \"cls\")\n    } else if (request.action === \"updatePSILabLCP\") {\n      handlePSILabMetricUpdate(request, sender, \"lcp\")\n    } else if (request.action === \"updatePSIStatus\") {\n      handlePSIStatusUpdate(request, sender)\n    } else if (request.action === \"getAnalysisResults\") {\n      handleGetAnalysisResults(request, sendResponse)\n      return true\n    } else if (request.action === \"updateParameters\") {\n      handleUpdateParameters(request, sendResponse, chrome)\n      return true\n    } else if (request.action === \"getParameters\") {\n      handleGetParameters(sendResponse, chrome, request)\n      return true\n    } else if (request.action === \"detachPopup\") {\n      handleDetachPopup(sendResponse, chrome)\n      return true\n    } else if (request.action === \"attachPopup\") {\n      handleAttachPopup(sendResponse)\n      return true\n    } else if (request.action === \"getWindowState\") {\n      handleGetWindowState(sendResponse)\n      return true\n    } else if (request.action === \"tabUrlChanged\") {\n      handleTabUrlChanged(request, sendResponse)\n      return true\n    } else if (request.action === \"getTabUrl\") {\n      handleGetTabUrl(request, sendResponse)\n      return true\n    } else if (request.action === \"completePSIResults\") {\n      handleCompletePSIResults(request, sender)\n    }\n    return true\n  })\n\n  // Add listener for tab URL changes\n  chrome.tabs.onUpdated.addListener((tabId, changeInfo, tab) => {\n    if (changeInfo.url) {\n      // Check if domain changed\n      import(\"./tab-manager.js\").then(({ getTabResults, getPSIResults, storeTabResults, storePSIResults }) => {\n        const existingResults = getTabResults(tabId)\n        const existingPSI = getPSIResults(tabId)\n\n        if (existingResults && existingResults.url) {\n          try {\n            const oldDomain = new URL(existingResults.url).hostname\n            const newDomain = new URL(changeInfo.url).hostname\n\n            if (oldDomain !== newDomain) {\n              console.log(\"ðŸ”„ [Domain Change] Clearing data for tab:\", tabId, \"from\", oldDomain, \"to\", newDomain)\n              // Clear stored data for this tab\n              storeTabResults(tabId, null)\n              storePSIResults(tabId, null)\n            }\n          } catch (error) {\n            console.log(\"Error parsing URLs for domain comparison:\", error)\n          }\n        }\n\n        if (existingPSI && existingPSI.url) {\n          try {\n            const oldDomain = new URL(existingPSI.url).hostname\n            const newDomain = new URL(changeInfo.url).hostname\n\n            if (oldDomain !== newDomain) {\n              console.log(\n                \"ðŸ”„ [PSI Domain Change] Clearing PSI data for tab:\",\n                tabId,\n                \"from\",\n                oldDomain,\n                \"to\",\n                newDomain,\n              )\n              storePSIResults(tabId, null)\n            }\n          } catch (error) {\n            console.log(\"Error parsing URLs for PSI domain comparison:\", error)\n          }\n        }\n      })\n\n      // Broadcast URL change to all extension contexts\n      chrome.runtime\n        .sendMessage({\n          action: \"tabUrlChanged\",\n          tabId: tabId,\n          url: changeInfo.url,\n        })\n        .catch(() => {\n          // Ignore errors if no receivers\n        })\n    }\n  })\n}\n\n/**\n * Handles PSI results storage\n * @param {Object} request - The request object\n * @param {Object} sender - The sender object\n */\nfunction handleStorePSIResults(request, sender) {\n  const tabId = sender.tab.id\n  const tabUrl = sender.tab.url\n  console.log(\"ðŸ“Š [PSI] Storing complete PSI results for tab:\", tabId, \"URL:\", tabUrl)\n\n  // Add URL to PSI data for verification\n  const psiDataWithUrl = {\n    ...request.psiData,\n    url: tabUrl,\n    timestamp: Date.now(),\n    // Store the complete data for insights restoration\n    completeData: request.psiData,\n  }\n\n  import(\"./tab-manager.js\").then(({ storePSIResults }) => {\n    storePSIResults(tabId, psiDataWithUrl)\n  })\n\n  // Forward to detached windows\n  forwardToDetachedWindows({ ...request, psiData: psiDataWithUrl })\n}\n\n/**\n * Handles PSI metric updates (CLS, LCP, INP, TTFB) - Field Data\n * @param {Object} request - The request object\n * @param {Object} sender - The sender object\n * @param {string} metric - The metric type (cls, lcp, inp, ttfb)\n */\nfunction handlePSIMetricUpdate(request, sender, metric) {\n  const tabId = sender.tab?.id\n  console.log(`ðŸŒ [PSI Field Data] Processing ${metric.toUpperCase()} for tab:`, tabId)\n\n  // Store field data in PSI results\n  if (tabId && request.fieldData) {\n    import(\"./tab-manager.js\").then(({ getPSIResults, storePSIResults }) => {\n      const existingPSI = getPSIResults(tabId) || { allFieldData: {}, allLabData: {} }\n\n      // Store field data\n      if (!existingPSI.allFieldData) existingPSI.allFieldData = {}\n      existingPSI.allFieldData[metric] = request.fieldData\n\n      storePSIResults(tabId, existingPSI)\n      console.log(`ðŸŒ [PSI Field Data] Stored ${metric.toUpperCase()} field data for tab:`, tabId)\n    })\n  }\n\n  // Forward to detached windows immediately\n  forwardToDetachedWindows(request)\n\n  // Log the field data for debugging\n  if (request.fieldData) {\n    console.log(`ðŸŒ [PSI Field Data] ${metric.toUpperCase()} metrics:`, {\n      percentile: `${request.fieldData.percentile}th percentile`,\n      category: request.fieldData.category,\n      value: request.fieldData.value,\n      dataSource: \"Real User Monitoring (CrUX)\",\n    })\n  }\n}\n\n/**\n * Handles PSI Lab metric updates (CLS, LCP only) - Lab Data\n * Note: TTFB is not available in lab data as it's a server-side metric\n * @param {Object} request - The request object\n * @param {Object} sender - The sender object\n * @param {string} metric - The metric type (cls, lcp)\n */\nfunction handlePSILabMetricUpdate(request, sender, metric) {\n  const tabId = sender.tab?.id\n  console.log(`ðŸ§ª [PSI Lab Data] Processing ${metric.toUpperCase()} for tab:`, tabId)\n\n  // Store lab data in PSI results\n  if (tabId && request.labData) {\n    import(\"./tab-manager.js\").then(({ getPSIResults, storePSIResults }) => {\n      const existingPSI = getPSIResults(tabId) || { allFieldData: {}, allLabData: {} }\n\n      // Store lab data with correct key format\n      if (!existingPSI.allLabData) existingPSI.allLabData = {}\n      existingPSI.allLabData[`lab${metric.toUpperCase()}`] = request.labData\n\n      storePSIResults(tabId, existingPSI)\n      console.log(`ðŸ§ª [PSI Lab Data] Stored ${metric.toUpperCase()} lab data for tab:`, tabId)\n    })\n  }\n\n  // Forward to detached windows immediately\n  forwardToDetachedWindows(request)\n\n  // Log the lab data for debugging\n  if (request.labData) {\n    console.log(`ðŸ§ª [PSI Lab Data] ${metric.toUpperCase()} metrics:`, {\n      numericValue: request.labData.numericValue,\n      displayValue: request.labData.displayValue,\n      score: request.labData.score,\n      dataSource: \"Lighthouse Lab Environment\",\n    })\n  }\n}\n\n/**\n * Handles PSI status updates\n * @param {Object} request - The request object\n * @param {Object} sender - The sender object\n */\nfunction handlePSIStatusUpdate(request, sender) {\n  const tabId = sender.tab?.id\n  const statusIcon =\n    request.status === \"loading\" ? \"â³\" : request.status === \"success\" ? \"âœ…\" : request.status === \"error\" ? \"âŒ\" : \"â„¹ï¸\"\n\n  console.log(`${statusIcon} [PSI Status] ${request.status.toUpperCase()} for tab:`, tabId)\n\n  // Forward to detached windows\n  forwardToDetachedWindows(request)\n}\n\n/**\n * Handles complete PSI results for insights processing\n * @param {Object} request - The request object\n * @param {Object} sender - The sender object\n */\nfunction handleCompletePSIResults(request, sender) {\n  const tabId = sender.tab?.id\n  console.log(\"ðŸ“Š [PSI Complete] Processing complete PSI results for insights, tab:\", tabId)\n\n  // Store the complete PSI data for insights restoration\n  if (tabId && request.psiData) {\n    import(\"./tab-manager.js\").then(({ getPSIResults, storePSIResults }) => {\n      const existingPSI = getPSIResults(tabId) || { allFieldData: {}, allLabData: {} }\n\n      // Store complete data for insights\n      existingPSI.completeData = request.psiData\n      existingPSI.timestamp = Date.now()\n\n      storePSIResults(tabId, existingPSI)\n      console.log(\"ðŸ“Š [PSI Complete] Stored complete PSI data for insights restoration\")\n    })\n  }\n\n  // Forward complete PSI data to detached windows for insights processing\n  forwardToDetachedWindows(request)\n}\n\n/**\n * Handles requests for PSI results\n * @param {Object} request - The request object\n * @param {Function} sendResponse - The response callback\n */\nfunction handleGetPSIResults(request, sendResponse) {\n  import(\"./tab-manager.js\").then(({ getPSIResults }) => {\n    const results = getPSIResults(request.tabId)\n    console.log(\"ðŸ“Š [PSI] Retrieving PSI results for tab:\", request.tabId, results ? \"âœ… found\" : \"âŒ not found\")\n    sendResponse(results)\n  })\n}\n\n// Add this new handler function to get a tab's URL\nfunction handleGetTabUrl(request, sendResponse) {\n  if (!request.tabId) {\n    sendResponse({ success: false, error: \"No tab ID provided\" })\n    return\n  }\n\n  chrome.tabs.get(request.tabId, (tab) => {\n    if (chrome.runtime.lastError) {\n      sendResponse({ success: false, error: chrome.runtime.lastError.message })\n      return\n    }\n\n    if (tab) {\n      sendResponse({ success: true, url: tab.url, tab: tab })\n    } else {\n      sendResponse({ success: false, error: \"Tab not found\" })\n    }\n  })\n}\n\n/**\n * Handles tab URL changes\n * @param {Object} request - The request object\n * @param {Function} sendResponse - The response callback\n */\nfunction handleTabUrlChanged(request, sendResponse) {\n  console.log(\"ðŸ”„ [Tab] URL changed:\", request.tabId, request.url)\n  // Forward to any open detached windows\n  forwardToDetachedWindows({\n    action: \"tabUrlChanged\",\n    tabId: request.tabId,\n    url: request.url,\n  })\n\n  if (sendResponse) {\n    sendResponse({ success: true })\n  }\n}\n\n/**\n * Handles extension icon clicks based on current window state\n */\nexport async function handleExtensionIconClick() {\n  const currentState = await getWindowState()\n  console.log(\"ðŸ–±ï¸ [Extension] Icon clicked, current state:\", currentState)\n\n  if (currentState === WINDOW_STATES.DETACHED) {\n    console.log(\"ðŸªŸ [Window] In detached mode, attempting to focus window\")\n    const focused = await focusDetachedWindow()\n    if (!focused) {\n      console.log(\"âŒ [Window] Failed to focus detached window, resetting to attached state\")\n      // Window was closed, reset to attached state\n      await handleDetachedWindowClosed()\n      return false // Allow default popup behavior\n    }\n    console.log(\"âœ… [Window] Successfully focused detached window\")\n    return true // Prevent default popup behavior\n  }\n\n  console.log(\"ðŸ“Ž [Window] In attached mode, allowing default popup behavior\")\n  // For attached state, Chrome handles the default popup behavior\n  return false\n}\n\n/**\n * Handles badge update requests\n * @param {Object} request - The request object\n * @param {Object} sender - The sender object\n * @param {Object} chrome - The Chrome API object\n */\nfunction handleUpdateBadge(request, sender, chrome) {\n  const hostedBy = request.hostedBy ? request.hostedBy.toLowerCase() : \"\"\n  const cacheStatus = request.cacheStatus ? request.cacheStatus.toLowerCase() : \"\"\n\n  const isHostedByBigScoots = hostedBy === \"bigscoots\"\n  const isCacheHit = cacheStatus === \"hit\"\n\n  let badgeColor\n\n  if (isHostedByBigScoots && isCacheHit) {\n    // Both conditions met - blue badge\n    badgeColor = \"#1a73e8\"\n    console.log(\"ðŸ”µ [Badge] BigScoots + Cache Hit - Blue badge\")\n  } else if (isHostedByBigScoots) {\n    // Only BigScoots hosting - green badge\n    badgeColor = \"#4CAF50\"\n    console.log(\"ðŸŸ¢ [Badge] BigScoots hosting - Green badge\")\n  } else {\n    // Neither condition met - red badge\n    badgeColor = \"#F44336\"\n    console.log(\"ðŸ”´ [Badge] Other hosting - Red badge\")\n  }\n\n  chrome.action.setBadgeText({ text: \"â—\", tabId: sender.tab.id })\n  chrome.action.setBadgeBackgroundColor({ color: [0, 0, 0, 0], tabId: sender.tab.id })\n  chrome.action.setBadgeTextColor({ color: badgeColor, tabId: sender.tab.id })\n}\n\n/**\n * Handles analysis results storage\n * @param {Object} request - The request object\n * @param {Object} sender - The sender object\n */\nfunction handleAnalysisResults(request, sender) {\n  const tabId = sender.tab.id\n  const tabUrl = sender.tab.url\n  const now = Date.now()\n\n  // Throttle logging to reduce noise (max once per 2 seconds per tab)\n  const lastLogKey = `lastAnalysisLog_${tabId}`\n  const lastLogTime = throttleStorage.get(lastLogKey) || 0\n\n  if (now - lastLogTime > 2000) {\n    console.log(\"ðŸ’» [Local Analysis] Storing local performance results for tab:\", tabId, \"URL:\", tabUrl)\n    throttleStorage.set(lastLogKey, now)\n  }\n\n  // Clean up old throttling entries (older than 1 hour)\n  const oneHourAgo = now - 60 * 60 * 1000\n  for (const [key, timestamp] of throttleStorage.entries()) {\n    if (timestamp < oneHourAgo) {\n      throttleStorage.delete(key)\n    }\n  }\n\n  // Add URL to the request data for verification\n  const dataWithUrl = { ...request, url: tabUrl, timestamp: now }\n  storeTabResults(tabId, dataWithUrl)\n\n  // Forward to any open detached windows\n  forwardToDetachedWindows(request)\n}\n\n// Add this new function after handleAnalysisResults\nfunction handleINPUpdate(request, sender) {\n  const tabId = sender.tab.id\n  const now = Date.now()\n\n  // Throttle logging for INP updates (max once per 3 seconds per tab)\n  const lastLogKey = `lastINPLog_${tabId}`\n  const lastLogTime = throttleStorage.get(lastLogKey) || 0\n\n  if (now - lastLogTime > 3000) {\n    console.log(\"âš¡ [Local INP] Storing local INP measurement for tab:\", tabId, \"value:\", request.value + \"ms\")\n    throttleStorage.set(lastLogKey, now)\n  }\n\n  // Get existing results and update INP data\n  const existingResults = getTabResults(tabId) || {}\n  existingResults.inp = {\n    value: request.value,\n    entries: request.entries,\n    rating: request.rating,\n    status: request.status,\n  }\n\n  storeTabResults(tabId, existingResults)\n\n  // Forward to detached windows\n  forwardToDetachedWindows(request)\n}\n\n/**\n * Forwards messages to detached windows\n * @param {Object} message - Message to forward\n */\nasync function forwardToDetachedWindows(message) {\n  try {\n    const currentState = await getWindowState()\n    if (currentState === WINDOW_STATES.DETACHED) {\n      // Send message to all extension contexts (including detached windows)\n      chrome.runtime.sendMessage(message).catch(() => {\n        // Ignore errors if no receivers\n      })\n    }\n  } catch (error) {\n    console.debug(\"âš ï¸ [Window] Error forwarding to detached windows:\", error)\n  }\n}\n\n/**\n * Handles requests for analysis results\n * @param {Object} request - The request object\n * @param {Function} sendResponse - The response callback\n */\nfunction handleGetAnalysisResults(request, sendResponse) {\n  const results = getTabResults(request.tabId)\n  console.log(\n    \"ðŸ’» [Local Analysis] Retrieving local analysis results for tab:\",\n    request.tabId,\n    results ? \"âœ… found\" : \"âŒ not found\",\n  )\n  sendResponse(results)\n}\n\n/**\n * Handles parameter update requests\n * @param {Object} request - The request object\n * @param {Function} sendResponse - The response callback\n * @param {Object} chrome - The Chrome API object\n */\nfunction handleUpdateParameters(request, sendResponse, chrome) {\n  // If a specific tab ID is provided, use it; otherwise fall back to active tab\n  if (request.tabId) {\n    console.log(\"âš™ï¸ [Parameters] Updating parameters for specific tab:\", request.tabId)\n\n    chrome.tabs.get(request.tabId, (tab) => {\n      if (chrome.runtime.lastError || !tab) {\n        console.error(\"âŒ [Parameters] Tab not found:\", request.tabId, chrome.runtime.lastError)\n        sendResponse({ urlChanged: false, error: \"Tab not found\" })\n        return\n      }\n\n      let changed = false\n\n      if (request.add) {\n        changed = addTabParameter(tab.id, request.parameter)\n      } else {\n        changed = removeTabParameter(tab.id, request.parameter)\n      }\n\n      if (changed) {\n        applyParametersToTab(tab.id, chrome)\n      }\n\n      sendResponse({ urlChanged: changed })\n    })\n  } else {\n    // Fallback to active tab behavior\n    chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {\n      if (chrome.runtime.lastError || !tabs || tabs.length === 0) {\n        sendResponse({ urlChanged: false, error: \"No active tab found\" })\n        return\n      }\n\n      const activeTab = tabs[0]\n      let changed = false\n\n      if (request.add) {\n        changed = addTabParameter(activeTab.id, request.parameter)\n      } else {\n        changed = removeTabParameter(activeTab.id, request.parameter)\n      }\n\n      if (changed) {\n        applyParametersToTab(activeTab.id, chrome)\n      }\n\n      sendResponse({ urlChanged: changed })\n    })\n  }\n}\n\n/**\n * Handles requests for parameters\n * @param {Function} sendResponse - The response callback\n * @param {Object} chrome - The Chrome API object\n */\nfunction handleGetParameters(sendResponse, chrome) {\n  // If a specific tab ID is provided in the request, use it\n  const request = arguments[2] // Get the original request object\n\n  if (request && request.tabId) {\n    console.log(\"âš™ï¸ [Parameters] Getting parameters for specific tab:\", request.tabId)\n    const params = getTabParameters(request.tabId)\n    sendResponse(Array.from(params))\n    return\n  }\n\n  // Fallback to active tab behavior\n  chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {\n    if (chrome.runtime.lastError || !tabs || tabs.length === 0) {\n      sendResponse([])\n      return\n    }\n\n    const activeTab = tabs[0]\n    const params = getTabParameters(activeTab.id)\n    sendResponse(Array.from(params))\n  })\n}\n\n/**\n * Handles popup detachment requests\n * @param {Function} sendResponse - The response callback\n * @param {Object} chrome - The Chrome API object\n */\nasync function handleDetachPopup(sendResponse, chrome) {\n  try {\n    console.log(\"ðŸªŸ [Window] Creating detached popup window\")\n\n    // Get the current active tab ID to pass to the detached window\n    const tabs = await new Promise((resolve) => {\n      chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {\n        if (chrome.runtime.lastError) {\n          resolve([])\n        } else {\n          resolve(tabs || [])\n        }\n      })\n    })\n\n    const originalTabId = tabs.length > 0 ? tabs[0].id : null\n\n    console.log(\"ðŸªŸ [Window] Original tab ID for detached window:\", originalTabId)\n\n    const window = await createDetachedWindow(originalTabId)\n    sendResponse({ success: true, windowId: window.id, originalTabId })\n  } catch (error) {\n    console.error(\"âŒ [Window] Failed to create detached window:\", error)\n    sendResponse({ success: false, error: error.message })\n  }\n}\n\n/**\n * Handles popup attachment requests\n * @param {Function} sendResponse - The response callback\n */\nasync function handleAttachPopup(sendResponse) {\n  try {\n    console.log(\"ðŸ“Ž [Window] Attaching popup to extension icon\")\n    await attachPopup()\n    sendResponse({ success: true })\n  } catch (error) {\n    console.error(\"âŒ [Window] Failed to attach popup:\", error)\n    sendResponse({ success: false, error: error.message })\n  }\n}\n\n/**\n * Handles window state requests\n * @param {Function} sendResponse - The response callback\n */\nasync function handleGetWindowState(sendResponse) {\n  try {\n    const state = await getCurrentWindowState()\n    sendResponse({ state })\n  } catch (error) {\n    sendResponse({ state: \"attached\", error: error.message })\n  }\n}\n","/**\n * Background service worker for the BigScoots Performance Debugger extension\n */\n\nimport { cleanupTab } from \"./tab-manager.js\"\nimport {\n  cleanupTabParameters,\n  getParametersFromUrl,\n  updateUrlWithParameters,\n  getTabParameters,\n} from \"./parameter-manager.js\"\nimport { setupMessageHandlers, handleExtensionIconClick } from \"./message-handler.js\"\nimport { handleDetachedWindowClosed, saveWindowBounds, isDetachedWindow } from \"./window-manager.js\"\n\n// Declare chrome variable\n\n// Set up message handlers\nsetupMessageHandlers(chrome)\n\n// Handle extension icon clicks with proper async handling\nchrome.action.onClicked.addListener(async (tab) => {\n  console.log(\"Extension icon clicked for tab:\", tab.id)\n  const handled = await handleExtensionIconClick()\n  console.log(\"Icon click handled:\", handled)\n\n  // If handled is true, we focused a detached window and should prevent default popup\n  // If handled is false, Chrome will show the default popup\n})\n\n// Handle tab removal\nchrome.tabs.onRemoved.addListener((tabId) => {\n  cleanupTab(tabId)\n  cleanupTabParameters(tabId)\n})\n\n// Handle navigation events\nchrome.webNavigation.onBeforeNavigate.addListener((details) => {\n  if (details.frameId === 0) {\n    try {\n      // Only handle main frame navigation\n      const currentParams = getTabParameters(details.tabId)\n      if (currentParams && currentParams.size > 0) {\n        const urlParams = getParametersFromUrl(details.url)\n        const mergedParams = new Set([...urlParams, ...currentParams])\n\n        // Update URL only if new parameters were added\n        if (mergedParams.size > urlParams.size) {\n          const newUrl = updateUrlWithParameters(details.url, mergedParams)\n          if (newUrl !== details.url) {\n            chrome.tabs.update(details.tabId, { url: newUrl })\n          }\n        }\n      }\n    } catch (error) {\n      // Silent error handling\n    }\n  }\n})\n\n// Handle window removal (for detached popup cleanup)\nchrome.windows.onRemoved.addListener(async (windowId) => {\n  // Check if this is our detached window\n  const isOurWindow = await isDetachedWindow(windowId)\n  if (isOurWindow) {\n    console.log(\"Detached window closed, cleaning up\")\n    await handleDetachedWindowClosed()\n  }\n})\n\n// Handle window bounds changes (save position when user moves/resizes)\nchrome.windows.onBoundsChanged.addListener(async (window) => {\n  const isOurWindow = await isDetachedWindow(window.id)\n  if (isOurWindow) {\n    await saveWindowBounds(window.id)\n  }\n})\n\nconsole.log(\"BigScoots Performance Debugger background service worker initialized\")\n"],"names":["tabResults","Map","tabPSIResults","storeTabResults","tabId","results","set","getTabResults","get","storePSIResults","psiResults","getPSIResults","cleanupPSIResults","delete","cleanupTab","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","tabParameters","updateUrlWithParameters","url","parameters","urlObj","URL","searchParams","forEach","has","param","toString","error","getParametersFromUrl","Set","keys","getTabParameters","addTabParameter","parameter","params","add","removeTabParameter","applyParametersToTab","chrome","tabs","tab","runtime","lastError","currentUrlParams","newUrl","a","b","size","every","update","WINDOW_STATES","STORAGE_KEYS","DEFAULT_WINDOW_CONFIG","globalThis","self","async","getWindowState","storage","local","setWindowState","state","getDetachedWindowId","setDetachedWindowId","windowId","remove","setWindowBounds","bounds","width","height","left","top","setOriginalTabId","originalTabId","detachedWindow","createDetachedWindow","requestedBounds","getWindowBounds","validatedBounds","displays","Promise","resolve","system","display","getInfo","length","Math","min","screenBounds","find","isPrimary","safeWidth","safeHeight","minLeft","floor","maxLeft","minTop","maxTop","safeLeft","safeTop","max","validateWindowBounds","windowConfig","getURL","type","focused","window","windows","create","id","fallbackConfig","fallbackError","handleDetachedWindowClosed","saveWindowBounds","isDetachedWindow","throttleStorage","handlePSIMetricUpdate","request","sender","metric","_sender$tab","fieldData","then","existingPSI","allFieldData","allLabData","forwardToDetachedWindows","handlePSILabMetricUpdate","_sender$tab2","labData","toUpperCase","handleExtensionIconClick","setTimeout","e","focusDetachedWindow","message","sendMessage","catch","onMessage","addListener","sendResponse","action","hostedBy","toLowerCase","cacheStatus","isHostedByBigScoots","isCacheHit","badgeColor","setBadgeText","text","setBadgeBackgroundColor","color","setBadgeTextColor","handleUpdateBadge","tabUrl","now","Date","lastLogKey","lastLogTime","oneHourAgo","timestamp","entries","dataWithUrl","handleAnalysisResults","existingResults","inp","rating","status","handleINPUpdate","psiDataWithUrl","psiData","completeData","handleStorePSIResults","handleGetPSIResults","_sender$tab3","handlePSIStatusUpdate","handleGetAnalysisResults","urlChanged","changed","query","active","currentWindow","activeTab","handleUpdateParameters","arguments","Array","from","handleGetParameters","success","handleDetachPopup","attachPopup","handleAttachPopup","getCurrentWindowState","handleGetWindowState","handleTabUrlChanged","handleGetTabUrl","_sender$tab4","handleCompletePSIResults","onUpdated","changeInfo","oldDomain","hostname","setupMessageHandlers","onClicked","onRemoved","cleanupTabParameters","webNavigation","onBeforeNavigate","details","frameId","currentParams","urlParams","mergedParams","onBoundsChanged"],"sourceRoot":""}