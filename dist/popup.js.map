{"version":3,"file":"popup.js","mappings":";;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;;AAEA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;ACxOA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;;AAOA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9VA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAUA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC5NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AClDA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;;;;;;;ACnKA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;AC3EA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC5IA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;ACtRA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnPA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAKA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACrtDA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AAEA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AAEA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAKA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAIA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;ACt8CA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC9GA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;;;;;;;;;ACzMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAGA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;;;;;;ACtJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACNA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAiBA;AACA;AACA;AACA;;AAQA;AACA;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AAEA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA","sources":["webpack://new-bs-helper-extension/./src/popup/displays/psi-insights-display.js","webpack://new-bs-helper-extension/./src/popup/toggle-manager.js","webpack://new-bs-helper-extension/./src/utils/window-state.js","webpack://new-bs-helper-extension/./src/utils/messaging.js","webpack://new-bs-helper-extension/./src/popup/displays/font-display.js","webpack://new-bs-helper-extension/./src/popup/tab-manager.js","webpack://new-bs-helper-extension/./src/popup/window-state-manager.js","webpack://new-bs-helper-extension/./src/utils/toast-notifications.js","webpack://new-bs-helper-extension/./src/utils/tab-helpers.js","webpack://new-bs-helper-extension/./src/popup/displays/insights-display.js","webpack://new-bs-helper-extension/./src/popup/displays/insights-renderer.js","webpack://new-bs-helper-extension/./src/popup/displays/header-display.js","webpack://new-bs-helper-extension/./src/popup/displays/image-display.js","webpack://new-bs-helper-extension/./src/utils/formatters.js","webpack://new-bs-helper-extension/webpack/bootstrap","webpack://new-bs-helper-extension/webpack/runtime/define property getters","webpack://new-bs-helper-extension/webpack/runtime/hasOwnProperty shorthand","webpack://new-bs-helper-extension/webpack/runtime/make namespace object","webpack://new-bs-helper-extension/./src/popup/index.js"],"sourcesContent":["/**\n * Module for handling PSI Insights display in the popup\n */\n\n// Chrome API is available globally in extension context\nconst chrome = globalThis.chrome || window.chrome\n\nimport { insightsRenderer } from \"./insights-renderer.js\"\n\n/**\n * PSI Insights state management\n */\nconst psiInsightsState = {\n  insights: {},\n  lastUpdate: null,\n  isLoading: false,\n  hasError: false,\n  errorMessage: \"\",\n}\n\n/**\n * Updates PSI insights display with data from PSI API\n * @param {Object} psiData - Complete PSI API response data\n */\nexport function updatePSIInsightsDisplay(psiData) {\n  console.log(\"=== updatePSIInsightsDisplay called ===\")\n  console.log(\"PSI Data received:\", psiData)\n\n  try {\n    // Extract insights from PSI data structure\n    const insights = extractPSIInsights(psiData)\n\n    if (!insights || Object.keys(insights).length === 0) {\n      console.log(\"No PSI insights found in data\")\n      showEmptyInsightsState()\n      return\n    }\n\n    console.log(\"Extracted PSI insights:\", insights)\n\n    // Update state\n    psiInsightsState.insights = insights\n    psiInsightsState.lastUpdate = Date.now()\n    psiInsightsState.isLoading = false\n    psiInsightsState.hasError = false\n\n    // Update UI\n    displayPSIInsights(insights)\n  } catch (error) {\n    console.error(\"Error updating PSI insights display:\", error)\n    psiInsightsState.hasError = true\n    psiInsightsState.errorMessage = error.message\n    psiInsightsState.isLoading = false\n    showInsightsError(error.message)\n  }\n}\n\nfunction extractPSIInsights(psiData) {\n  console.log(\"=== extractPSIInsights called ===\")\n\n  try {\n    // Navigate through the PSI data structure\n    if (!psiData || !psiData.data) {\n      console.log(\"No PSI data or data property found\")\n      return null\n    }\n\n    const lighthouseResult = psiData.data.lighthouseResult\n    if (!lighthouseResult) {\n      console.log(\"No lighthouseResult found in PSI data\")\n      return null\n    }\n\n    const audits = lighthouseResult.audits\n    if (!audits) {\n      console.log(\"No audits found in lighthouse result\")\n      return null\n    }\n\n    const allInsights = {}\n\n    // Extract failed insights\n    if (audits.failed && audits.failed.insights) {\n      console.log(\"Found failed insights:\", audits.failed.insights)\n      Object.keys(audits.failed.insights).forEach((key) => {\n        allInsights[key] = {\n          ...audits.failed.insights[key],\n          category: \"failed\",\n          score: 0, // Failed insights have score of 0\n        }\n      })\n    }\n\n    // Extract warning insights\n    if (audits.warnings && audits.warnings.insights) {\n      console.log(\"Found warning insights:\", audits.warnings.insights)\n      Object.keys(audits.warnings.insights).forEach((key) => {\n        allInsights[key] = {\n          ...audits.warnings.insights[key],\n          category: \"warning\",\n          score: 0.7, // Warning insights have score between 0.5-0.89\n        }\n      })\n    }\n\n    console.log(\"Successfully extracted all insights:\", allInsights)\n    return Object.keys(allInsights).length > 0 ? allInsights : null\n  } catch (error) {\n    console.error(\"Error extracting PSI insights:\", error)\n    return null\n  }\n}\n\nfunction displayPSIInsights(insights) {\n  console.log(\"=== displayPSIInsights called ===\")\n  console.log(\"Displaying insights:\", insights)\n\n  const container = document.getElementById(\"psiInsightsContainer\")\n  if (!container) {\n    console.log(\"PSI insights container not found in DOM\")\n    return\n  }\n\n  // Convert insights object to array format expected by renderer\n  const insightsArray = Object.keys(insights).map((insightKey) => {\n    const insightData = insights[insightKey]\n    return {\n      id: insightKey,\n      title: insightData.title || insightKey,\n      description: insightData.description,\n      details: insightData.details,\n      ...insightData,\n    }\n  })\n\n  // Use the insights renderer to display the insights\n  insightsRenderer.renderInsights(container, insightsArray)\n\n  // Show the container\n  container.style.display = \"block\"\n}\n\n/**\n * Formats insight key into readable title\n * @param {string} insightKey - Raw insight key\n * @returns {string} Formatted title\n */\n\n/**\n * Shows empty state when no insights are available\n */\nfunction showEmptyInsightsState() {\n  console.log(\"=== showEmptyInsightsState called ===\")\n\n  const container = document.getElementById(\"psiInsightsContainer\")\n  if (!container) return\n\n  container.innerHTML = `\n    <div class=\"psi-insights-empty\">\n      <p>No performance insights available</p>\n      <small>Run PSI analysis to get detailed insights</small>\n    </div>\n  `\n  container.style.display = \"block\"\n}\n\n/**\n * Shows error state for insights\n * @param {string} errorMessage - Error message to display\n */\nfunction showInsightsError(errorMessage) {\n  console.log(\"=== showInsightsError called ===\")\n  console.log(\"Error message:\", errorMessage)\n\n  const container = document.getElementById(\"psiInsightsContainer\")\n  if (!container) return\n\n  container.innerHTML = `\n    <div class=\"psi-insights-error\">\n      <p>Error loading insights: ${errorMessage}</p>\n    </div>\n  `\n  container.style.display = \"block\"\n}\n\n/**\n * Clears PSI insights display\n */\nexport function clearPSIInsightsDisplay() {\n  console.log(\"=== clearPSIInsightsDisplay called ===\")\n\n  const container = document.getElementById(\"psiInsightsContainer\")\n  if (container) {\n    container.innerHTML = \"\"\n    container.style.display = \"none\"\n  }\n\n  // Reset state\n  psiInsightsState.insights = {}\n  psiInsightsState.lastUpdate = null\n  psiInsightsState.hasError = false\n  psiInsightsState.errorMessage = \"\"\n}\n\n/**\n * Sets loading state for PSI insights\n * @param {boolean} isLoading - Loading state\n */\nexport function setPSIInsightsLoading(isLoading) {\n  console.log(\"=== setPSIInsightsLoading called ===\", isLoading)\n\n  psiInsightsState.isLoading = isLoading\n\n  const container = document.getElementById(\"psiInsightsContainer\")\n  if (!container) return\n\n  if (isLoading) {\n    container.innerHTML = `\n      <div class=\"psi-insights-loading\">\n        <p>Loading performance insights...</p>\n      </div>\n    `\n    container.style.display = \"block\"\n  }\n}\n\n/**\n * Gets current PSI insights state\n * @returns {Object} Current insights state\n */\nexport function getPSIInsightsState() {\n  return { ...psiInsightsState }\n}\n","/**\n * Module for managing debug toggles and parameters with proper loading detection\n */\n\n// Global state management\nlet isProcessingToggle = false\nconst toggleQueue = []\nlet currentOperation = null\n\n/**\n * Sets up toggle functionality\n */\nexport function setupToggleManagement() {\n\n  // Load initial toggle states using the target tab ID\n  loadInitialToggleStates()\n\n  // Add event listeners to toggles with queuing\n  const toggleInputs = document.querySelectorAll(\".toggle-input\")\n  toggleInputs.forEach((input) => {\n    input.addEventListener(\"change\", (event) => {\n      // Prevent rapid clicking\n      if (isProcessingToggle) {\n        event.preventDefault()\n        input.checked = !input.checked // Revert the change\n        return\n      }\n\n      // Queue the toggle change\n      queueToggleChange(input.id, input.checked)\n    })\n  })\n}\n\n/**\n * Loads initial toggle states for the current target tab\n */\nasync function loadInitialToggleStates() {\n\n  try {\n    // Get the target tab ID (works in both attached and detached modes)\n    const targetTabId = await window.getTargetTabId()\n\n    if (!targetTabId) {\n      console.log(\"No target tab available for loading toggle states\")\n      // Set all toggles to unchecked if no tab available\n      document.getElementById(\"perfmattersoff\").checked = false\n      document.getElementById(\"perfmatterscssoff\").checked = false\n      document.getElementById(\"perfmattersjsoff\").checked = false\n      document.getElementById(\"nocache\").checked = false\n      updateToggleStates(true)\n      return\n    }\n\n    console.log(\"Loading toggle states for tab:\", targetTabId)\n\n    // Get parameters for the specific tab\n    chrome.runtime.sendMessage({ action: \"getParameters\", tabId: targetTabId }, (parameters) => {\n      if (chrome.runtime.lastError) {\n        console.error(\"Error getting parameters:\", chrome.runtime.lastError)\n        parameters = []\n      }\n\n      // Ensure parameters is an array\n      if (!Array.isArray(parameters)) {\n        parameters = []\n      }\n\n      console.log(\"Loaded parameters for tab\", targetTabId, \":\", parameters)\n\n      // Update toggle states based on parameters\n      document.getElementById(\"perfmattersoff\").checked = parameters.includes(\"perfmattersoff\")\n      document.getElementById(\"perfmatterscssoff\").checked = parameters.includes(\"perfmatterscssoff\")\n      document.getElementById(\"perfmattersjsoff\").checked = parameters.includes(\"perfmattersjsoff\")\n      document.getElementById(\"nocache\").checked = parameters.includes(\"nocache\")\n\n      updateToggleStates(true) // Pass true to skip parameter updates during initial load\n    })\n  } catch (error) {\n    console.error(\"Error loading initial toggle states:\", error)\n    // Fallback to unchecked state\n    document.getElementById(\"perfmattersoff\").checked = false\n    document.getElementById(\"perfmatterscssoff\").checked = false\n    document.getElementById(\"perfmattersjsoff\").checked = false\n    document.getElementById(\"nocache\").checked = false\n    updateToggleStates(true)\n  }\n}\n\n/**\n * Queues a toggle change to be processed sequentially\n * @param {string} toggleId - The ID of the toggle\n * @param {boolean} isChecked - Whether the toggle is checked\n */\nfunction queueToggleChange(toggleId, isChecked) {\n  const operation = {\n    toggleId,\n    isChecked,\n    timestamp: Date.now(),\n  }\n\n  toggleQueue.push(operation)\n  console.log(`Queued toggle change: ${toggleId} = ${isChecked}`)\n\n  // Process the queue if not already processing\n  if (!isProcessingToggle) {\n    processToggleQueue()\n  }\n}\n\n/**\n * Processes the toggle queue sequentially\n */\nasync function processToggleQueue() {\n  if (isProcessingToggle || toggleQueue.length === 0) {\n    return\n  }\n\n  isProcessingToggle = true\n\n  while (toggleQueue.length > 0) {\n    const operation = toggleQueue.shift()\n    currentOperation = operation\n\n    console.log(`Processing toggle: ${operation.toggleId} = ${operation.isChecked}`)\n\n    // Update UI to show loading state\n    updateToggleStates(true) // Skip parameter updates, just update UI\n\n    // Process the parameter change and wait for site to load\n    await processParameterChangeAndWaitForLoad(operation.toggleId, operation.isChecked)\n  }\n\n  currentOperation = null\n  isProcessingToggle = false\n\n  // Final UI update\n  updateToggleStates(true)\n  console.log(\"Toggle queue processing completed\")\n}\n\n/**\n * Processes a single parameter change and waits for site to fully load\n * @param {string} toggleId - The ID of the toggle\n * @param {boolean} isChecked - Whether the toggle is checked\n * @returns {Promise} Promise that resolves when the change is complete and site is loaded\n */\nasync function processParameterChangeAndWaitForLoad(toggleId, isChecked) {\n  return new Promise(async (resolve) => {\n\n    // Map toggle IDs to parameter names\n    const parameterMap = {\n      perfmattersoff: \"perfmattersoff\",\n      perfmatterscssoff: \"perfmatterscssoff\",\n      perfmattersjsoff: \"perfmattersjsoff\",\n      nocache: \"nocache\",\n    }\n\n    const parameter = parameterMap[toggleId]\n    if (!parameter) {\n      console.error(\"Unknown toggle ID:\", toggleId)\n      resolve()\n      return\n    }\n\n    try {\n      // Get the target tab ID (works in both attached and detached modes)\n      const targetTabId = await window.getTargetTabId()\n\n      if (!targetTabId) {\n        console.error(\"No target tab available for parameter update\")\n        resolve()\n        return\n      }\n\n      console.log(\"Processing parameter change for tab:\", targetTabId, \"parameter:\", parameter, \"value:\", isChecked)\n\n      // Send parameter update with specific tab ID\n      chrome.runtime.sendMessage(\n        {\n          action: \"updateParameters\",\n          parameter: parameter,\n          add: isChecked,\n          tabId: targetTabId, // Include the specific tab ID\n        },\n        (response) => {\n          if (chrome.runtime.lastError) {\n            console.error(\"Parameter update error:\", chrome.runtime.lastError)\n            resolve()\n            return\n          }\n\n          if (response && response.error) {\n            console.error(\"Parameter update failed:\", response.error)\n            resolve()\n            return\n          }\n\n          if (response && response.urlChanged) {\n            console.log(`URL updated for ${parameter} on tab ${targetTabId}, waiting for page to load...`)\n\n            // Wait for the tab to finish loading + additional time\n            waitForTabToLoadWithDelay(targetTabId)\n              .then(() => {\n                console.log(`Page loaded successfully after ${parameter} change on tab ${targetTabId}`)\n                resolve()\n              })\n              .catch((error) => {\n                console.error(\"Error waiting for page load:\", error)\n                // Resolve anyway after timeout\n                setTimeout(resolve, 5000)\n              })\n          } else {\n            console.log(`No URL change needed for ${parameter} on tab ${targetTabId}`)\n            // Still add delay even if no URL change needed to ensure consistency\n            setTimeout(resolve, 2000)\n          }\n        },\n      )\n    } catch (error) {\n      console.error(\"Error in processParameterChangeAndWaitForLoad:\", error)\n      resolve()\n    }\n  })\n}\n\n/**\n * Waits for a tab to finish loading completely with additional delay\n * @param {number} tabId - The ID of the tab to monitor\n * @returns {Promise} Promise that resolves when the tab is fully loaded\n */\nfunction waitForTabToLoadWithDelay(tabId) {\n  return new Promise((resolve, reject) => {\n    const timeout = 20000 // 20 second timeout\n    const startTime = Date.now()\n\n    function checkTabStatus() {\n      chrome.tabs.get(tabId, (tab) => {\n        if (chrome.runtime.lastError) {\n          reject(new Error(\"Tab not found\"))\n          return\n        }\n\n        // Check if tab is complete\n        if (tab.status === \"complete\") {\n          // Additional wait to ensure all resources are loaded + fake delay for control\n          setTimeout(() => {\n            console.log(`Tab ${tabId} finished loading with additional delay`)\n            resolve()\n          }, 3000) // 3 second additional delay as requested\n          return\n        }\n\n        // Check timeout\n        if (Date.now() - startTime > timeout) {\n          console.warn(`Timeout waiting for tab ${tabId} to load`)\n          resolve() // Resolve anyway to not block the queue\n          return\n        }\n\n        // Tab still loading, check again\n        setTimeout(checkTabStatus, 500)\n      })\n    }\n\n    // Start checking\n    checkTabStatus()\n  })\n}\n\n/**\n * Updates toggle states and dependencies\n * @param {boolean} skipParameterUpdate - Whether to skip updating parameters\n */\nexport function updateToggleStates(skipParameterUpdate = false) {\n  const perfmattersoff = document.getElementById(\"perfmattersoff\")\n  const perfmatterscssoff = document.getElementById(\"perfmatterscssoff\")\n  const perfmattersjsoff = document.getElementById(\"perfmattersjsoff\")\n  const nocache = document.getElementById(\"nocache\")\n\n  const isPerfmattersOff = perfmattersoff.checked\n\n  // Get all toggle containers\n  const allContainers = [\n    perfmattersoff.closest(\".toggle-container\"),\n    perfmatterscssoff.closest(\".toggle-container\"),\n    perfmattersjsoff.closest(\".toggle-container\"),\n    nocache.closest(\".toggle-container\"),\n  ]\n\n  // Apply loading state to all toggles if processing\n  if (isProcessingToggle) {\n    allContainers.forEach((container, index) => {\n      const toggleIds = [\"perfmattersoff\", \"perfmatterscssoff\", \"perfmattersjsoff\", \"nocache\"]\n      const toggleId = toggleIds[index]\n\n      if (container) {\n        const input = container.querySelector(\".toggle-input\")\n        if (input) input.disabled = true\n\n        // Only show \"processing\" on the currently active toggle\n        if (currentOperation && currentOperation.toggleId === toggleId) {\n          container.classList.add(\"processing-current\")\n          container.classList.remove(\"disabled-toggle\")\n        } else {\n          // All other toggles appear disabled\n          container.classList.add(\"disabled-toggle\")\n          container.classList.remove(\"processing-current\")\n        }\n      }\n    })\n\n    return\n  }\n\n  // Clear all loading states\n  allContainers.forEach((container) => {\n    if (container) {\n      container.classList.remove(\"processing-current\", \"disabled-toggle\")\n      const input = container.querySelector(\".toggle-input\")\n      if (input) input.disabled = false\n    }\n  })\n\n  // Handle dependent toggles\n  ;[perfmatterscssoff, perfmattersjsoff].forEach((toggle) => {\n    toggle.disabled = isPerfmattersOff\n    const container = toggle.closest(\".toggle-container\")\n    if (isPerfmattersOff) {\n      toggle.checked = false\n      container.classList.add(\"disabled-toggle\")\n    } else {\n      container.classList.remove(\"disabled-toggle\")\n    }\n  })\n\n  // Handle nocache toggle\n  nocache.disabled = isPerfmattersOff || perfmatterscssoff.checked || perfmattersjsoff.checked\n  const nocacheContainer = nocache.closest(\".toggle-container\")\n  if (nocache.disabled) {\n    if (nocache.checked) nocache.checked = false\n    nocacheContainer.classList.add(\"disabled-toggle\")\n  } else {\n    nocacheContainer.classList.remove(\"disabled-toggle\")\n  }\n\n  // Handle main perfmatters toggle\n  perfmattersoff.disabled = false\n  const perfmattersContainer = perfmattersoff.closest(\".toggle-container\")\n  perfmattersContainer.classList.remove(\"disabled-toggle\")\n}\n","/**\n * Utility module for managing popup window state - Enhanced with bounds validation\n */\n\n// Window state constants\nexport const WINDOW_STATES = {\n  ATTACHED: \"attached\",\n  DETACHED: \"detached\",\n}\n\n// Storage keys\nexport const STORAGE_KEYS = {\n  WINDOW_STATE: \"popup_window_state\",\n  DETACHED_WINDOW_ID: \"detached_window_id\",\n  WINDOW_BOUNDS: \"detached_window_bounds\",\n}\n\n// Default window dimensions - Conservative sizes for better compatibility\nexport const DEFAULT_WINDOW_CONFIG = {\n  width: 700, // Reduced from 800\n  height: 600, // Reduced from 700\n  type: \"popup\",\n  focused: true,\n}\n\n// Declare chrome variable\nconst chrome = globalThis.chrome || self.chrome\n\n/**\n * Gets the current window state from storage\n * @returns {Promise<string>} Current window state\n */\nexport async function getWindowState() {\n  try {\n    const result = await chrome.storage.local.get(STORAGE_KEYS.WINDOW_STATE)\n    return result[STORAGE_KEYS.WINDOW_STATE] || WINDOW_STATES.ATTACHED\n  } catch (error) {\n    console.debug(\"Error getting window state:\", error)\n    return WINDOW_STATES.ATTACHED\n  }\n}\n\n/**\n * Sets the window state in storage\n * @param {string} state - The window state to set\n */\nexport async function setWindowState(state) {\n  try {\n    await chrome.storage.local.set({ [STORAGE_KEYS.WINDOW_STATE]: state })\n  } catch (error) {\n    console.debug(\"Error setting window state:\", error)\n  }\n}\n\n/**\n * Gets the detached window ID from storage\n * @returns {Promise<number|null>} Window ID or null\n */\nexport async function getDetachedWindowId() {\n  try {\n    const result = await chrome.storage.local.get(STORAGE_KEYS.DETACHED_WINDOW_ID)\n    return result[STORAGE_KEYS.DETACHED_WINDOW_ID] || null\n  } catch (error) {\n    console.debug(\"Error getting detached window ID:\", error)\n    return null\n  }\n}\n\n/**\n * Sets the detached window ID in storage\n * @param {number|null} windowId - The window ID to store\n */\nexport async function setDetachedWindowId(windowId) {\n  try {\n    if (windowId === null) {\n      await chrome.storage.local.remove(STORAGE_KEYS.DETACHED_WINDOW_ID)\n    } else {\n      await chrome.storage.local.set({ [STORAGE_KEYS.DETACHED_WINDOW_ID]: windowId })\n    }\n  } catch (error) {\n    console.debug(\"Error setting detached window ID:\", error)\n  }\n}\n\n/**\n * Gets saved window bounds from storage with validation\n * @returns {Promise<Object|null>} Window bounds or null\n */\nexport async function getWindowBounds() {\n  try {\n    const result = await chrome.storage.local.get(STORAGE_KEYS.WINDOW_BOUNDS)\n    const bounds = result[STORAGE_KEYS.WINDOW_BOUNDS]\n\n    // Validate bounds before returning\n    if (bounds && typeof bounds === \"object\") {\n      // Check if bounds seem reasonable\n      if (\n        bounds.width >= 300 &&\n        bounds.height >= 200 &&\n        bounds.width <= 2000 &&\n        bounds.height <= 1500 &&\n        typeof bounds.left === \"number\" &&\n        typeof bounds.top === \"number\"\n      ) {\n        return bounds\n      } else {\n        console.log(\"Stored bounds seem invalid, ignoring:\", bounds)\n        // Clear invalid bounds\n        await setWindowBounds(null)\n        return null\n      }\n    }\n\n    return null\n  } catch (error) {\n    console.debug(\"Error getting window bounds:\", error)\n    return null\n  }\n}\n\n/**\n * Saves window bounds to storage with validation\n * @param {Object|null} bounds - Window bounds object\n */\nexport async function setWindowBounds(bounds) {\n  try {\n    if (bounds === null) {\n      await chrome.storage.local.remove(STORAGE_KEYS.WINDOW_BOUNDS)\n      console.log(\"Window bounds cleared\")\n    } else {\n      // Validate bounds before saving\n      if (\n        bounds &&\n        typeof bounds === \"object\" &&\n        bounds.width >= 300 &&\n        bounds.height >= 200 &&\n        bounds.width <= 2000 &&\n        bounds.height <= 1500 &&\n        typeof bounds.left === \"number\" &&\n        typeof bounds.top === \"number\"\n      ) {\n        await chrome.storage.local.set({ [STORAGE_KEYS.WINDOW_BOUNDS]: bounds })\n        console.log(\"Window bounds saved:\", bounds)\n      } else {\n        console.log(\"Invalid bounds not saved:\", bounds)\n      }\n    }\n  } catch (error) {\n    console.debug(\"Error setting window bounds:\", error)\n  }\n}\n\n/**\n * Gets the original tab ID from storage\n * @returns {Promise<number|null>} Original tab ID or null\n */\nexport async function getOriginalTabId() {\n  try {\n    const result = await chrome.storage.local.get(\"originalTabId\")\n    return result.originalTabId || null\n  } catch (error) {\n    console.debug(\"Error getting original tab ID:\", error)\n    return null\n  }\n}\n\n/**\n * Sets the original tab ID in storage\n * @param {number|null} tabId - The tab ID to store\n */\nexport async function setOriginalTabId(tabId) {\n  try {\n    if (tabId === null) {\n      await chrome.storage.local.remove(\"originalTabId\")\n    } else {\n      await chrome.storage.local.set({ originalTabId: tabId })\n    }\n  } catch (error) {\n    console.debug(\"Error setting original tab ID:\", error)\n  }\n}\n\n/**\n * Clears the original tab ID from storage\n */\nexport async function clearOriginalTabId() {\n  try {\n    await chrome.storage.local.remove(\"originalTabId\")\n  } catch (error) {\n    console.debug(\"Error clearing original tab ID:\", error)\n  }\n}\n\n/**\n * Checks if current window is the detached popup window\n * @returns {Promise<boolean>} True if this is the detached window\n */\nexport async function isCurrentWindowDetached() {\n  try {\n    const currentWindowId = await getCurrentWindowId()\n    const detachedWindowId = await getDetachedWindowId()\n    return currentWindowId === detachedWindowId\n  } catch (error) {\n    console.debug(\"Error checking if current window is detached:\", error)\n    return false\n  }\n}\n\n/**\n * Gets the current window ID\n * @returns {Promise<number|null>} Current window ID or null\n */\nexport async function getCurrentWindowId() {\n  try {\n    const currentWindow = await chrome.windows.getCurrent()\n    return currentWindow.id\n  } catch (error) {\n    console.debug(\"Error getting current window ID:\", error)\n    return null\n  }\n}\n","/**\n * Safely sends a message to the extension runtime\n * @param {Object} message - The message to send\n * @param {Function} callback - Optional callback function\n */\nexport function safeSendMessage(message, callback) {\n  try {\n    chrome.runtime.sendMessage(message, (response) => {\n      if (chrome.runtime.lastError) {\n        return\n      }\n      if (callback) callback(response)\n    })\n  } catch (error) {\n    // Extension context invalidated or other error\n    console.debug(\"Message sending failed:\", error)\n  }\n}\n\n/**\n * Sends a message to a specific tab\n * @param {number} tabId - The ID of the tab to send the message to\n * @param {Object} message - The message to send\n * @param {Function} callback - Optional callback function\n */\nexport function sendMessageToTab(tabId, message, callback) {\n  try {\n    chrome.tabs.sendMessage(tabId, message, (response) => {\n      if (chrome.runtime.lastError) {\n        return\n      }\n      if (callback) callback(response)\n    })\n  } catch (error) {\n    console.debug(\"Tab message sending failed:\", error)\n  }\n}\n\n/**\n * Sets up a listener for messages from content scripts or popup\n * @param {Object} handlers - Object mapping action names to handler functions\n */\nexport function setupMessageListener(handlers) {\n  chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n    const action = message.action\n    if (handlers[action]) {\n      handlers[action](message, sender, sendResponse)\n    }\n    return true // Keep the message channel open for async responses\n  })\n}\n","/**\n * Module for handling font display in the popup\n */\n\n/**\n * Updates the font display with analysis results\n * @param {Array} fonts - Array of font data\n */\nexport function updateFontDisplay(fonts) {\n  const fontInfo = document.getElementById(\"fontInfo\")\n  const fontCountEl = document.getElementById(\"fontCount\")\n  const fontList = document.getElementById(\"fontList\")\n\n  // Add margin if no button is present\n  if (fontInfo) fontInfo.style.marginTop = \"0px\"\n\n  const totalFonts = fonts.length\n  fontCountEl.textContent = `Found ${totalFonts} font${totalFonts !== 1 ? \"s\" : \"\"} loaded`\n  fontList.innerHTML = \"\"\n\n  if (totalFonts === 0) {\n    fontInfo.style.display = \"block\"\n    const p = document.createElement(\"p\")\n    p.textContent = \"No fonts detected loading on this page.\"\n    p.className = \"empty-state-message\"\n    fontList.appendChild(p)\n    return\n  }\n\n  fonts.forEach((font, index) => {\n    const li = createFontListItem(font, index)\n    fontList.appendChild(li)\n  })\n\n  fontInfo.style.display = \"block\"\n}\n\n/**\n * Creates a list item for a font\n * @param {Object} font - Font data object\n * @param {number} index - Font index\n * @returns {HTMLElement} The created list item\n */\nfunction createFontListItem(font, index) {\n  const li = document.createElement(\"li\")\n  li.className = \"card-style font-list-item\"\n\n  const numberBadge = document.createElement(\"div\")\n  numberBadge.className = \"font-list-item-badge\"\n  numberBadge.textContent = index + 1\n\n  const contentContainer = createFontContentContainer(font)\n\n  li.appendChild(numberBadge)\n  li.appendChild(contentContainer)\n\n  return li\n}\n\n/**\n * Creates the content container for a font\n * @param {Object} font - Font data object\n * @returns {HTMLElement} The content container\n */\nfunction createFontContentContainer(font) {\n  const contentContainer = document.createElement(\"div\")\n  contentContainer.className = \"font-list-item-content\"\n\n  const urlContainer = createFontUrlContainer(font)\n  contentContainer.appendChild(urlContainer)\n\n  const statusContainer = createFontStatusContainer(font)\n  contentContainer.appendChild(statusContainer)\n\n  return contentContainer\n}\n\n/**\n * Creates the URL container with copy button\n * @param {Object} font - Font data object\n * @returns {HTMLElement} The URL container\n */\nfunction createFontUrlContainer(font) {\n  const urlContainer = document.createElement(\"div\")\n  urlContainer.className = \"url-container\"\n\n  const urlSpan = document.createElement(\"span\")\n  urlSpan.className = \"font-url\"\n  urlSpan.textContent = font.url\n  urlSpan.title = font.url\n\n  const copyButton = createCopyButton(font.url)\n\n  urlContainer.appendChild(urlSpan)\n  urlContainer.appendChild(copyButton)\n\n  return urlContainer\n}\n\n/**\n * Creates a copy button for a URL\n * @param {string} url - The URL to copy\n * @returns {HTMLElement} The copy button\n */\nfunction createCopyButton(url) {\n  const copyButton = document.createElement(\"button\")\n  copyButton.className = \"copy-button icon-button-sm\"\n  copyButton.title = \"Copy URL\"\n\n  const originalCopyIcon =\n    '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"14\" height=\"14\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><rect x=\"9\" y=\"9\" width=\"13\" height=\"13\" rx=\"2\" ry=\"2\"></rect><path d=\"M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1\"></path></svg>'\n  const copiedIcon =\n    '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"14\" height=\"14\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><polyline points=\"20 6 9 17 4 12\"></polyline></svg>'\n\n  copyButton.innerHTML = originalCopyIcon\n\n  copyButton.onclick = (e) => {\n    e.stopPropagation()\n    navigator.clipboard.writeText(url).then(() => {\n      copyButton.innerHTML = copiedIcon\n      copyButton.classList.add(\"copied-feedback\")\n      setTimeout(() => {\n        copyButton.innerHTML = originalCopyIcon\n        copyButton.classList.remove(\"copied-feedback\")\n      }, 1200)\n    })\n  }\n\n  return copyButton\n}\n\n/**\n * Creates the status container with status indicators\n * @param {Object} font - Font data object\n * @returns {HTMLElement} The status container\n */\nfunction createFontStatusContainer(font) {\n  const statusContainer = document.createElement(\"div\")\n  statusContainer.className = \"status-container\"\n\n  // Early Hints indicator (highest priority)\n  if (font.earlyHints) {\n    const earlyHintsSticker = document.createElement(\"span\")\n    earlyHintsSticker.textContent = \"EARLY HINTS\"\n    earlyHintsSticker.className = \"status-sticker early-hints\"\n    statusContainer.appendChild(earlyHintsSticker)\n  }\n\n  // Font type sticker\n  if (font.type) {\n    const typeSticker = document.createElement(\"span\")\n    typeSticker.textContent = font.type\n    typeSticker.className = `status-sticker font-type font-type-${font.type.toLowerCase()}`\n    statusContainer.appendChild(typeSticker)\n  }\n\n  // Preload status sticker\n  const preloadedSticker = document.createElement(\"span\")\n  preloadedSticker.textContent = font.preloaded ? \"PRELOADED\" : \"NOT PRELOADED\"\n  preloadedSticker.className = font.preloaded ? \"status-sticker preloaded\" : \"status-sticker not-preloaded\"\n  statusContainer.appendChild(preloadedSticker)\n\n  return statusContainer\n}\n","/**\n * Module for managing popup tabs\n */\n\nconsole.log(\"=== TAB MANAGER LOADING ===\")\n\n/**\n * Sets up tab switching functionality\n * @param {Array} tabs - Array of tab configuration objects\n */\nexport function setupTabSwitching(tabs) {\n  console.log(\"setupTabSwitching called with tabs:\", tabs)\n\n  function switchTab(activeTabId) {\n    console.log(\"switchTab called with:\", activeTabId)\n    tabs.forEach((tabInfo) => {\n      const tabEl = document.getElementById(tabInfo.id)\n      const contentEl = document.getElementById(tabInfo.contentId)\n      console.log(`Processing tab ${tabInfo.id}:`, !!tabEl, !!contentEl)\n\n      if (tabEl && contentEl) {\n        if (tabInfo.id === activeTabId) {\n          tabEl.classList.add(\"active\")\n          contentEl.classList.add(\"active\")\n          console.log(`Activated tab: ${tabInfo.id}`)\n        } else {\n          tabEl.classList.remove(\"active\")\n          contentEl.classList.remove(\"active\")\n        }\n      } else {\n        console.warn(`Missing elements for tab ${tabInfo.id}:`, { tabEl: !!tabEl, contentEl: !!contentEl })\n      }\n    })\n    localStorage.setItem(\"activeExtensionTab\", activeTabId)\n    console.log(\"Active tab saved to localStorage:\", activeTabId)\n  }\n\n  // Add click listeners to tabs\n  tabs.forEach((tabInfo) => {\n    const tabEl = document.getElementById(tabInfo.id)\n    console.log(`Setting up click listener for tab ${tabInfo.id}:`, !!tabEl)\n\n    if (tabEl) {\n      // Remove any existing listeners\n      const newTabEl = tabEl.cloneNode(true)\n      tabEl.parentNode.replaceChild(newTabEl, tabEl)\n\n      // Add new listener\n      newTabEl.addEventListener(\"click\", (e) => {\n        console.log(`Tab ${tabInfo.id} clicked`)\n        e.preventDefault()\n        e.stopPropagation()\n        switchTab(tabInfo.id)\n      })\n      console.log(`Click listener added to tab ${tabInfo.id}`)\n    } else {\n      console.error(`Tab element not found: ${tabInfo.id}`)\n    }\n  })\n\n  // Restore last active tab or default to first tab\n  const lastActiveTab = localStorage.getItem(\"activeExtensionTab\")\n  console.log(\"Last active tab from localStorage:\", lastActiveTab)\n\n  if (lastActiveTab && tabs.find((t) => t.id === lastActiveTab)) {\n    console.log(\"Restoring last active tab:\", lastActiveTab)\n    switchTab(lastActiveTab)\n  } else if (tabs.length > 0) {\n    console.log(\"No last active tab, defaulting to first tab:\", tabs[0].id)\n    switchTab(tabs[0].id)\n  }\n\n  console.log(\"Tab switching setup complete\")\n}\n\nconsole.log(\"=== TAB MANAGER LOADED ===\")\n","/**\n * Module for managing popup window state in the UI\n */\n\nimport { safeSendMessage } from \"../utils/messaging.js\"\nimport { isCurrentWindowDetached, clearOriginalTabId } from \"../utils/window-state.js\"\n\n/**\n * Detaches the current popup into a separate window\n * @returns {Promise<boolean>} Success status\n */\nexport async function detachPopup() {\n  return new Promise((resolve) => {\n    safeSendMessage({ action: \"detachPopup\" }, (response) => {\n      if (response && response.success) {\n        // Close current popup window\n        window.close()\n        resolve(true)\n      } else {\n        console.error(\"Failed to detach popup:\", response?.error)\n        resolve(false)\n      }\n    })\n  })\n}\n\n/**\n * Attaches the popup back to the extension icon\n * @returns {Promise<boolean>} Success status\n */\nexport async function attachPopup() {\n  return new Promise((resolve) => {\n    safeSendMessage({ action: \"attachPopup\" }, async (response) => {\n      if (response && response.success) {\n        // Clear the stored original tab ID\n        await clearOriginalTabId()\n\n        // Close current detached window\n        window.close()\n        resolve(true)\n      } else {\n        console.error(\"Failed to detach popup:\", response?.error)\n        resolve(false)\n      }\n    })\n  })\n}\n\n/**\n * Gets the current window state from background\n * @returns {Promise<string>} Current window state\n */\nexport async function getWindowStateFromBackground() {\n  return new Promise((resolve) => {\n    safeSendMessage({ action: \"getWindowState\" }, (response) => {\n      resolve(response?.state || \"attached\")\n    })\n  })\n}\n\n/**\n * Checks if the current popup is running in a detached window\n * Uses multiple detection methods for accuracy\n * @returns {Promise<boolean>} True if detached\n */\nexport async function isDetachedWindow() {\n  try {\n    // Method 1: Check against stored detached window ID\n    const isDetachedById = await isCurrentWindowDetached()\n\n    // Method 2: Check window characteristics\n    const hasLargerDimensions = window.outerWidth > 650 || window.outerHeight > 650\n    const isExtensionUrl = window.location.protocol === \"chrome-extension:\"\n\n    // Method 3: Check background state\n    const backgroundState = await getWindowStateFromBackground()\n    const isDetachedByState = backgroundState === \"detached\"\n\n    // Method 4: Check window type (detached windows have different properties)\n    const isPopupWindow = window.opener === null && window.parent === window\n\n    // Combine all methods for accurate detection\n    const isDetached = (isDetachedById || isDetachedByState) && hasLargerDimensions && isExtensionUrl && isPopupWindow\n\n    console.log(\"Detached window detection:\", {\n      isDetachedById,\n      hasLargerDimensions,\n      isExtensionUrl,\n      isDetachedByState,\n      isPopupWindow,\n      finalResult: isDetached,\n    })\n\n    return isDetached\n  } catch (error) {\n    console.debug(\"Error detecting detached window:\", error)\n    return false\n  }\n}\n\n/**\n * Applies detached mode styling to the UI\n * @param {boolean} isDetached - Whether we're in detached mode\n */\nexport function applyDetachedModeStyles(isDetached) {\n  if (isDetached) {\n    document.body.classList.add(\"detached-mode\")\n    document.querySelector(\".container\")?.classList.add(\"detached-mode\")\n  } else {\n    document.body.classList.remove(\"detached-mode\")\n    document.querySelector(\".container\")?.classList.remove(\"detached-mode\")\n  }\n}\n\n/**\n * Updates the window control button icon and tooltip based on current state\n * @param {boolean} isDetached - Whether we're in detached mode\n * @param {HTMLElement} button - The button element to update\n */\nexport function updateWindowControlButton(isDetached, button) {\n  if (!button) return\n\n  const icon = button.querySelector(\".window-toggle-icon\")\n  if (!icon) return\n\n  if (isDetached) {\n    // Show \"Attach\" icon when in detached mode - dock/attach back to extension\n    icon.innerHTML = `<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n      <path d=\"M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3\"/>\n    </svg>`\n    button.title = \"Attach popup back to extension icon\"\n  } else {\n    // Show \"Open in new window\" icon when in attached mode - like the one in your screenshot\n    icon.innerHTML = `<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n      <path d=\"M15 3h6v6\"/>\n      <path d=\"M10 14 21 3\"/>\n      <path d=\"M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6\"/>\n    </svg>`\n    button.title = \"Open popup in separate window\"\n  }\n}\n","/**\n * Professional toast notification system\n */\n\n// Toast container and configuration\nlet toastContainer = null\nlet toastCounter = 0\n\nconst TOAST_TYPES = {\n  SUCCESS: \"success\",\n  ERROR: \"error\",\n  WARNING: \"warning\",\n  INFO: \"info\",\n}\n\nconst TOAST_CONFIG = {\n  duration: {\n    success: 2500,\n    error: 4000,\n    warning: 3000,\n    info: 2500,\n  },\n  maxToasts: 3,\n  position: \"top-center\", // Changed to top-center for better positioning\n}\n\n/**\n * Initialize the toast container\n */\nfunction initializeToastContainer() {\n  if (toastContainer) return\n\n  toastContainer = document.createElement(\"div\")\n  toastContainer.id = \"toast-container\"\n  toastContainer.className = `toast-container toast-${TOAST_CONFIG.position}`\n\n  // Add container styles\n  toastContainer.style.cssText = `\n    position: fixed;\n    z-index: 10000;\n    pointer-events: none;\n    display: flex;\n    flex-direction: column;\n    gap: 6px;\n    max-width: 320px;\n    padding: 8px;\n  `\n\n  // Position the container\n  switch (TOAST_CONFIG.position) {\n    case \"top-center\":\n      toastContainer.style.top = \"8px\"\n      toastContainer.style.left = \"50%\"\n      toastContainer.style.transform = \"translateX(-50%)\"\n      break\n    case \"top-right\":\n      toastContainer.style.top = \"8px\"\n      toastContainer.style.right = \"8px\"\n      break\n    case \"top-left\":\n      toastContainer.style.top = \"8px\"\n      toastContainer.style.left = \"8px\"\n      break\n    case \"bottom-right\":\n      toastContainer.style.bottom = \"8px\"\n      toastContainer.style.right = \"8px\"\n      toastContainer.style.flexDirection = \"column-reverse\"\n      break\n    case \"bottom-left\":\n      toastContainer.style.bottom = \"8px\"\n      toastContainer.style.left = \"8px\"\n      toastContainer.style.flexDirection = \"column-reverse\"\n      break\n  }\n\n  document.body.appendChild(toastContainer)\n}\n\n/**\n * Create a toast notification\n * @param {string} message - The message to display\n * @param {string} type - The type of toast (success, error, warning, info)\n * @param {Object} options - Additional options\n * @returns {HTMLElement} The toast element\n */\nfunction createToast(message, type = TOAST_TYPES.INFO, options = {}) {\n  initializeToastContainer()\n\n  const toastId = `toast-${++toastCounter}`\n  const duration = options.duration || TOAST_CONFIG.duration[type]\n  const dismissible = options.dismissible !== false\n  const compact = options.compact !== false // Default to compact\n\n  // Create toast element\n  const toast = document.createElement(\"div\")\n  toast.id = toastId\n  toast.className = `toast toast-${type} ${compact ? \"toast-compact\" : \"\"}`\n  toast.style.pointerEvents = \"auto\"\n\n  // Get icon for toast type\n  const icon = getToastIcon(type)\n\n  // Create compact toast content\n  if (compact) {\n    toast.innerHTML = `\n      <div class=\"toast-content-compact\">\n        <div class=\"toast-icon-compact\">${icon}</div>\n        <div class=\"toast-message-compact\">${message}</div>\n        ${dismissible ? '<button class=\"toast-dismiss-compact\" aria-label=\"Dismiss\">×</button>' : \"\"}\n      </div>\n      <div class=\"toast-progress-compact\"></div>\n    `\n  } else {\n    // Keep original layout for non-compact toasts\n    toast.innerHTML = `\n      <div class=\"toast-content\">\n        <div class=\"toast-icon\">${icon}</div>\n        <div class=\"toast-message\">${message}</div>\n        ${dismissible ? '<button class=\"toast-dismiss\" aria-label=\"Dismiss\">&times;</button>' : \"\"}\n      </div>\n      <div class=\"toast-progress\"></div>\n    `\n  }\n\n  // Add event listeners\n  if (dismissible) {\n    const dismissBtn = toast.querySelector(compact ? \".toast-dismiss-compact\" : \".toast-dismiss\")\n    dismissBtn.addEventListener(\"click\", () => dismissToast(toast))\n  }\n\n  // Add to container\n  toastContainer.appendChild(toast)\n\n  // Trigger entrance animation\n  requestAnimationFrame(() => {\n    toast.classList.add(\"toast-show\")\n  })\n\n  // Auto dismiss\n  if (duration > 0) {\n    const progressBar = toast.querySelector(compact ? \".toast-progress-compact\" : \".toast-progress\")\n\n    // Animate progress bar\n    progressBar.style.animation = `toast-progress ${duration}ms linear`\n\n    setTimeout(() => {\n      dismissToast(toast)\n    }, duration)\n  }\n\n  // Limit number of toasts\n  limitToasts()\n\n  return toast\n}\n\n/**\n * Dismiss a toast notification\n * @param {HTMLElement} toast - The toast element to dismiss\n */\nfunction dismissToast(toast) {\n  if (!toast || !toast.parentNode) return\n\n  toast.classList.add(\"toast-hide\")\n\n  setTimeout(() => {\n    if (toast.parentNode) {\n      toast.parentNode.removeChild(toast)\n    }\n  }, 300) // Match animation duration\n}\n\n/**\n * Limit the number of visible toasts\n */\nfunction limitToasts() {\n  const toasts = toastContainer.querySelectorAll(\".toast\")\n  if (toasts.length > TOAST_CONFIG.maxToasts) {\n    const oldestToast = toasts[0]\n    dismissToast(oldestToast)\n  }\n}\n\n/**\n * Get icon for toast type\n * @param {string} type - Toast type\n * @returns {string} SVG icon\n */\nfunction getToastIcon(type) {\n  const icons = {\n    success: `<svg width=\"20\" height=\"20\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n      <path d=\"M22 11.08V12a10 10 0 1 1-5.93-9.14\"></path>\n      <polyline points=\"22,4 12,14.01 9,11.01\"></polyline>\n    </svg>`,\n    error: `<svg width=\"20\" height=\"20\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n      <circle cx=\"12\" cy=\"12\" r=\"10\"></circle>\n      <line x1=\"15\" y1=\"9\" x2=\"9\" y2=\"15\"></line>\n      <line x1=\"9\" y1=\"9\" x2=\"15\" y2=\"15\"></line>\n    </svg>`,\n    warning: `<svg width=\"20\" height=\"20\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n      <path d=\"m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z\"></path>\n      <line x1=\"12\" y1=\"9\" x2=\"12\" y2=\"13\"></line>\n      <line x1=\"12\" y1=\"17\" x2=\"12.01\" y2=\"17\"></line>\n    </svg>`,\n    info: `<svg width=\"20\" height=\"20\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n      <circle cx=\"12\" cy=\"12\" r=\"10\"></circle>\n      <line x1=\"12\" y1=\"16\" x2=\"12\" y2=\"12\"></line>\n      <line x1=\"12\" y1=\"8\" x2=\"12.01\" y2=\"8\"></line>\n    </svg>`,\n  }\n  return icons[type] || icons.info\n}\n\n/**\n * Show success toast\n * @param {string} message - Success message\n * @param {Object} options - Additional options\n */\nexport function showSuccessToast(message, options = {}) {\n  return createToast(message, TOAST_TYPES.SUCCESS, options)\n}\n\n/**\n * Show error toast\n * @param {string} message - Error message\n * @param {Object} options - Additional options\n */\nexport function showErrorToast(message, options = {}) {\n  return createToast(message, TOAST_TYPES.ERROR, options)\n}\n\n/**\n * Show warning toast\n * @param {string} message - Warning message\n * @param {Object} options - Additional options\n */\nexport function showWarningToast(message, options = {}) {\n  return createToast(message, TOAST_TYPES.WARNING, options)\n}\n\n/**\n * Show info toast\n * @param {string} message - Info message\n * @param {Object} options - Additional options\n */\nexport function showInfoToast(message, options = {}) {\n  return createToast(message, TOAST_TYPES.INFO, options)\n}\n\n/**\n * Show toast with action button\n * @param {string} message - Toast message\n * @param {string} type - Toast type\n * @param {Object} action - Action configuration\n * @param {Object} options - Additional options\n */\nexport function showActionToast(message, type, action, options = {}) {\n  return createToast(message, type, { ...options, action })\n}\n\n/**\n * Clear all toasts\n */\nexport function clearAllToasts() {\n  if (!toastContainer) return\n\n  const toasts = toastContainer.querySelectorAll(\".toast\")\n  toasts.forEach((toast) => dismissToast(toast))\n}\n\n/**\n * Configure toast system\n * @param {Object} config - Configuration options\n */\nexport function configureToasts(config) {\n  Object.assign(TOAST_CONFIG, config)\n}\n\n// Export types for convenience\nexport { TOAST_TYPES }\n","/**\n * Utility functions for tab management and verification\n */\n\nimport { getOriginalTabId, setOriginalTabId } from \"./window-state.js\"\n\n// Declare chrome variable\n\n/**\n * Gets the original tab ID from URL parameters or storage\n * @returns {Promise<number|null>} Original tab ID or null\n */\nexport async function getOriginalTabIdFromUrl() {\n  try {\n    const urlParams = new URLSearchParams(window.location.search)\n    const tabIdFromUrl = urlParams.get(\"originalTabId\")\n\n    if (tabIdFromUrl) {\n      const tabId = Number.parseInt(tabIdFromUrl, 10)\n      console.log(\"Retrieved original tab ID from URL:\", tabId)\n      return tabId\n    }\n\n    // Fallback to storage\n    const tabIdFromStorage = await getOriginalTabId()\n\n    if (tabIdFromStorage) {\n      console.log(\"Retrieved original tab ID from storage:\", tabIdFromStorage)\n      return tabIdFromStorage\n    }\n\n    console.log(\"No original tab ID found in URL or storage\")\n    return null\n  } catch (error) {\n    console.debug(\"Error getting original tab ID:\", error)\n    return null\n  }\n}\n\n/**\n * Stores the original tab ID for future use\n * @param {number} tabId - The tab ID to store\n */\nexport async function storeOriginalTabId(tabId) {\n  try {\n    await setOriginalTabId(tabId)\n    console.log(\"Stored original tab ID:\", tabId)\n  } catch (error) {\n    console.debug(\"Error storing original tab ID:\", error)\n  }\n}\n\n/**\n * Verifies that a tab exists and is accessible\n * @param {number} tabId - The tab ID to verify\n * @returns {Promise<boolean>} True if tab exists and is accessible\n */\nexport async function verifyTabExists(tabId) {\n  if (!tabId) return false\n\n  try {\n    return new Promise((resolve) => {\n      chrome.tabs.get(Number.parseInt(tabId, 10), (tab) => {\n        if (chrome.runtime.lastError) {\n          console.debug(`Tab verification failed for ID ${tabId}:`, chrome.runtime.lastError.message)\n          resolve(false)\n        } else {\n          console.log(`Tab ${tabId} verified:`, tab.url)\n          resolve(true)\n        }\n      })\n    })\n  } catch (error) {\n    console.debug(\"Exception during tab verification:\", error)\n    return false\n  }\n}\n\n/**\n * Detects if we're in detached mode by checking URL parameters\n * @returns {boolean} True if in detached mode\n */\nfunction isDetachedMode() {\n  const urlParams = new URLSearchParams(window.location.search)\n  const hasOriginalTabId = urlParams.has(\"originalTabId\")\n  console.log(\"Detached mode detection:\", hasOriginalTabId, \"URL:\", window.location.href)\n  return hasOriginalTabId\n}\n\n/**\n * Gets the target tab ID for messaging, automatically detecting attached vs detached mode\n * @returns {Promise<number|null>} Tab ID or null if not available\n */\nexport async function getTargetTabId() {\n  try {\n    const detachedMode = isDetachedMode()\n    console.log(\"getTargetTabId called, detached mode:\", detachedMode)\n\n    if (detachedMode) {\n      // In detached mode, use the original bound tab ID\n      const originalTabId = await getOriginalTabIdFromUrl()\n      console.log(\"Detached mode - original tab ID:\", originalTabId)\n\n      if (originalTabId) {\n        // Verify the tab still exists\n        const tabExists = await verifyTabExists(originalTabId)\n        if (tabExists) {\n          console.log(\"Using bound original tab ID for detached mode:\", originalTabId)\n          return originalTabId\n        } else {\n          console.log(\"Bound original tab no longer exists:\", originalTabId)\n          return null\n        }\n      }\n\n      console.log(\"No bound tab ID available in detached mode\")\n      return null\n    }\n\n    // In attached mode, get the current active tab\n    console.log(\"Attached mode - getting current active tab\")\n    return new Promise((resolve) => {\n      chrome.tabs.query({ active: true, currentWindow: true }, (activeTabs) => {\n        if (chrome.runtime.lastError || !activeTabs || activeTabs.length === 0) {\n          console.log(\"No active tabs found in attached mode\")\n          resolve(null)\n          return\n        }\n\n        const tabId = activeTabs[0].id\n        console.log(\"Using current active tab ID for attached mode:\", tabId)\n        resolve(tabId)\n      })\n    })\n  } catch (error) {\n    console.debug(\"Error getting target tab ID:\", error)\n    return null\n  }\n}\n\n/**\n * Sends a message to a content script with error handling\n * @param {number} tabId - The tab ID to send the message to\n * @param {Object} message - The message to send\n * @returns {Promise<Object|null>} Response from content script or null if failed\n */\nexport async function sendMessageToContentScript(tabId, message) {\n  if (!tabId) {\n    console.error(\"Cannot send message: No tab ID provided\")\n    return null\n  }\n\n  try {\n    return new Promise((resolve) => {\n      chrome.tabs.sendMessage(Number.parseInt(tabId, 10), message, (response) => {\n        if (chrome.runtime.lastError) {\n          console.error(`Error sending message to tab ${tabId}:`, chrome.runtime.lastError.message)\n          resolve(null)\n        } else {\n          console.log(`Message sent successfully to tab ${tabId}:`, message.action)\n          resolve(response)\n        }\n      })\n    })\n  } catch (error) {\n    console.error(\"Exception when sending message to content script:\", error)\n    return null\n  }\n}\n\n/**\n * Shows minimal visual feedback on an element\n * @param {HTMLElement} element - The element to show feedback on\n * @param {string} type - The feedback type ('success', 'error')\n * @param {number} duration - Duration in milliseconds\n */\nexport function showElementFeedback(element, type = \"success\", duration = 1000) {\n  if (!element) return\n\n  const originalTransform = element.style.transform\n  const originalTransition = element.style.transition\n\n  // Add subtle visual feedback\n  element.style.transition = \"transform 0.1s ease\"\n  element.style.transform = \"scale(0.95)\"\n\n  setTimeout(() => {\n    element.style.transform = \"scale(1)\"\n\n    setTimeout(() => {\n      element.style.transform = originalTransform\n      element.style.transition = originalTransition\n    }, 100)\n  }, 50)\n}\n\n// Legacy function names for compatibility (now just do minimal feedback)\n\n/**\n * Refreshes the original tab ID in storage to maintain connection\n * @param {number} tabId - The tab ID to store\n * @returns {Promise<boolean>} Success status\n */\nexport async function refreshOriginalTabId(tabId) {\n  try {\n    if (!tabId) return false\n\n    // Verify the tab still exists before storing\n    const tabExists = await verifyTabExists(tabId)\n    if (!tabExists) return false\n\n    // Store the tab ID\n    await setOriginalTabId(tabId)\n    console.log(\"Refreshed original tab ID:\", tabId)\n    return true\n  } catch (error) {\n    console.debug(\"Error refreshing original tab ID:\", error)\n    return false\n  }\n}\n\n/**\n * Gets the current active tab ID\n * @returns {Promise<number|null>} Current active tab ID or null\n */\nexport async function getCurrentActiveTabId() {\n  try {\n    return new Promise((resolve) => {\n      chrome.tabs.query({ active: true, lastFocusedWindow: true }, (tabs) => {\n        if (chrome.runtime.lastError || !tabs || tabs.length === 0) {\n          console.debug(\"No active tab found\")\n          resolve(null)\n          return\n        }\n        const tabId = tabs[0].id\n        console.log(\"Current active tab ID:\", tabId, \"URL:\", tabs[0].url)\n        resolve(tabId)\n      })\n    })\n  } catch (error) {\n    console.debug(\"Error getting current active tab ID:\", error)\n    return null\n  }\n}\n","// src/popup/displays/insights-display.js\n\n/**\n * Module for handling insights display in the popup - Complete Enhanced Version with Combination Indicators\n */\n\n// Import the simplified helpers\nimport { sendMessageToContentScript, showElementFeedback, getTargetTabId } from \"../../utils/tab-helpers.js\"\nimport { showErrorToast } from \"../../utils/toast-notifications.js\"\nimport { updatePSIInsightsDisplay, clearPSIInsightsDisplay, setPSIInsightsLoading } from \"./psi-insights-display.js\"\n\n// Chrome API is available globally in extension context\nconst chrome = globalThis.chrome || window.chrome\n\n/**\n * Enhanced state management for insights display\n */\nconst insightsState = {\n  isLoading: false,\n  hasError: false,\n  errorMessage: \"\",\n  lastUpdate: null,\n  dataTypes: {\n    local: { available: false, lastUpdate: null },\n    field: { available: false, lastUpdate: null },\n    lab: { available: false, lastUpdate: null },\n  },\n  metrics: {\n    cls: { local: null, field: null, lab: null },\n    lcp: { local: null, field: null, lab: null },\n    inp: { local: null, field: null, lab: null },\n    ttfb: { local: null, field: null, lab: null }, // Note: lab TTFB will always be null\n  },\n}\n\n/**\n * Core Web Vitals thresholds based on official Google guidelines\n */\nconst THRESHOLDS = {\n  cls: { good: 0.1, needsImprovement: 0.25 },\n  lcp: { good: 2500, needsImprovement: 4000 },\n  inp: { good: 200, needsImprovement: 500 },\n  ttfb: { good: 800, needsImprovement: 1800 },\n}\n\n/**\n * Format metric value for display\n */\nfunction formatMetricValue(metric, value) {\n  if (metric === \"cls\") {\n    return typeof value === \"number\" ? value.toFixed(3) : value\n  } else {\n    return typeof value === \"number\" ? `${Math.round(value)}ms` : value\n  }\n}\n\n/**\n * Updates the insights state and triggers UI updates\n */\nfunction updateInsightsState(updates) {\n  const previousState = JSON.parse(JSON.stringify(insightsState))\n\n  // Deep merge updates\n  if (updates.dataTypes) {\n    Object.assign(insightsState.dataTypes, updates.dataTypes)\n  }\n  if (updates.metrics) {\n    Object.keys(updates.metrics).forEach((metric) => {\n      if (insightsState.metrics[metric]) {\n        Object.assign(insightsState.metrics[metric], updates.metrics[metric])\n      }\n    })\n  }\n\n  // Update other properties\n  Object.keys(updates).forEach((key) => {\n    if (key !== \"dataTypes\" && key !== \"metrics\") {\n      insightsState[key] = updates[key]\n    }\n  })\n\n  insightsState.lastUpdate = Date.now()\n\n  // Trigger UI updates if state changed\n  if (JSON.stringify(previousState) !== JSON.stringify(insightsState)) {\n    updateUIFromState()\n  }\n}\n\n/**\n * Updates UI based on current state\n */\nfunction updateUIFromState() {\n  // Update loading states\n  updateLoadingStates()\n\n  // Update error states\n  updateErrorStates()\n\n  // Update legend visibility\n  updateLegendFromState()\n\n  // Update metric displays\n  updateMetricDisplaysFromState()\n}\n\n/**\n * Updates loading states across the UI\n */\nfunction updateLoadingStates() {\n  const loadingElements = document.querySelectorAll(\".metric-loading\")\n  loadingElements.forEach((el) => {\n    el.style.display = insightsState.isLoading ? \"flex\" : \"none\"\n  })\n\n  // Update PSI button loading state\n  if (insightsState.isLoading) {\n    setPSIButtonState(\"analyzing\")\n  }\n}\n\n/**\n * Updates error states across the UI\n */\nfunction updateErrorStates() {\n  const errorContainer = document.getElementById(\"insightsErrorContainer\")\n  if (errorContainer) {\n    if (insightsState.hasError) {\n      errorContainer.style.display = \"block\"\n      errorContainer.textContent = insightsState.errorMessage || \"An error occurred\"\n      errorContainer.className = \"insights-error-message\"\n    } else {\n      errorContainer.style.display = \"none\"\n    }\n  }\n}\n\n/**\n * Updates legend visibility based on state including combination indicators\n */\nfunction updateLegendFromState() {\n  const localLegend = document.querySelector('.legend-item[data-type=\"local\"]')\n  const fieldLegend = document.querySelector('.legend-item[data-type=\"field\"]')\n  const labLegend = document.querySelector('.legend-item[data-type=\"lab\"]')\n\n  // Check for combination matches across all metrics\n  const combinationStates = getCombinationStates()\n\n  // Show/hide individual legends based on availability and combinations\n  if (localLegend) {\n    const showLocal = insightsState.dataTypes.local.available && !hasAnyCombinations(combinationStates)\n    localLegend.style.display = showLocal ? \"flex\" : \"none\"\n  }\n  if (fieldLegend) {\n    const showField = insightsState.dataTypes.field.available && !hasAnyCombinations(combinationStates)\n    fieldLegend.style.display = showField ? \"flex\" : \"none\"\n  }\n  if (labLegend) {\n    const showLab = insightsState.dataTypes.lab.available && !hasAnyCombinations(combinationStates)\n    labLegend.style.display = showLab ? \"flex\" : \"none\"\n  }\n\n  // Update combination legends\n  updateCombinationLegends(combinationStates)\n\n  const legendContainer = document.querySelector(\".cwv-legend\")\n  if (legendContainer) {\n    const hasAnyData = Object.values(insightsState.dataTypes).some((dt) => dt.available)\n    legendContainer.style.display = hasAnyData ? \"flex\" : \"none\"\n  }\n}\n\n/**\n * Get combination states across all metrics\n */\nfunction getCombinationStates() {\n  const states = {\n    localField: false,\n    localLab: false,\n    fieldLab: false,\n    allSources: false,\n  }\n\n  Object.keys(insightsState.metrics).forEach((metric) => {\n    const metricData = insightsState.metrics[metric]\n    const localValue = metricData.local\n    const fieldValue = metricData.field\n    const labValue = metricData.lab\n\n    if (localValue !== null && fieldValue !== null && labValue !== null) {\n      const tolerance = calculateTolerance(metric, localValue)\n      const localFieldMatch = Math.abs(localValue - fieldValue) <= tolerance\n      const localLabMatch = Math.abs(localValue - labValue) <= tolerance\n      const fieldLabMatch = Math.abs(fieldValue - labValue) <= tolerance\n\n      if (localFieldMatch && localLabMatch && fieldLabMatch) {\n        states.allSources = true\n      } else if (localFieldMatch) {\n        states.localField = true\n      } else if (localLabMatch) {\n        states.localLab = true\n      } else if (fieldLabMatch) {\n        states.fieldLab = true\n      }\n    } else {\n      // Check two-way combinations\n      if (localValue !== null && fieldValue !== null) {\n        const tolerance = calculateTolerance(metric, localValue)\n        if (Math.abs(localValue - fieldValue) <= tolerance) {\n          states.localField = true\n        }\n      }\n      if (localValue !== null && labValue !== null) {\n        const tolerance = calculateTolerance(metric, localValue)\n        if (Math.abs(localValue - labValue) <= tolerance) {\n          states.localLab = true\n        }\n      }\n      if (fieldValue !== null && labValue !== null) {\n        const tolerance = calculateTolerance(metric, fieldValue)\n        if (Math.abs(fieldValue - labValue) <= tolerance) {\n          states.fieldLab = true\n        }\n      }\n    }\n  })\n\n  return states\n}\n\n/**\n * Check if any combinations are active\n */\nfunction hasAnyCombinations(states) {\n  return states.localField || states.localLab || states.fieldLab || states.allSources\n}\n\n/**\n * Update combination legend items\n */\nfunction updateCombinationLegends(states) {\n  const legendContainer = document.querySelector(\".cwv-legend\")\n  if (!legendContainer) return\n\n  // Remove existing combination legends\n  const existingCombinations = legendContainer.querySelectorAll(\n    '.legend-item[data-type*=\"-\"], .legend-item[data-type=\"all-sources\"]',\n  )\n  existingCombinations.forEach((item) => item.remove())\n\n  // Add active combination legends\n  if (states.allSources) {\n    addCombinationLegendItem(legendContainer, \"all-sources\", \"All Match\")\n  } else {\n    if (states.localField) {\n      addCombinationLegendItem(legendContainer, \"local-field\", \"Local + Field\")\n    }\n    if (states.localLab) {\n      addCombinationLegendItem(legendContainer, \"local-lab\", \"Local + Lab\")\n    }\n    if (states.fieldLab) {\n      addCombinationLegendItem(legendContainer, \"field-lab\", \"Field + Lab\")\n    }\n  }\n}\n\n/**\n * Add combination legend item\n */\nfunction addCombinationLegendItem(container, type, label) {\n  const legendItem = document.createElement(\"div\")\n  legendItem.className = \"legend-item\"\n  legendItem.setAttribute(\"data-type\", type)\n\n  const dot = document.createElement(\"div\")\n  dot.className = \"legend-dot\"\n\n  const labelElement = document.createElement(\"span\")\n  labelElement.className = \"legend-label\"\n  labelElement.textContent = label\n\n  legendItem.appendChild(dot)\n  legendItem.appendChild(labelElement)\n  container.appendChild(legendItem)\n}\n\n/**\n * Updates metric displays based on current state\n */\nfunction updateMetricDisplaysFromState() {\n  Object.keys(insightsState.metrics).forEach((metric) => {\n    const metricData = insightsState.metrics[metric]\n\n    // Update local values\n    if (metricData.local !== null) {\n      updateMetricValue(metric, \"local\", metricData.local)\n    }\n\n    // Update field values\n    if (metricData.field !== null) {\n      updateMetricValue(metric, \"field\", metricData.field)\n    }\n\n    // Update lab values (only for CLS and LCP, TTFB not available in lab)\n    if (metricData.lab !== null && (metric === \"cls\" || metric === \"lcp\")) {\n      updateMetricValue(metric, \"lab\", metricData.lab)\n    }\n  })\n}\n\n/**\n * Generic function to update metric values in UI\n */\nfunction updateMetricValue(metric, type, value) {\n  const valueContainer = document.getElementById(`${metric}${type.charAt(0).toUpperCase() + type.slice(1)}Value`)\n  const textElement = document.getElementById(`${metric}${type.charAt(0).toUpperCase() + type.slice(1)}Text`)\n\n  if (!valueContainer || !textElement) {\n    console.log(`Missing elements for ${metric} ${type}:`, {\n      container: !!valueContainer,\n      text: !!textElement,\n    })\n    return\n  }\n\n  // Show the container\n  valueContainer.style.display = \"flex\"\n\n  // Format value based on metric type\n  const displayValue = formatMetricValue(metric, value)\n  textElement.textContent = displayValue\n\n  // Add threshold-based styling\n  if (typeof value === \"number\") {\n    updateMetricThresholds(metric, value, type === \"field\", type === \"lab\")\n    addThresholdStyling(textElement, metric, value)\n  }\n\n  console.log(`Updated ${metric} ${type} value:`, displayValue)\n}\n\n/**\n * Adds threshold-based styling to metric elements\n */\nfunction addThresholdStyling(element, metric, value) {\n  const threshold = THRESHOLDS[metric]\n  if (!threshold) return\n\n  // Remove existing threshold classes\n  element.classList.remove(\"metric-good\", \"metric-needs-improvement\", \"metric-poor\")\n\n  // Add appropriate class\n  if (value <= threshold.good) {\n    element.classList.add(\"metric-good\")\n  } else if (value <= threshold.needsImprovement) {\n    element.classList.add(\"metric-needs-improvement\")\n  } else {\n    element.classList.add(\"metric-poor\")\n  }\n}\n\n/**\n * Verifies content script is ready with simple ping\n */\nasync function verifyContentScriptReady(targetTabId) {\n  console.log(`Verifying content script readiness for tab ${targetTabId}`)\n\n  return new Promise((resolve) => {\n    chrome.tabs.sendMessage(targetTabId, { action: \"ping\" }, (response) => {\n      if (chrome.runtime.lastError) {\n        console.log(\"Content script ping failed:\", chrome.runtime.lastError.message)\n        resolve(false)\n      } else if (response && response.ready) {\n        console.log(\"Content script ping successful\")\n        resolve(true)\n      } else {\n        console.log(\"Content script ping returned unexpected response:\", response)\n        resolve(false)\n      }\n    })\n  })\n}\n\n/**\n * Sets up the PSI analyze button functionality with proper detached mode support\n */\nfunction setupPSIAnalyzeButton() {\n  console.log(\"Setting up PSI button\")\n  const psiBtn = document.getElementById(\"analyzePSIBtn\")\n\n  if (!psiBtn) {\n    console.log(\"PSI button not found\")\n    return\n  }\n\n  // Remove any existing listeners to prevent duplicates\n  const newBtn = psiBtn.cloneNode(true)\n  psiBtn.parentNode.replaceChild(newBtn, psiBtn)\n\n  // Set initial state\n  newBtn.setAttribute(\"data-tooltip\", \"Analyze with PageSpeed Insights\")\n\n  // Single event listener with proper error handling\n  newBtn.addEventListener(\"click\", handlePSIButtonClick)\n}\n\n/**\n * Handles PSI button click with proper detached mode support\n */\nasync function handlePSIButtonClick() {\n  try {\n    console.log(\"PSI button clicked - starting analysis\")\n\n    // Update state to loading\n    updateInsightsState({\n      isLoading: true,\n      hasError: false,\n      errorMessage: \"\",\n    })\n\n    // Get target tab ID using the improved helper that auto-detects mode\n    console.log(\"Getting target tab ID...\")\n    const targetTabId = await getTargetTabId()\n    console.log(\"Target tab ID for PSI analysis:\", targetTabId)\n\n    if (!targetTabId) {\n      throw new Error(\"No target tab available. Please ensure you're on a valid webpage.\")\n    }\n\n    // Verify content script is ready before sending PSI request\n    console.log(\"Verifying content script readiness...\")\n    const isReady = await verifyContentScriptReady(targetTabId)\n\n    if (!isReady) {\n      throw new Error(\"Content script not ready. Please refresh the page and try again.\")\n    }\n\n    console.log(\"Content script ready, sending PSI analysis request...\")\n\n    // Send PSI analysis request with proper timeout handling\n    const response = await new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        reject(new Error(\"Request timeout - analysis taking too long\"))\n      }, 45000)\n\n      chrome.tabs.sendMessage(targetTabId, { action: \"analyzePSI\" }, (response) => {\n        clearTimeout(timeout)\n\n        if (chrome.runtime.lastError) {\n          console.error(\"Chrome runtime error:\", chrome.runtime.lastError.message)\n          reject(new Error(`Connection failed: ${chrome.runtime.lastError.message}`))\n        } else if (response && response.success) {\n          console.log(\"PSI analysis request successful:\", response)\n          resolve(response)\n        } else {\n          const errorMessage = response?.userMessage || response?.message || \"Analysis failed. Please try again.\"\n          console.error(\"PSI analysis failed:\", errorMessage)\n          reject(new Error(errorMessage))\n        }\n      })\n    })\n\n    // Success state\n    updateInsightsState({\n      isLoading: false,\n      hasError: false,\n    })\n\n    console.log(\"✅ PSI analysis completed successfully\")\n  } catch (error) {\n    console.error(\"PSI button error:\", error)\n\n    // Error state\n    updateInsightsState({\n      isLoading: false,\n      hasError: true,\n      errorMessage: error.message,\n    })\n\n    showErrorToast(error.message, { duration: 5000 })\n  }\n}\n\n/**\n * Enhanced PSI button state management\n */\nfunction setPSIButtonState(state) {\n  const psiBtn = document.getElementById(\"analyzePSIBtn\")\n  if (!psiBtn) return\n\n  console.log(`Setting PSI button state to: ${state}`)\n\n  // Remove all state classes\n  psiBtn.classList.remove(\"analyzing\", \"success\", \"error\")\n\n  const btnText = psiBtn.querySelector(\".psi-btn-text\")\n  const btnIcon = psiBtn.querySelector(\".psi-btn-icon\")\n\n  if (state === \"analyzing\") {\n    psiBtn.classList.add(\"analyzing\")\n    psiBtn.disabled = true\n    if (btnText) btnText.textContent = \"Analyzing...\"\n    psiBtn.setAttribute(\"data-tooltip\", \"Analyzing with PageSpeed Insights...\")\n  } else if (state === \"success\") {\n    psiBtn.classList.add(\"success\")\n    psiBtn.disabled = false\n    if (btnText) btnText.textContent = \"Success!\"\n    psiBtn.setAttribute(\"data-tooltip\", \"Analysis completed successfully\")\n\n    // Reset to default after 2 seconds\n    setTimeout(() => {\n      setPSIButtonState(\"default\")\n    }, 2000)\n  } else if (state === \"error\") {\n    psiBtn.classList.add(\"error\")\n    psiBtn.disabled = false\n    if (btnText) btnText.textContent = \"Error\"\n    psiBtn.setAttribute(\"data-tooltip\", \"Analysis failed - click to retry\")\n\n    // Reset to default after 3 seconds\n    setTimeout(() => {\n      setPSIButtonState(\"default\")\n    }, 3000)\n  } else {\n    // Default state\n    psiBtn.disabled = false\n    if (btnText) btnText.textContent = \"Analyze PSI\"\n    psiBtn.setAttribute(\"data-tooltip\", \"Analyze with PageSpeed Insights\")\n  }\n}\n\n/**\n * Resets data availability (useful when navigating to new page)\n */\nfunction resetDataAvailability() {\n  updateInsightsState({\n    dataTypes: {\n      local: { available: false, lastUpdate: null },\n      field: { available: false, lastUpdate: null },\n      lab: { available: false, lastUpdate: null },\n    },\n    metrics: {\n      cls: { local: null, field: null, lab: null },\n      lcp: { local: null, field: null, lab: null },\n      inp: { local: null, field: null, lab: null },\n      ttfb: { local: null, field: null, lab: null }, // Lab TTFB always null\n    },\n    hasError: false,\n    errorMessage: \"\",\n    isLoading: false,\n  })\n\n  // Clear PSI insights as well\n  clearPSIInsightsDisplay()\n}\n\n/**\n * Updates the insights display with analysis results\n * @param {Object} data - Analysis data object\n */\nexport function updateInsightsDisplay(data) {\n  console.log(\"Updating insights display with data:\", data)\n\n  // Update CLS display\n  if (data.cls !== undefined) {\n    console.log(\"Updating CLS display\")\n    updateCLSDisplay(data.cls)\n  }\n\n  // Update LCP display\n  if (data.lcp !== undefined) {\n    console.log(\"Updating LCP display\")\n    updateLCPDisplay(data.lcp)\n  }\n\n  // Update INP display\n  if (data.inp !== undefined) {\n    console.log(\"Updating INP display\")\n    updateINPDisplay(data.inp)\n  }\n\n  // Update TTFB display\n  if (data.additionalMetrics !== undefined) {\n    console.log(\"Updating TTFB display\")\n    updateTTFBDisplay(data.additionalMetrics)\n  }\n}\n\n// Update the CLS display function - Fixed to properly update state\nexport function updateCLSDisplay(clsData) {\n  console.log(\"updateCLSDisplay called with:\", clsData)\n\n  const value = clsData.value || 0\n\n  // Update state with actual value\n  updateInsightsState({\n    dataTypes: {\n      local: { available: true, lastUpdate: Date.now() },\n    },\n    metrics: {\n      cls: { local: value },\n    },\n  })\n\n  const clsElementPreview = document.getElementById(\"clsElementPreview\")\n\n  // Show/hide element preview\n  if (clsElementPreview) {\n    if (value > 0) {\n      clsElementPreview.style.display = \"block\"\n      updateCLSElementPreview(clsData.element || {}, value)\n    } else {\n      clsElementPreview.style.display = \"none\"\n    }\n  }\n\n  updateMetricThresholds(\"cls\", value, false, false) // isField = false, isLab = false (local)\n}\n\n// Update the LCP display function - Fixed to properly update state\nexport function updateLCPDisplay(lcpData) {\n  console.log(\"updateLCPDisplay called with:\", lcpData)\n\n  const value = lcpData.value || 0\n\n  // Update state with actual value\n  updateInsightsState({\n    dataTypes: {\n      local: { available: true, lastUpdate: Date.now() },\n    },\n    metrics: {\n      lcp: { local: value },\n    },\n  })\n\n  const lcpElementPreview = document.getElementById(\"lcpElementPreview\")\n\n  // Show element preview\n  if (lcpElementPreview) {\n    lcpElementPreview.style.display = \"block\"\n    updateLCPElementPreview(lcpData.element || {})\n  }\n\n  updateMetricThresholds(\"lcp\", value, false, false) // isField = false, isLab = false (local)\n}\n\n// Update the INP display function - Enhanced to show element details\nexport function updateINPDisplay(inpData) {\n  console.log(\"updateINPDisplay called with:\", inpData)\n\n  const value = inpData.value || 0\n\n  // Update state with actual value\n  updateInsightsState({\n    dataTypes: {\n      local: { available: true, lastUpdate: Date.now() },\n    },\n    metrics: {\n      inp: { local: value },\n    },\n  })\n\n  const inpStatus = document.getElementById(\"inpStatus\")\n  const inpElementPreview = document.getElementById(\"inpElementPreview\")\n\n  if (inpStatus) {\n    const status = inpData.status || \"waiting\"\n\n    if (value !== null && value !== undefined && value > 0) {\n      if (inpData.entries && inpData.entries.length > 0) {\n        const latestEntry = inpData.entries[0]\n        inpStatus.innerHTML = `\n          <div class=\"inp-message\">\n            Latest interaction: ${latestEntry.name} on ${latestEntry.target} (${latestEntry.duration}ms)\n          </div>\n        `\n\n        // Show element preview if we have element data\n        if (latestEntry.element && inpElementPreview) {\n          inpElementPreview.style.display = \"block\"\n          updateINPElementPreview(latestEntry.element, latestEntry)\n        }\n      } else {\n        inpStatus.innerHTML = `<div class=\"inp-message\">INP measured: ${value}ms</div>`\n        if (inpElementPreview) {\n          inpElementPreview.style.display = \"none\"\n        }\n      }\n    } else {\n      if (status === \"waiting\") {\n        inpStatus.innerHTML = `<div class=\"inp-message\">Click anywhere on the page to measure interaction responsiveness</div>`\n      } else {\n        inpStatus.innerHTML = `<div class=\"inp-message\">No interactions detected yet</div>`\n      }\n      if (inpElementPreview) {\n        inpElementPreview.style.display = \"none\"\n      }\n    }\n  }\n\n  updateMetricThresholds(\"inp\", value, false, false) // isField = false, isLab = false (local)\n}\n\n// Update the TTFB display function - Fixed to properly update state\nexport function updateTTFBDisplay(metrics) {\n  console.log(\"updateTTFBDisplay called with:\", metrics)\n\n  const value = metrics.ttfb || 0\n\n  // Update state with actual value\n  updateInsightsState({\n    dataTypes: {\n      local: { available: true, lastUpdate: Date.now() },\n    },\n    metrics: {\n      ttfb: { local: value },\n    },\n  })\n\n  updateMetricThresholds(\"ttfb\", value, false, false) // isField = false, isLab = false (local)\n}\n\n/**\n * Updates the CLS display with PSI field data\n */\nexport function updatePSICLSDisplay(psiData) {\n  console.log(\"updatePSICLSDisplay called with:\", psiData)\n\n  if (!psiData || psiData.value === null || psiData.value === undefined || isNaN(psiData.value)) {\n    console.log(\"No valid PSI CLS data available\")\n    return\n  }\n\n  // Update state with actual value\n  updateInsightsState({\n    dataTypes: {\n      field: { available: true, lastUpdate: Date.now() },\n    },\n    metrics: {\n      cls: { field: psiData.value },\n    },\n  })\n\n  console.log(\"PSI CLS field data processed:\", psiData.value)\n  updateMetricThresholds(\"cls\", psiData.value, true, false) // isField = true, isLab = false\n}\n\n/**\n * Updates the LCP display with PSI field data\n */\nexport function updatePSILCPDisplay(psiData) {\n  console.log(\"updatePSILCPDisplay called with:\", psiData)\n\n  if (!psiData || psiData.value === null || psiData.value === undefined || isNaN(psiData.value)) {\n    console.log(\"No valid PSI LCP data available\")\n    return\n  }\n\n  // Update state with actual value\n  updateInsightsState({\n    dataTypes: {\n      field: { available: true, lastUpdate: Date.now() },\n    },\n    metrics: {\n      lcp: { field: psiData.value },\n    },\n  })\n\n  console.log(\"PSI LCP field data processed:\", psiData.value)\n  updateMetricThresholds(\"lcp\", psiData.value, true, false) // isField = true, isLab = false\n}\n\n/**\n * Updates the INP display with PSI field data\n */\nexport function updatePSIINPDisplay(psiData) {\n  console.log(\"updatePSIINPDisplay called with:\", psiData)\n\n  if (!psiData || psiData.value === null || psiData.value === undefined || isNaN(psiData.value)) {\n    console.log(\"No valid PSI INP data available\")\n    return\n  }\n\n  // Update state with actual value\n  updateInsightsState({\n    dataTypes: {\n      field: { available: true, lastUpdate: Date.now() },\n    },\n    metrics: {\n      inp: { field: psiData.value },\n    },\n  })\n\n  console.log(\"PSI INP field data processed:\", psiData.value)\n  updateMetricThresholds(\"inp\", psiData.value, true, false) // isField = true, isLab = false\n}\n\n/**\n * Updates the TTFB display with PSI field data\n */\nexport function updatePSITTFBDisplay(psiData) {\n  console.log(\"updatePSITTFBDisplay called with:\", psiData)\n\n  if (!psiData || psiData.value === null || psiData.value === undefined || isNaN(psiData.value)) {\n    console.log(\"No valid PSI TTFB data available\")\n    return\n  }\n\n  // Update state with actual value\n  updateInsightsState({\n    dataTypes: {\n      field: { available: true, lastUpdate: Date.now() },\n    },\n    metrics: {\n      ttfb: { field: psiData.value },\n    },\n  })\n\n  console.log(\"PSI TTFB field data processed:\", psiData.value)\n  updateMetricThresholds(\"ttfb\", psiData.value, true, false) // isField = true, isLab = false\n}\n\n/**\n * Updates the CLS display with PSI lab data\n */\nexport function updatePSILabCLSDisplay(labData) {\n  console.log(\"updatePSILabCLSDisplay called with:\", labData)\n\n  if (!labData || labData.value === null || labData.value === undefined || isNaN(labData.value)) {\n    console.log(\"No valid PSI Lab CLS data available\")\n    return\n  }\n\n  // Update state with actual value\n  updateInsightsState({\n    dataTypes: {\n      lab: { available: true, lastUpdate: Date.now() },\n    },\n    metrics: {\n      cls: { lab: labData.value },\n    },\n  })\n\n  console.log(\"PSI Lab CLS data processed:\", labData.value)\n  updateMetricThresholds(\"cls\", labData.value, false, true) // isField = false, isLab = true\n}\n\n/**\n * Updates the LCP display with PSI lab data\n */\nexport function updatePSILabLCPDisplay(labData) {\n  console.log(\"updatePSILabLCPDisplay called with:\", labData)\n\n  if (!labData || labData.value === null || labData.value === undefined || isNaN(labData.value)) {\n    console.log(\"No valid PSI Lab LCP data available\")\n    return\n  }\n\n  // Update state with actual value\n  updateInsightsState({\n    dataTypes: {\n      lab: { available: true, lastUpdate: Date.now() },\n    },\n    metrics: {\n      lcp: { lab: labData.value },\n    },\n  })\n\n  console.log(\"PSI Lab LCP data processed:\", labData.value)\n  updateMetricThresholds(\"lcp\", labData.value, false, true) // isField = false, isLab = true\n}\n\n// Note: TTFB lab data function removed as TTFB is not available in Lighthouse lab environment\n\n/**\n * Updates PSI status display\n * @param {Object} statusData - PSI status data\n */\nexport function updatePSIStatus(statusData) {\n  console.log(\"updatePSIStatus called with:\", statusData)\n\n  if (statusData.status === \"loading\") {\n    console.log(\"PSI: Loading...\")\n    setPSIButtonState(\"analyzing\")\n    setPSIInsightsLoading(true)\n  } else if (statusData.status === \"success\") {\n    console.log(\"PSI: Success -\", statusData.message, statusData.cached ? \"(cached)\" : \"(fresh)\")\n    setPSIButtonState(\"success\")\n    setPSIInsightsLoading(false)\n  } else if (statusData.status === \"error\") {\n    console.error(\"PSI: Error -\", statusData.message)\n    setPSIButtonState(\"error\")\n    setPSIInsightsLoading(false)\n\n    // Show error toast for API errors\n    const errorMessage = statusData.userMessage || statusData.message || \"Analysis failed\"\n    showErrorToast(errorMessage, { duration: 5000 })\n  }\n}\n\n/**\n * Handles complete PSI results including insights\n * @param {Object} psiData - Complete PSI data\n */\nexport function handleCompletePSIResults(psiData) {\n  console.log(\"handleCompletePSIResults called with:\", psiData)\n\n  try {\n    // Update insights display with complete PSI data\n    updatePSIInsightsDisplay(psiData)\n  } catch (error) {\n    console.error(\"Error handling complete PSI results:\", error)\n  }\n}\n\n/**\n * Updates the CLS element preview with enhanced information\n * @param {Object} element - CLS element data\n * @param {number} clsValue - Current CLS value\n */\nfunction updateCLSElementPreview(element, clsValue) {\n  console.log(\"updateCLSElementPreview called with:\", element, clsValue)\n\n  const elementTag = document.getElementById(\"clsElementTag\")\n  const elementImage = document.getElementById(\"clsElementImage\")\n  const clsShiftValue = document.getElementById(\"clsShiftValue\")\n  const elementDimensions = document.getElementById(\"clsElementDimensions\")\n  const elementPosition = document.getElementById(\"clsElementPosition\")\n  const elementClassesContainer = document.getElementById(\"clsElementClassesContainer\")\n  const elementClasses = document.getElementById(\"clsElementClasses\")\n  const elementSelectorContainer = document.getElementById(\"clsElementSelector\")\n  const elementSelector = document.getElementById(\"clsElementSelector\")\n\n  // Handle case where element data might be empty or incomplete\n  if (!element || Object.keys(element).length === 0 || !element.tagName) {\n    console.log(\"No CLS element data available, element:\", element)\n    if (elementTag) elementTag.textContent = \"Layout Shift Detected\"\n    if (clsShiftValue) clsShiftValue.textContent = clsValue ? clsValue.toFixed(3) : \"0.000\"\n\n    // Show what we can from the CLS data itself\n    if (elementDimensions) {\n      elementDimensions.textContent = \"Element details not available\"\n    }\n    if (elementPosition) {\n      elementPosition.textContent = \"Position not available\"\n    }\n    if (elementImage) {\n      elementImage.innerHTML = '<div class=\"preview-placeholder\">No element preview available</div>'\n    }\n\n    // Hide optional sections\n    if (elementClassesContainer) elementClassesContainer.style.display = \"none\"\n    if (elementSelectorContainer) elementSelectorContainer.style.display = \"none\"\n    return\n  }\n\n  console.log(\"Updating CLS element preview with:\", element)\n\n  // Update element tag with more detailed information\n  if (elementTag) {\n    let tagDisplay = element.tagName ? element.tagName.toUpperCase() : \"ELEMENT\"\n    if (element.classList && element.classList.length > 0) {\n      tagDisplay += \".\" + element.classList[0]\n    } else if (element.id) {\n      tagDisplay += `#${element.id}`\n    }\n    elementTag.textContent = tagDisplay\n    elementTag.style.color = \"#ff9500\" // Orange color for CLS\n  }\n\n  // Update shift value\n  if (clsShiftValue) {\n    clsShiftValue.textContent = element.shiftValue\n      ? element.shiftValue.toFixed(3)\n      : clsValue\n        ? clsValue.toFixed(3)\n        : \"0.000\"\n  }\n\n  // Update dimensions\n  if (elementDimensions && element.dimensions) {\n    let dimensionText = `${element.dimensions.width || 0}×${element.dimensions.height || 0}px`\n    if (element.dimensions.naturalWidth && element.dimensions.naturalHeight) {\n      dimensionText += ` (natural: ${element.dimensions.naturalWidth}×${element.dimensions.naturalHeight}px)`\n    }\n    elementDimensions.textContent = dimensionText\n  } else if (elementDimensions) {\n    elementDimensions.textContent = \"Unknown dimensions\"\n  }\n\n  // Update position\n  if (elementPosition && element.position) {\n    elementPosition.textContent = `${element.position.left || 0}, ${element.position.top || 0}px`\n  } else if (elementPosition) {\n    elementPosition.textContent = \"Unknown position\"\n  }\n\n  // Update classes\n  if (elementClassesContainer && elementClasses && element.classList && element.classList.length > 0) {\n    elementClassesContainer.style.display = \"block\"\n    elementClasses.textContent = element.classList.join(\" \")\n    elementClasses.title = element.classList.join(\" \")\n  } else if (elementClassesContainer) {\n    elementClassesContainer.style.display = \"none\"\n  }\n\n  // Update CSS selector\n  if (elementSelectorContainer && elementSelector && element.selector) {\n    elementSelectorContainer.style.display = \"block\"\n    elementSelector.textContent = element.selector\n    elementSelector.title = element.selector\n  } else if (elementSelectorContainer) {\n    elementSelectorContainer.style.display = \"none\"\n  }\n\n  // Update preview image with click functionality\n  if (elementImage) {\n    const imageUrl =\n      element.preview || element.primarySource || element.src || element.currentSrc || element.backgroundImageUrl\n\n    if (imageUrl) {\n      console.log(\"Setting CLS preview image:\", imageUrl)\n      elementImage.innerHTML = `\n        <img src=\"${imageUrl}\" \n             alt=\"CLS Element Preview\" \n             class=\"element-preview-img clickable-preview\" \n             title=\"Click to highlight this element on the page\"\n             crossorigin=\"anonymous\">\n      `\n\n      // Add click handler to highlight element\n      const previewImg = elementImage.querySelector(\".clickable-preview\")\n      if (previewImg) {\n        previewImg.addEventListener(\"click\", () => {\n          highlightCLSElementOnPage()\n        })\n\n        // Add error handling for image loading\n        previewImg.addEventListener(\"error\", () => {\n          console.log(\"CLS preview image failed to load\")\n          elementImage.innerHTML = '<div class=\"preview-placeholder\">Preview not available</div>'\n        })\n      }\n    } else {\n      console.log(\"No image URL available for CLS preview\")\n      elementImage.innerHTML = '<div class=\"preview-placeholder\">No preview available</div>'\n    }\n  }\n\n  // Make the entire preview clickable\n  const clsElementPreview = document.getElementById(\"clsElementPreview\")\n  if (clsElementPreview) {\n    clsElementPreview.style.cursor = \"pointer\"\n    clsElementPreview.title = \"Click to highlight this element on the page\"\n\n    // Remove existing click handlers\n    clsElementPreview.replaceWith(clsElementPreview.cloneNode(true))\n    const newPreview = document.getElementById(\"clsElementPreview\")\n\n    newPreview.addEventListener(\"click\", () => {\n      highlightCLSElementOnPage()\n    })\n  }\n}\n\n/**\n * Updates the LCP element preview with enhanced information\n * @param {Object} element - LCP element data\n */\nfunction updateLCPElementPreview(element) {\n  console.log(\"updateLCPElementPreview called with:\", element)\n\n  const elementTag = document.getElementById(\"lcpElementTag\")\n  const elementImage = document.getElementById(\"lcpElementImage\")\n  const elementDimensions = document.getElementById(\"lcpElementDimensions\")\n  const elementPosition = document.getElementById(\"lcpElementPosition\")\n  const elementSrcContainer = document.getElementById(\"lcpElementSrcContainer\")\n  const elementSrc = document.getElementById(\"lcpElementSrc\")\n  const elementTextContainer = document.getElementById(\"lcpElementText\")\n  const elementText = document.getElementById(\"lcpElementText\")\n  const elementClassesContainer = document.getElementById(\"lcpElementClassesContainer\")\n  const elementClasses = document.getElementById(\"lcpElementClasses\")\n\n  // Handle case where element data might be empty or incomplete\n  if (!element || Object.keys(element).length === 0) {\n    console.log(\"No element data available, showing placeholder\")\n    if (elementTag) elementTag.textContent = \"LCP Element\"\n    if (elementDimensions) elementDimensions.textContent = \"Analyzing...\"\n    if (elementPosition) elementPosition.textContent = \"Analyzing...\"\n    if (elementImage) {\n      elementImage.innerHTML = '<div class=\"preview-placeholder\">Analyzing LCP element...</div>'\n    }\n\n    // Hide optional sections\n    if (elementSrcContainer) elementSrcContainer.style.display = \"none\"\n    if (elementTextContainer) elementTextContainer.style.display = \"none\"\n    if (elementClassesContainer) elementClassesContainer.style.display = \"none\"\n    return\n  }\n\n  console.log(\"Updating LCP element preview with:\", element)\n\n  // Update element tag with more detailed information\n  if (elementTag) {\n    let tagDisplay = element.tagName ? element.tagName.toUpperCase() : \"ELEMENT\"\n    if (element.classList && element.classList.length > 0) {\n      tagDisplay += \".\" + element.classList[0]\n    } else if (element.id) {\n      tagDisplay += `#${element.id}`\n    }\n    elementTag.textContent = tagDisplay\n    elementTag.style.color = \"#007aff\" // Make it blue like in the screenshot\n  }\n\n  // Update dimensions with natural dimensions if available\n  if (elementDimensions && element.dimensions) {\n    let dimensionText = `${element.dimensions.width || 0}×${element.dimensions.height || 0}px`\n    if (element.dimensions.naturalWidth && element.dimensions.naturalHeight) {\n      dimensionText += ` (natural: ${element.dimensions.naturalWidth}×${element.dimensions.naturalHeight}px)`\n    }\n    elementDimensions.textContent = dimensionText\n  } else if (elementDimensions) {\n    elementDimensions.textContent = \"Unknown dimensions\"\n  }\n\n  // Update position\n  if (elementPosition && element.position) {\n    elementPosition.textContent = `${element.position.left || 0}, ${element.position.top || 0}px`\n  } else if (elementPosition) {\n    elementPosition.textContent = \"Unknown position\"\n  }\n\n  // Update classes\n  if (elementClassesContainer && elementClasses && element.classList && element.classList.length > 0) {\n    elementClassesContainer.style.display = \"block\"\n    elementClasses.textContent = element.classList.join(\" \")\n    elementClasses.title = element.classList.join(\" \")\n  } else if (elementClassesContainer) {\n    elementClassesContainer.style.display = \"none\"\n  }\n\n  // Update source with primary source\n  if (element.primarySource || element.src || element.currentSrc || element.backgroundImageUrl) {\n    const sourceUrl = element.primarySource || element.src || element.currentSrc || element.backgroundImageUrl\n    if (elementSrcContainer && elementSrc) {\n      elementSrcContainer.style.display = \"block\"\n      const displaySrc = sourceUrl.length > 60 ? sourceUrl.substring(0, 60) + \"...\" : sourceUrl\n      elementSrc.textContent = displaySrc\n      elementSrc.title = sourceUrl\n    }\n  } else if (elementSrcContainer) {\n    elementSrcContainer.style.display = \"none\"\n  }\n\n  // Update text content\n  if (element.textContent && element.textContent.trim()) {\n    if (elementTextContainer && elementText) {\n      elementTextContainer.style.display = \"block\"\n      const displayText =\n        element.textContent.length > 60 ? element.textContent.substring(0, 60) + \"...\" : element.textContent\n      elementText.textContent = displayText\n      elementText.title = element.textContent\n    }\n  } else if (elementTextContainer) {\n    elementTextContainer.style.display = \"none\"\n  }\n\n  // Update preview image with click functionality\n  if (elementImage) {\n    const imageUrl =\n      element.preview || element.primarySource || element.src || element.currentSrc || element.backgroundImageUrl\n\n    if (imageUrl) {\n      console.log(\"Setting LCP preview image:\", imageUrl)\n      elementImage.innerHTML = `\n        <img src=\"${imageUrl}\" \n             alt=\"LCP Element Preview\" \n             class=\"element-preview-img clickable-preview\" \n             title=\"Click to highlight this element on the page\"\n             crossorigin=\"anonymous\">\n      `\n\n      // Add click handler to highlight element\n      const previewImg = elementImage.querySelector(\".clickable-preview\")\n      if (previewImg) {\n        previewImg.addEventListener(\"click\", () => {\n          highlightLCPElementOnPage()\n        })\n\n        // Add error handling for image loading\n        previewImg.addEventListener(\"error\", () => {\n          console.log(\"LCP preview image failed to load\")\n          elementImage.innerHTML = '<div class=\"preview-placeholder\">Preview not available</div>'\n        })\n      }\n    } else {\n      console.log(\"No image URL available for LCP preview\")\n      elementImage.innerHTML = '<div class=\"preview-placeholder\">No preview available</div>'\n    }\n  }\n\n  // Make the entire preview clickable\n  const lcpElementPreview = document.getElementById(\"lcpElementPreview\")\n  if (lcpElementPreview) {\n    lcpElementPreview.style.cursor = \"pointer\"\n    lcpElementPreview.title = \"Click to highlight this element on the page\"\n\n    // Remove existing click handlers\n    lcpElementPreview.replaceWith(lcpElementPreview.cloneNode(true))\n    const newPreview = document.getElementById(\"lcpElementPreview\")\n\n    newPreview.addEventListener(\"click\", () => {\n      highlightLCPElementOnPage()\n    })\n  }\n}\n\n/**\n * Updates the INP element preview with enhanced information\n * @param {Object} element - INP element data\n * @param {Object} interaction - Interaction entry data\n */\nfunction updateINPElementPreview(element, interaction) {\n  console.log(\"updateINPElementPreview called with:\", element, interaction)\n\n  const elementTag = document.getElementById(\"inpElementTag\")\n  const elementImage = document.getElementById(\"inpElementImage\")\n  const elementDimensions = document.getElementById(\"inpElementDimensions\")\n  const elementPosition = document.getElementById(\"inpElementPosition\")\n  const elementClassesContainer = document.getElementById(\"inpElementClassesContainer\")\n  const elementClasses = document.getElementById(\"inpElementClasses\")\n  const interactionTypeContainer = document.getElementById(\"inpInteractionTypeContainer\")\n  const interactionType = document.getElementById(\"inpInteractionType\")\n  const interactionDuration = document.getElementById(\"inpInteractionDuration\")\n\n  // Handle case where element data might be empty or incomplete\n  if (!element || Object.keys(element).length === 0) {\n    console.log(\"No INP element data available, showing interaction info\")\n    if (elementTag) elementTag.textContent = `${interaction.target || \"Element\"} (${interaction.name})`\n    if (interactionDuration) interactionDuration.textContent = `${interaction.duration}ms`\n    if (elementDimensions) elementDimensions.textContent = \"Element details not available\"\n    if (elementPosition) elementPosition.textContent = \"Position not available\"\n    if (elementImage) {\n      elementImage.innerHTML = '<div class=\"preview-placeholder\">No element preview available</div>'\n    }\n\n    // Hide optional sections\n    if (elementClassesContainer) elementClassesContainer.style.display = \"none\"\n    if (interactionTypeContainer) interactionTypeContainer.style.display = \"none\"\n    return\n  }\n\n  console.log(\"Updating INP element preview with:\", element)\n\n  // Update element tag with more detailed information\n  if (elementTag) {\n    let tagDisplay = element.tagName ? element.tagName.toUpperCase() : \"ELEMENT\"\n    if (element.classList && element.classList.length > 0) {\n      tagDisplay += \".\" + element.classList[0]\n    } else if (element.id) {\n      tagDisplay += `#${element.id}`\n    }\n    elementTag.textContent = tagDisplay\n    elementTag.style.color = \"#ff6b35\" // Orange-red color for INP\n  }\n\n  // Update interaction duration\n  if (interactionDuration) {\n    interactionDuration.textContent = `${interaction.duration}ms`\n  }\n\n  // Update dimensions\n  if (elementDimensions && element.dimensions) {\n    const dimensionText = `${element.dimensions.width || 0}×${element.dimensions.height || 0}px`\n    elementDimensions.textContent = dimensionText\n  } else if (elementDimensions) {\n    elementDimensions.textContent = \"Unknown dimensions\"\n  }\n\n  // Update position\n  if (elementPosition && element.position) {\n    elementPosition.textContent = `${element.position.left || 0}, ${element.position.top || 0}px`\n  } else if (elementPosition) {\n    elementPosition.textContent = \"Unknown position\"\n  }\n\n  // Update classes\n  if (elementClassesContainer && elementClasses && element.classList && element.classList.length > 0) {\n    elementClassesContainer.style.display = \"block\"\n    elementClasses.textContent = element.classList.join(\" \")\n    elementClasses.title = element.classList.join(\" \")\n  } else if (elementClassesContainer) {\n    elementClassesContainer.style.display = \"none\"\n  }\n\n  // Update interaction type\n  if (interactionTypeContainer && interactionType) {\n    interactionTypeContainer.style.display = \"block\"\n    interactionType.textContent = interaction.name || \"unknown\"\n  } else if (interactionTypeContainer) {\n    interactionTypeContainer.style.display = \"none\"\n  }\n\n  // Update preview image with click functionality\n  if (elementImage) {\n    const imageUrl = element.preview || element.src || element.currentSrc\n\n    if (imageUrl) {\n      console.log(\"Setting INP preview image:\", imageUrl)\n      elementImage.innerHTML = `\n        <img src=\"${imageUrl}\" \n             alt=\"INP Element Preview\" \n             class=\"element-preview-img clickable-preview\" \n             title=\"Click to highlight this element on the page\"\n             crossorigin=\"anonymous\">\n      `\n\n      // Add click handler to highlight element\n      const previewImg = elementImage.querySelector(\".clickable-preview\")\n      if (previewImg) {\n        previewImg.addEventListener(\"click\", () => {\n          highlightINPElementOnPage()\n        })\n\n        // Add error handling for image loading\n        previewImg.addEventListener(\"error\", () => {\n          console.log(\"INP preview image failed to load\")\n          elementImage.innerHTML = '<div class=\"preview-placeholder\">Preview not available</div>'\n        })\n      }\n    } else {\n      console.log(\"No image URL available for INP preview\")\n      elementImage.innerHTML = '<div class=\"preview-placeholder\">No preview available</div>'\n    }\n  }\n\n  // Make the entire preview clickable\n  const inpElementPreview = document.getElementById(\"inpElementPreview\")\n  if (inpElementPreview) {\n    inpElementPreview.style.cursor = \"pointer\"\n    inpElementPreview.title = \"Click to highlight this element on the page\"\n\n    // Remove existing click handlers\n    inpElementPreview.replaceWith(inpElementPreview.cloneNode(true))\n    const newPreview = document.getElementById(\"inpElementPreview\")\n\n    newPreview.addEventListener(\"click\", () => {\n      highlightINPElementOnPage()\n    })\n  }\n}\n\n/**\n * Highlights the INP element on the page\n */\nasync function highlightINPElementOnPage() {\n  console.log(\"highlightINPElementOnPage called\")\n\n  const inpElementPreview = document.getElementById(\"inpElementPreview\")\n\n  try {\n    // Use the improved getTargetTabId function that auto-detects mode\n    const targetTabId = await getTargetTabId()\n    console.log(\"Target tab ID for INP highlighting:\", targetTabId)\n\n    if (!targetTabId) {\n      console.log(\"No target tab available for INP highlighting\")\n      if (inpElementPreview) {\n        showElementFeedback(inpElementPreview, \"error\")\n      }\n      return false\n    }\n\n    // Show immediate feedback\n    if (inpElementPreview) {\n      showElementFeedback(inpElementPreview, \"success\")\n    }\n\n    const response = await sendMessageToContentScript(targetTabId, {\n      action: \"highlightINPElement\",\n    })\n\n    console.log(\"INP highlight response:\", response)\n    return !!response\n  } catch (error) {\n    console.error(\"Error highlighting INP element:\", error)\n    if (inpElementPreview) {\n      showElementFeedback(inpElementPreview, \"error\")\n    }\n    return false\n  }\n}\n\n/**\n * Highlights the CLS element on the page\n */\nasync function highlightCLSElementOnPage() {\n  console.log(\"highlightCLSElementOnPage called\")\n\n  const clsElementPreview = document.getElementById(\"clsElementPreview\")\n\n  try {\n    // Use the improved getTargetTabId function that auto-detects mode\n    const targetTabId = await getTargetTabId()\n    console.log(\"Target tab ID for CLS highlighting:\", targetTabId)\n\n    if (!targetTabId) {\n      console.log(\"No target tab available for CLS highlighting\")\n      if (clsElementPreview) {\n        showElementFeedback(clsElementPreview, \"error\")\n      }\n      return false\n    }\n\n    // Show immediate feedback\n    if (clsElementPreview) {\n      showElementFeedback(clsElementPreview, \"success\")\n    }\n\n    const response = await sendMessageToContentScript(targetTabId, {\n      action: \"highlightCLSElement\",\n    })\n\n    console.log(\"CLS highlight response:\", response)\n    return !!response\n  } catch (error) {\n    console.error(\"Error highlighting CLS element:\", error)\n    if (clsElementPreview) {\n      showElementFeedback(clsElementPreview, \"error\")\n    }\n    return false\n  }\n}\n\n/**\n * Highlights the LCP element on the page\n */\nasync function highlightLCPElementOnPage() {\n  console.log(\"highlightLCPElementOnPage called\")\n\n  const lcpElementPreview = document.getElementById(\"lcpElementPreview\")\n\n  try {\n    // Use the improved getTargetTabId function that auto-detects mode\n    const targetTabId = await getTargetTabId()\n    console.log(\"Target tab ID for LCP highlighting:\", targetTabId)\n\n    if (!targetTabId) {\n      console.log(\"No target tab available for LCP highlighting\")\n      if (lcpElementPreview) {\n        showElementFeedback(lcpElementPreview, \"error\")\n      }\n      return false\n    }\n\n    // Show immediate feedback\n    if (lcpElementPreview) {\n      showElementFeedback(lcpElementPreview, \"success\")\n    }\n\n    const response = await sendMessageToContentScript(targetTabId, {\n      action: \"highlightLCPElement\",\n    })\n\n    console.log(\"LCP highlight response:\", response)\n    return !!response\n  } catch (error) {\n    console.error(\"Error highlighting LCP element:\", error)\n    if (lcpElementPreview) {\n      showElementFeedback(lcpElementPreview, \"error\")\n    }\n    return false\n  }\n}\n\n/**\n * Updates threshold indicators with correct Core Web Vitals ranges\n * Now supports combination indicators when values are close (within tolerance)\n */\nfunction updateMetricThresholds(metric, value, isField = false, isLab = false) {\n  const threshold = THRESHOLDS[metric]\n  if (!threshold || value === null || value === undefined) return\n\n  const bar = document.querySelector(`.${metric}-bar`)\n  if (!bar) return\n\n  // Calculate position based on threshold ranges\n  let percentage = 0\n  const maxValue = threshold.needsImprovement * 2 // Extended range for visualization\n\n  if (metric === \"cls\") {\n    // CLS uses different scale (0-1 range)\n    percentage = Math.min((value / 0.5) * 100, 100)\n  } else {\n    // Time-based metrics (ms)\n    percentage = Math.min((value / maxValue) * 100, 100)\n  }\n\n  // Determine indicator type and data label\n  let dataType = \"local\"\n  let dataLabel = \"Local\"\n\n  if (isLab) {\n    dataType = \"lab\"\n    dataLabel = \"Lab\"\n  } else if (isField) {\n    dataType = \"field\"\n    dataLabel = \"Field\"\n  }\n\n  // Get current metric values for combination checking\n  const localValue = insightsState.metrics[metric].local\n  const fieldValue = insightsState.metrics[metric].field\n  const labValue = insightsState.metrics[metric].lab\n\n  // Define tolerance for \"close enough\" values (0% to 0.1% tolerance)\n  const tolerance = calculateTolerance(metric, value)\n\n  // Check for matching values within tolerance\n  const localFieldMatch = localValue !== null && fieldValue !== null && Math.abs(localValue - fieldValue) <= tolerance\n  const localLabMatch = localValue !== null && labValue !== null && Math.abs(localValue - labValue) <= tolerance\n  const fieldLabMatch = fieldValue !== null && labValue !== null && Math.abs(fieldValue - labValue) <= tolerance\n  const allMatch =\n    localValue !== null && fieldValue !== null && labValue !== null && localFieldMatch && localLabMatch && fieldLabMatch\n\n  // Remove all existing indicators for this metric to avoid duplicates\n  const existingIndicators = bar.querySelectorAll(\".threshold-indicator\")\n  existingIndicators.forEach((indicator) => indicator.remove())\n\n  // Create indicators based on combinations and individual values\n  const indicatorsToCreate = new Set()\n\n  if (allMatch) {\n    // All three sources match - show single combination indicator\n    const indicator = document.createElement(\"div\")\n    indicator.className = `threshold-indicator all-sources-indicator`\n    indicator.style.left = `${percentage}%`\n    indicator.setAttribute(\"data-type\", \"all-sources-indicator\")\n    indicator.setAttribute(\"data-metric\", metric)\n    indicator.setAttribute(\"data-value\", value)\n    indicator.setAttribute(\"data-position\", percentage.toFixed(2))\n    indicator.title = `All Sources Match: ${formatMetricValue(metric, value)}`\n    bar.appendChild(indicator)\n    console.log(`Added all-sources combination indicator for ${metric} at ${percentage}%`)\n  } else {\n    // Handle partial matches and individual indicators\n    if (localFieldMatch && localValue !== null && fieldValue !== null) {\n      // Local and Field match - create combination indicator\n      const localPercentage = calculateIndicatorPosition(metric, localValue)\n      const indicator = document.createElement(\"div\")\n      indicator.className = `threshold-indicator local-field-indicator`\n      indicator.style.left = `${localPercentage}%`\n      indicator.setAttribute(\"data-type\", \"local-field-indicator\")\n      indicator.setAttribute(\"data-metric\", metric)\n      indicator.setAttribute(\"data-value\", localValue)\n      indicator.setAttribute(\"data-position\", localPercentage.toFixed(2))\n      indicator.title = `Local + Field Match: ${formatMetricValue(metric, localValue)}`\n      bar.appendChild(indicator)\n\n      // Add lab indicator separately if it exists and doesn't match\n      if (labValue !== null && !localLabMatch) {\n        createIndividualIndicator(bar, metric, labValue, \"lab\", \"Lab\")\n      }\n    } else if (localLabMatch && localValue !== null && labValue !== null) {\n      // Local and Lab match - create combination indicator\n      const localPercentage = calculateIndicatorPosition(metric, localValue)\n      const indicator = document.createElement(\"div\")\n      indicator.className = `threshold-indicator local-lab-indicator`\n      indicator.style.left = `${localPercentage}%`\n      indicator.setAttribute(\"data-type\", \"local-lab-indicator\")\n      indicator.setAttribute(\"data-metric\", metric)\n      indicator.setAttribute(\"data-value\", localValue)\n      indicator.setAttribute(\"data-position\", localPercentage.toFixed(2))\n      indicator.title = `Local + Lab Match: ${formatMetricValue(metric, localValue)}`\n      bar.appendChild(indicator)\n\n      // Add field indicator separately if it exists and doesn't match\n      if (fieldValue !== null && !localFieldMatch) {\n        createIndividualIndicator(bar, metric, fieldValue, \"field\", \"Field\")\n      }\n    } else if (fieldLabMatch && fieldValue !== null && labValue !== null) {\n      // Field and Lab match - create combination indicator\n      const fieldPercentage = calculateIndicatorPosition(metric, fieldValue)\n      const indicator = document.createElement(\"div\")\n      indicator.className = `threshold-indicator field-lab-indicator`\n      indicator.style.left = `${fieldPercentage}%`\n      indicator.setAttribute(\"data-type\", \"field-lab-indicator\")\n      indicator.setAttribute(\"data-metric\", metric)\n      indicator.setAttribute(\"data-value\", fieldValue)\n      indicator.setAttribute(\"data-position\", fieldPercentage.toFixed(2))\n      indicator.title = `Field + Lab Match: ${formatMetricValue(metric, fieldValue)}`\n      bar.appendChild(indicator)\n\n      // Add local indicator separately if it exists and doesn't match\n      if (localValue !== null && !localFieldMatch) {\n        createIndividualIndicator(bar, metric, localValue, \"local\", \"Local\")\n      }\n    } else {\n      // No matches - create individual indicators for all available sources\n      if (localValue !== null) {\n        createIndividualIndicator(bar, metric, localValue, \"local\", \"Local\")\n      }\n      if (fieldValue !== null) {\n        createIndividualIndicator(bar, metric, fieldValue, \"field\", \"Field\")\n      }\n      if (labValue !== null && (metric === \"cls\" || metric === \"lcp\")) {\n        createIndividualIndicator(bar, metric, labValue, \"lab\", \"Lab\")\n      }\n    }\n  }\n\n  // Smart positioning logic for multiple indicators\n  const allIndicators = bar.querySelectorAll(\".threshold-indicator\")\n  if (allIndicators.length > 1) {\n    bar.classList.add(\"multiple-indicators\")\n    positionIndicatorsIntelligently(bar, allIndicators)\n  } else {\n    bar.classList.remove(\"multiple-indicators\")\n  }\n}\n\n/**\n * Calculate tolerance based on metric type and value\n * 0% to 0.1% tolerance as requested\n */\nfunction calculateTolerance(metric, value) {\n  if (metric === \"cls\") {\n    // For CLS, 0.1% of typical range (0-0.5)\n    return Math.max(0.0005, value * 0.001) // Minimum 0.0005, or 0.1% of value\n  } else {\n    // For time-based metrics, 0.1% of value with minimum 1ms\n    return Math.max(1, value * 0.001) // Minimum 1ms, or 0.1% of value\n  }\n}\n\n/**\n * Calculate indicator position on the threshold bar\n */\nfunction calculateIndicatorPosition(metric, value) {\n  const threshold = THRESHOLDS[metric]\n  if (!threshold) return 0\n\n  const maxValue = threshold.needsImprovement * 2\n\n  if (metric === \"cls\") {\n    return Math.min((value / 0.5) * 100, 100)\n  } else {\n    return Math.min((value / maxValue) * 100, 100)\n  }\n}\n\n/**\n * Create individual indicator for a specific data source\n */\nfunction createIndividualIndicator(bar, metric, value, dataType, dataLabel) {\n  const threshold = THRESHOLDS[metric]\n  if (!threshold) return\n\n  // Calculate position\n  let percentage = 0\n  const maxValue = threshold.needsImprovement * 2\n\n  if (metric === \"cls\") {\n    percentage = Math.min((value / 0.5) * 100, 100)\n  } else {\n    percentage = Math.min((value / maxValue) * 100, 100)\n  }\n\n  const indicator = document.createElement(\"div\")\n  indicator.className = `threshold-indicator ${dataType}-indicator`\n  indicator.style.left = `${percentage}%`\n  indicator.setAttribute(\"data-type\", dataType)\n  indicator.setAttribute(\"data-metric\", metric)\n  indicator.setAttribute(\"data-value\", value)\n  indicator.setAttribute(\"data-position\", percentage.toFixed(2))\n  indicator.title = `${dataLabel}: ${formatMetricValue(metric, value)}`\n\n  bar.appendChild(indicator)\n}\n\n/**\n * Intelligently positions indicators to handle overlaps and same-position stacking\n */\nfunction positionIndicatorsIntelligently(bar, indicators) {\n  // Group indicators by position (within 1% tolerance for same position)\n  const positionGroups = new Map()\n\n  indicators.forEach((indicator) => {\n    const position = Number.parseFloat(indicator.getAttribute(\"data-position\"))\n    let foundGroup = false\n\n    // Check if this position is close to any existing group\n    for (const [groupPos, group] of positionGroups) {\n      if (Math.abs(position - groupPos) <= 1) {\n        group.push(indicator)\n        foundGroup = true\n        break\n      }\n    }\n\n    if (!foundGroup) {\n      positionGroups.set(position, [indicator])\n    }\n  })\n\n  // Position indicators within each group\n  positionGroups.forEach((group, position) => {\n    if (group.length === 1) {\n      // Single indicator - normal positioning\n      const indicator = group[0]\n      indicator.style.left = `${position}%`\n      indicator.style.top = \"-5px\" // Updated position\n      indicator.style.zIndex = \"10\"\n    } else {\n      // Multiple indicators at same position - stack them\n      group.forEach((indicator, index) => {\n        const dataType = indicator.getAttribute(\"data-type\")\n\n        // Vertical stacking with slight horizontal offset for visibility\n        const verticalOffset = index * 8 // 8px vertical spacing\n        const horizontalOffset = index * 2 // 2px horizontal offset for better visibility\n\n        indicator.style.left = `calc(${position}% + ${horizontalOffset}px)`\n        indicator.style.top = `${-5 - verticalOffset}px` // Updated position\n        indicator.style.zIndex = `${15 + index}` // Higher z-index for stacked items\n\n        // Add stacked class for special styling\n        indicator.classList.add(\"stacked-indicator\")\n      })\n    }\n  })\n}\n\n// Initialize PSI button when the module loads\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  setupPSIAnalyzeButton()\n})\n\n// Also export the setup function so it can be called from other modules\nexport { setupPSIAnalyzeButton, resetDataAvailability }\n\n// Export the state management function\nexport { updateInsightsState }\n\n// Ensure PSI button is set up when module loads\nif (document.readyState === \"loading\") {\n  document.addEventListener(\"DOMContentLoaded\", setupPSIAnalyzeButton)\n} else {\n  setupPSIAnalyzeButton()\n}\n","/**\n * Simplified PSI Insights Renderer\n * Renders PageSpeed Insights data with minimal DOM structure\n */\n\nexport class InsightsRenderer {\n  constructor() {\n    this.expandedInsights = new Set()\n    this.activeTooltip = null\n  }\n\n  /**\n   * Render the complete PSI insights interface\n   */\n  renderInsights(container, insights) {\n    if (!container) {\n      console.error(\"InsightsRenderer: Container element not found\")\n      return\n    }\n\n    // Clear existing content\n    container.innerHTML = \"\"\n\n    if (!insights || !Array.isArray(insights) || insights.length === 0) {\n      this.renderEmptyState(container)\n      return\n    }\n\n    // Render header directly to container\n    const header = this.renderHeader(insights.length)\n    container.appendChild(header)\n\n    // Render insights directly to container\n    insights.forEach((insight, index) => {\n      const item = this.renderInsightItem(insight, index)\n      container.appendChild(item)\n    })\n\n    // Initialize tooltip system after rendering\n    this.initializeTooltips()\n  }\n\n  /**\n   * Initialize smart tooltip system with proper cleanup\n   */\n  initializeTooltips() {\n    // Clean up any existing tooltips and listeners\n    this.cleanupTooltips()\n\n    // Add event listeners to all tooltip triggers\n    document.querySelectorAll(\".tooltip-trigger\").forEach((trigger) => {\n      trigger.addEventListener(\"mouseenter\", (e) => this.showTooltip(e))\n      trigger.addEventListener(\"mouseleave\", (e) => this.hideTooltip(e))\n      trigger.addEventListener(\"mousemove\", (e) => this.updateTooltipPosition(e))\n    })\n  }\n\n  /**\n   * Clean up all tooltips and prevent clustering\n   */\n  cleanupTooltips() {\n    // Remove all existing tooltips\n    document.querySelectorAll(\".smart-tooltip\").forEach((tooltip) => tooltip.remove())\n    this.activeTooltip = null\n  }\n\n  /**\n   * Show smart positioned tooltip with clustering prevention\n   */\n  showTooltip(event) {\n    // Prevent multiple tooltips\n    this.cleanupTooltips()\n\n    const trigger = event.target\n    const tooltipText = trigger.getAttribute(\"data-tooltip\")\n\n    if (!tooltipText) return\n\n    // Create tooltip element\n    const tooltip = document.createElement(\"div\")\n    tooltip.className = \"smart-tooltip\"\n    tooltip.textContent = tooltipText\n    document.body.appendChild(tooltip)\n\n    // Store reference\n    this.activeTooltip = tooltip\n    trigger._tooltip = tooltip\n\n    // Position tooltip\n    this.positionTooltip(trigger, tooltip)\n  }\n\n  /**\n   * Position tooltip intelligently\n   */\n  positionTooltip(trigger, tooltip) {\n    const triggerRect = trigger.getBoundingClientRect()\n    const tooltipRect = tooltip.getBoundingClientRect()\n    const viewportWidth = window.innerWidth\n    const viewportHeight = window.innerHeight\n    const padding = 16\n\n    // Calculate initial position (below trigger)\n    let left = triggerRect.left\n    let top = triggerRect.bottom + 8\n\n    // Adjust horizontal position if tooltip would overflow\n    if (left + tooltipRect.width > viewportWidth - padding) {\n      left = viewportWidth - tooltipRect.width - padding\n    }\n    if (left < padding) {\n      left = padding\n    }\n\n    // Adjust vertical position if tooltip would overflow\n    if (top + tooltipRect.height > viewportHeight - padding) {\n      top = triggerRect.top - tooltipRect.height - 8\n    }\n    if (top < padding) {\n      top = triggerRect.bottom + 8 // Fallback to below\n    }\n\n    // Apply position with smooth animation\n    tooltip.style.left = `${left}px`\n    tooltip.style.top = `${top}px`\n    tooltip.style.opacity = \"1\"\n    tooltip.style.transform = \"translateY(0)\"\n  }\n\n  /**\n   * Update tooltip position on mouse move (for better tracking)\n   */\n  updateTooltipPosition(event) {\n    if (!this.activeTooltip) return\n\n    const trigger = event.target\n    this.positionTooltip(trigger, this.activeTooltip)\n  }\n\n  /**\n   * Hide tooltip with proper cleanup\n   */\n  hideTooltip(event) {\n    const trigger = event.target\n    if (trigger._tooltip) {\n      trigger._tooltip.remove()\n      trigger._tooltip = null\n    }\n    if (this.activeTooltip) {\n      this.activeTooltip.remove()\n      this.activeTooltip = null\n    }\n  }\n\n  /**\n   * Render the insights header with count\n   */\n  renderHeader(count) {\n    const header = document.createElement(\"div\")\n    header.className = \"psi-insights-header\"\n\n    const title = document.createElement(\"h3\")\n    title.className = \"section-title\"\n    title.textContent = \"Performance Insights\"\n\n    const countBadge = document.createElement(\"span\")\n    countBadge.className = \"insights-count\"\n    countBadge.textContent = `${count} insights`\n\n    header.appendChild(title)\n    header.appendChild(countBadge)\n\n    return header\n  }\n\n  /**\n   * Render individual insight item - simplified without icons\n   */\n  renderInsightItem(insight, index) {\n    const item = document.createElement(\"div\")\n\n    // Determine status based on score instead of hardcoding\n    const statusClass = this.determineInsightStatus(insight)\n    item.className = `psi-insight-item ${statusClass}`\n\n    // Create header\n    const header = this.renderInsightHeader(insight, index)\n    item.appendChild(header)\n\n    // Create content (initially hidden)\n    const content = this.renderInsightContent(insight)\n    item.appendChild(content)\n\n    return item\n  }\n\n  /**\n   * Determine insight status based on category and score\n   */\n  determineInsightStatus(insight) {\n    // First check if insight has a category from the API\n    if (insight.category) {\n      switch (insight.category) {\n        case \"failed\":\n          return \"failed-insight\"\n        case \"warning\":\n          return \"warning-insight\"\n        default:\n          return \"unknown-insight\"\n      }\n    }\n\n    // Fallback to score-based determination if no category\n    if (insight.score === undefined || insight.score === null) {\n      return \"unknown-insight\"\n    }\n\n    const score = Number.parseFloat(insight.score)\n\n    // PSI scoring: 0-0.49 = failed, 0.5-0.89 = warning\n    if (score < 0.5) {\n      return \"failed-insight\"\n    } else if (score < 0.9) {\n      return \"warning-insight\"\n    } else {\n      return \"unknown-insight\"\n    }\n  }\n\n  /**\n   * Render insight header (clickable) - simplified without icons\n   */\n  renderInsightHeader(insight, index) {\n    const header = document.createElement(\"div\")\n    header.className = \"insight-header\"\n    header.setAttribute(\"role\", \"button\")\n    header.setAttribute(\"tabindex\", \"0\")\n    header.setAttribute(\"aria-expanded\", \"false\")\n\n    // Title only (no icon)\n    const title = document.createElement(\"div\")\n    title.className = \"insight-title\"\n    title.textContent = this.formatInsightTitle(insight.title || insight.id)\n\n    // Expand icon\n    const expandIcon = document.createElement(\"div\")\n    expandIcon.className = \"insight-expand-icon\"\n    expandIcon.innerHTML = `\n            <svg viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\">\n                <polyline points=\"6,9 12,15 18,9\"></polyline>\n            </svg>\n        `\n\n    header.appendChild(title)\n    header.appendChild(expandIcon)\n\n    // Add click handler\n    header.addEventListener(\"click\", () => this.toggleInsight(header.parentElement, index))\n    header.addEventListener(\"keydown\", (e) => {\n      if (e.key === \"Enter\" || e.key === \" \") {\n        e.preventDefault()\n        this.toggleInsight(header.parentElement, index)\n      }\n    })\n\n    return header\n  }\n\n  /**\n   * Render insight content with support for different detail types\n   */\n  renderInsightContent(insight) {\n    console.log(\"Rendering insight content for:\", insight.title || insight.id, insight)\n\n    const content = document.createElement(\"div\")\n    content.className = \"insight-content\"\n\n    // Add description if available\n    if (insight.description) {\n      const description = this.renderDescription(insight.description)\n      content.appendChild(description)\n    }\n\n    // Special handling for network dependency tree\n    if (insight.id === \"network-dependency-tree-insight\" || insight.id === \"critical-request-chains\") {\n      console.log(\"Detected network dependency tree insight\")\n      const networkTree = this.renderNetworkDependencyFromAPI(insight)\n      content.appendChild(networkTree)\n      return content\n    }\n\n    // Handle different types of details\n    if (insight.details) {\n      console.log(\"Processing insight details:\", insight.details)\n\n      if (insight.details.type === \"network-tree\") {\n        console.log(\"Rendering network tree for:\", insight.title)\n        const networkTree = this.renderNetworkTree(insight.details)\n        content.appendChild(networkTree)\n      } else if (insight.details.items) {\n        console.log(\"Rendering details items for:\", insight.title)\n        const detailsContainer = this.renderDetails(insight.details, insight)\n        if (detailsContainer.children.length > 0) {\n          content.appendChild(detailsContainer)\n        }\n      } else {\n        console.log(\"Unknown details structure for:\", insight.title, insight.details)\n        // Show raw details structure for debugging\n        const debugContainer = document.createElement(\"div\")\n        debugContainer.className = \"debug-details\"\n        debugContainer.innerHTML = `<pre style=\"font-size: 10px; max-height: 150px; overflow: auto;\">${JSON.stringify(insight.details, null, 2)}</pre>`\n        content.appendChild(debugContainer)\n      }\n    } else {\n      console.log(\"No details found for:\", insight.title)\n      // Show a minimal \"no data\" message if no details\n      const noData = document.createElement(\"div\")\n      noData.className = \"no-data-message\"\n      noData.textContent = \"No detailed data available\"\n      content.appendChild(noData)\n    }\n\n    return content\n  }\n\n  /**\n   * Render network dependency tree from API response structure\n   */\n  renderNetworkDependencyFromAPI(insight) {\n    console.log(\"Rendering network dependency tree from API:\", insight)\n\n    const container = document.createElement(\"div\")\n    container.className = \"network-dependency-container\"\n\n    // Extract chains data from the API structure\n    let chainsData = null\n    let longestChain = null\n\n    if (insight.details && insight.details.items && insight.details.items.length > 0) {\n      const firstItem = insight.details.items[0]\n      if (firstItem.value && firstItem.value.chains) {\n        chainsData = firstItem.value.chains\n        longestChain = firstItem.value.longestChain\n        console.log(\"Found chains data:\", chainsData)\n      }\n    }\n\n    if (chainsData && Object.keys(chainsData).length > 0) {\n      // Show summary info\n      const summary = document.createElement(\"div\")\n      summary.className = \"network-summary\"\n\n      const chainCount = Object.keys(chainsData).length\n\n      summary.innerHTML = `\n        <div class=\"summary-item\">\n          <span class=\"summary-label\">Critical chains:</span>\n          <span class=\"summary-value\">${chainCount}</span>\n        </div>\n        ${\n          longestChain && longestChain.duration\n            ? `\n        <div class=\"summary-item\">\n          <span class=\"summary-label\">Longest chain:</span>\n          <span class=\"summary-value\">${Math.round(longestChain.duration)}ms</span>\n        </div>\n        `\n            : \"\"\n        }\n      `\n      container.appendChild(summary)\n\n      // Render each chain\n      const chainsContainer = document.createElement(\"div\")\n      chainsContainer.className = \"critical-chains\"\n\n      Object.entries(chainsData).forEach(([chainId, chain], index) => {\n        const chainHeader = document.createElement(\"div\")\n        chainHeader.className = \"chain-header\"\n        chainHeader.textContent = `Chain ${index + 1}`\n        chainsContainer.appendChild(chainHeader)\n\n        const chainTree = this.renderAPIChain(chain, 0)\n        chainsContainer.appendChild(chainTree)\n      })\n\n      container.appendChild(chainsContainer)\n    } else {\n      // No chains data found\n      const noChains = document.createElement(\"div\")\n      noChains.className = \"no-chains-message\"\n      noChains.textContent = \"No critical request chains detected\"\n      container.appendChild(noChains)\n    }\n\n    return container\n  }\n\n  /**\n   * Render a chain from the API response structure\n   */\n  renderAPIChain(chain, depth) {\n    const chainElement = document.createElement(\"div\")\n    chainElement.className = `critical-chain-item depth-${depth}`\n\n    // Create the main item\n    const itemElement = document.createElement(\"div\")\n    itemElement.className = \"chain-item\"\n\n    // Add indentation\n    const indent = document.createElement(\"div\")\n    indent.className = \"chain-indent\"\n    indent.style.width = `${depth * 16}px`\n\n    if (depth > 0) {\n      indent.innerHTML = \"└─ \"\n    }\n\n    // Extract URL info\n    const url = chain.url || \"Unknown URL\"\n    const filename = this.extractFilename(url)\n    const domain = this.extractDomain(url)\n\n    // Create URL display\n    const urlDisplay = document.createElement(\"div\")\n    urlDisplay.className = \"chain-url\"\n\n    const urlText = document.createElement(\"span\")\n    urlText.className = \"url-text tooltip-trigger\"\n    urlText.setAttribute(\"data-tooltip\", url)\n    urlText.textContent = filename\n\n    if (domain && !domain.includes(window.location.hostname)) {\n      const domainSpan = document.createElement(\"span\")\n      domainSpan.className = \"url-domain\"\n      domainSpan.textContent = ` (${domain})`\n      urlText.appendChild(domainSpan)\n    }\n\n    urlDisplay.appendChild(urlText)\n\n    // Add timing info\n    const timing = document.createElement(\"div\")\n    timing.className = \"chain-timing\"\n\n    const transferSize = chain.transferSize || 0\n    const duration = chain.navStartToEndTime || 0\n\n    timing.innerHTML = `\n      <span class=\"timing-size\">${this.formatBytes(transferSize)}</span>\n      <span class=\"timing-duration\">${Math.round(duration)}ms</span>\n    `\n\n    // Combine elements\n    itemElement.appendChild(indent)\n    itemElement.appendChild(urlDisplay)\n    itemElement.appendChild(timing)\n    chainElement.appendChild(itemElement)\n\n    // Render children recursively\n    if (chain.children && Object.keys(chain.children).length > 0) {\n      Object.values(chain.children).forEach((childChain) => {\n        const childElement = this.renderAPIChain(childChain, depth + 1)\n        chainElement.appendChild(childElement)\n      })\n    }\n\n    return chainElement\n  }\n\n  /**\n   * Render network dependency tree specifically for critical request chains\n   */\n  renderNetworkDependencyTree(insight) {\n    console.log(\"Rendering network dependency tree for critical request chains:\", insight)\n\n    const container = document.createElement(\"div\")\n    container.className = \"network-dependency-container\"\n\n    // Check if we have chains data\n    let chainsData = null\n\n    if (insight.details && insight.details.chains) {\n      chainsData = insight.details.chains\n    } else if (insight.details && insight.details.items) {\n      // Look for chains in items\n      for (const item of insight.details.items) {\n        if (item.chains) {\n          chainsData = item.chains\n          break\n        }\n      }\n    }\n\n    if (chainsData && Object.keys(chainsData).length > 0) {\n      // Show summary info\n      const summary = document.createElement(\"div\")\n      summary.className = \"network-summary\"\n\n      const chainCount = Object.keys(chainsData).length\n      const longestChain = this.findLongestChain(chainsData)\n\n      summary.innerHTML = `\n        <div class=\"summary-item\">\n          <span class=\"summary-label\">Critical chains:</span>\n          <span class=\"summary-value\">${chainCount}</span>\n        </div>\n        ${\n          longestChain\n            ? `\n        <div class=\"summary-item\">\n          <span class=\"summary-label\">Longest chain:</span>\n          <span class=\"summary-value\">${Math.round(longestChain.duration)}ms</span>\n        </div>\n        `\n            : \"\"\n        }\n      `\n      container.appendChild(summary)\n\n      // Render each chain\n      const chainsContainer = document.createElement(\"div\")\n      chainsContainer.className = \"critical-chains\"\n\n      Object.entries(chainsData).forEach(([chainId, chain], index) => {\n        const chainHeader = document.createElement(\"div\")\n        chainHeader.className = \"chain-header\"\n        chainHeader.textContent = `Chain ${index + 1}`\n        chainsContainer.appendChild(chainHeader)\n\n        const chainTree = this.renderCriticalChain(chain, 0)\n        chainsContainer.appendChild(chainTree)\n      })\n\n      container.appendChild(chainsContainer)\n    } else {\n      // No chains data found\n      const noChains = document.createElement(\"div\")\n      noChains.className = \"no-chains-message\"\n      noChains.textContent = \"No critical request chains detected\"\n      container.appendChild(noChains)\n    }\n\n    return container\n  }\n\n  /**\n   * Find the longest chain for summary display\n   */\n  findLongestChain(chainsData) {\n    let longest = null\n    let maxDuration = 0\n\n    Object.values(chainsData).forEach((chain) => {\n      const duration = this.calculateChainDuration(chain)\n      if (duration > maxDuration) {\n        maxDuration = duration\n        longest = { ...chain, duration }\n      }\n    })\n\n    return longest\n  }\n\n  /**\n   * Calculate total duration of a chain\n   */\n  calculateChainDuration(chain) {\n    let totalDuration = chain.transferSize || 0\n\n    if (chain.children) {\n      Object.values(chain.children).forEach((child) => {\n        totalDuration += this.calculateChainDuration(child)\n      })\n    }\n\n    return totalDuration\n  }\n\n  /**\n   * Render a critical request chain\n   */\n  renderCriticalChain(chain, depth) {\n    const chainElement = document.createElement(\"div\")\n    chainElement.className = `critical-chain-item depth-${depth}`\n\n    // Create the main item\n    const itemElement = document.createElement(\"div\")\n    itemElement.className = \"chain-item\"\n\n    // Add indentation\n    const indent = document.createElement(\"div\")\n    indent.className = \"chain-indent\"\n    indent.style.width = `${depth * 16}px`\n\n    if (depth > 0) {\n      indent.innerHTML = \"└─ \"\n    }\n\n    // Extract URL info\n    const url = chain.request?.url || chain.url || \"Unknown URL\"\n    const filename = this.extractFilename(url)\n    const domain = this.extractDomain(url)\n\n    // Create URL display\n    const urlDisplay = document.createElement(\"div\")\n    urlDisplay.className = \"chain-url\"\n\n    const urlText = document.createElement(\"span\")\n    urlText.className = \"url-text tooltip-trigger\"\n    urlText.setAttribute(\"data-tooltip\", url)\n    urlText.textContent = filename\n\n    if (domain && !domain.includes(window.location.hostname)) {\n      const domainSpan = document.createElement(\"span\")\n      domainSpan.className = \"url-domain\"\n      domainSpan.textContent = ` (${domain})`\n      urlText.appendChild(domainSpan)\n    }\n\n    urlDisplay.appendChild(urlText)\n\n    // Add timing info\n    const timing = document.createElement(\"div\")\n    timing.className = \"chain-timing\"\n\n    const transferSize = chain.transferSize || 0\n    const duration = chain.responseReceivedTime - chain.startTime || 0\n\n    timing.innerHTML = `\n      <span class=\"timing-size\">${this.formatBytes(transferSize)}</span>\n      <span class=\"timing-duration\">${Math.round(duration)}ms</span>\n    `\n\n    // Combine elements\n    itemElement.appendChild(indent)\n    itemElement.appendChild(urlDisplay)\n    itemElement.appendChild(timing)\n    chainElement.appendChild(itemElement)\n\n    // Render children recursively\n    if (chain.children && Object.keys(chain.children).length > 0) {\n      Object.values(chain.children).forEach((childChain) => {\n        const childElement = this.renderCriticalChain(childChain, depth + 1)\n        chainElement.appendChild(childElement)\n      })\n    }\n\n    return chainElement\n  }\n\n  /**\n   * Render insight description with link formatting\n   */\n  renderDescription(description) {\n    const descContainer = document.createElement(\"div\")\n    descContainer.className = \"insight-description\"\n\n    // Convert markdown-style links to HTML links\n    const htmlDescription = description.replace(\n      /\\[([^\\]]+)\\]$$([^)]+)$$/g,\n      '<a href=\"$2\" target=\"_blank\" rel=\"noopener noreferrer\" class=\"insight-link\">$1</a>',\n    )\n\n    descContainer.innerHTML = htmlDescription\n    return descContainer\n  }\n\n  /**\n   * Render details based on type\n   */\n  renderDetails(details, insight) {\n    const container = document.createElement(\"div\")\n    container.className = \"insight-details-container\"\n\n    if (!details.items || !Array.isArray(details.items)) {\n      console.log(\"No items array found in details:\", details)\n      return container\n    }\n\n    // Process items only once - find the first table-like structure\n    let tableRendered = false\n\n    for (const item of details.items) {\n      if (item.type === \"checklist\") {\n        const checklist = this.renderChecklist(item)\n        container.appendChild(checklist)\n      } else if (item.type === \"node\") {\n        const nodeInfo = this.renderNodeInfo(item)\n        container.appendChild(nodeInfo)\n      } else if (item.items && Array.isArray(item.items) && !tableRendered) {\n        // Only render the first table structure found\n        const table = this.renderDetailsTable({ items: item.items, headings: item.headings }, insight)\n        container.appendChild(table)\n        tableRendered = true\n      }\n    }\n\n    // Fallback: if no table was rendered, try extracting from details\n    if (!tableRendered && container.children.length === 0) {\n      const tableData = this.extractTableData(details)\n      if (tableData && tableData.items && tableData.items.length > 0) {\n        const table = this.renderDetailsTable(tableData, insight)\n        container.appendChild(table)\n      }\n    }\n\n    return container\n  }\n\n  /**\n   * Render checklist items with checkmarks and X marks\n   */\n  renderChecklist(checklistItem) {\n    const checklist = document.createElement(\"div\")\n    checklist.className = \"insight-checklist\"\n\n    if (!checklistItem.items || typeof checklistItem.items !== \"object\") {\n      return checklist\n    }\n\n    // Convert checklist items object to array for rendering\n    Object.entries(checklistItem.items).forEach(([key, item]) => {\n      const checklistRow = document.createElement(\"div\")\n      checklistRow.className = \"checklist-item\"\n\n      // Create icon based on value\n      const icon = document.createElement(\"div\")\n      icon.className = `checklist-icon ${item.value ? \"checklist-pass\" : \"checklist-fail\"}`\n\n      if (item.value) {\n        icon.innerHTML = `\n          <svg viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\">\n            <polyline points=\"20,6 9,17 4,12\"></polyline>\n          </svg>\n        `\n      } else {\n        icon.innerHTML = `\n          <svg viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\">\n            <line x1=\"18\" y1=\"6\" x2=\"6\" y2=\"18\"></line>\n            <line x1=\"6\" y1=\"6\" x2=\"18\" y2=\"18\"></line>\n          </svg>\n        `\n      }\n\n      // Create label\n      const label = document.createElement(\"div\")\n      label.className = \"checklist-label\"\n      label.textContent = item.label || key\n\n      checklistRow.appendChild(icon)\n      checklistRow.appendChild(label)\n      checklist.appendChild(checklistRow)\n    })\n\n    return checklist\n  }\n\n  /**\n   * Render node information\n   */\n  renderNodeInfo(nodeItem) {\n    const nodeContainer = document.createElement(\"div\")\n    nodeContainer.className = \"insight-node-info\"\n\n    if (nodeItem.snippet) {\n      const snippet = document.createElement(\"div\")\n      snippet.className = \"node-snippet\"\n      snippet.textContent = nodeItem.snippet\n      nodeContainer.appendChild(snippet)\n    }\n\n    if (nodeItem.selector) {\n      const selector = document.createElement(\"div\")\n      selector.className = \"node-selector\"\n      selector.textContent = `Selector: ${nodeItem.selector}`\n      nodeContainer.appendChild(selector)\n    }\n\n    if (nodeItem.nodeLabel) {\n      const label = document.createElement(\"div\")\n      label.className = \"node-label\"\n      label.textContent = nodeItem.nodeLabel\n      nodeContainer.appendChild(label)\n    }\n\n    return nodeContainer\n  }\n\n  /**\n   * Render network dependency tree - Fixed to handle PSI network tree structure\n   */\n  renderNetworkTree(details) {\n    console.log(\"Rendering network tree with details:\", details)\n\n    const treeContainer = document.createElement(\"div\")\n    treeContainer.className = \"network-tree-container\"\n\n    // Add maximum critical path latency if available\n    if (details.longestChain && details.longestChain.duration) {\n      const latencyInfo = document.createElement(\"div\")\n      latencyInfo.className = \"network-latency-info\"\n      latencyInfo.textContent = `Maximum critical path latency: ${details.longestChain.duration} ms`\n      treeContainer.appendChild(latencyInfo)\n    }\n\n    // Add initial navigation header\n    const navHeader = document.createElement(\"div\")\n    navHeader.className = \"network-nav-header\"\n    navHeader.textContent = \"Initial Navigation\"\n    treeContainer.appendChild(navHeader)\n\n    // Handle different possible structures for network tree data\n    let chainsData = null\n\n    // Check for chains in details directly\n    if (details.chains) {\n      chainsData = details.chains\n      console.log(\"Found chains in details.chains:\", chainsData)\n    }\n    // Check for chains in items array\n    else if (details.items && Array.isArray(details.items)) {\n      // Look for chains in the items array\n      for (const item of details.items) {\n        if (item.chains) {\n          chainsData = item.chains\n          console.log(\"Found chains in details.items[].chains:\", chainsData)\n          break\n        }\n        // Sometimes the entire item is the chain data\n        if (item.url && (item.children || item.transferSize)) {\n          // Convert single item to chains format\n          chainsData = { 0: item }\n          console.log(\"Converted single item to chains format:\", chainsData)\n          break\n        }\n      }\n\n      // If no chains found but we have items, try to render as a simple list\n      if (!chainsData && details.items.length > 0) {\n        console.log(\"No chains found, rendering items as simple list\")\n        const simpleList = this.renderNetworkSimpleList(details.items)\n        treeContainer.appendChild(simpleList)\n        return treeContainer\n      }\n    }\n\n    // Render the dependency chains if we found them\n    if (chainsData && typeof chainsData === \"object\") {\n      const chainsContainer = document.createElement(\"div\")\n      chainsContainer.className = \"network-chains\"\n\n      Object.entries(chainsData).forEach(([chainId, chain]) => {\n        console.log(`Rendering chain ${chainId}:`, chain)\n        const chainElement = this.renderNetworkChain(chain, 0)\n        chainsContainer.appendChild(chainElement)\n      })\n\n      treeContainer.appendChild(chainsContainer)\n    } else {\n      console.log(\"No valid chains data found, showing debug info\")\n      // Show debug information\n      const debugInfo = document.createElement(\"div\")\n      debugInfo.className = \"network-debug\"\n      debugInfo.innerHTML = `\n        <div>Network tree structure not recognized:</div>\n        <pre style=\"font-size: 8px; max-height: 200px; overflow: auto;\">${JSON.stringify(details, null, 2)}</pre>\n      `\n      treeContainer.appendChild(debugInfo)\n    }\n\n    return treeContainer\n  }\n\n  /**\n   * Render network items as a simple list when chain structure is not available\n   */\n  renderNetworkSimpleList(items) {\n    const listContainer = document.createElement(\"div\")\n    listContainer.className = \"network-simple-list\"\n\n    items.forEach((item, index) => {\n      const itemElement = document.createElement(\"div\")\n      itemElement.className = \"network-list-item\"\n\n      // Extract URL and basic info\n      const url = item.url || item.href || \"Unknown URL\"\n      const filename = this.extractFilename(url)\n      const domain = this.extractDomain(url)\n\n      // Create display\n      const urlDisplay = document.createElement(\"div\")\n      urlDisplay.className = \"network-url-display\"\n      urlDisplay.textContent = filename\n\n      if (domain && !domain.includes(window.location.hostname)) {\n        const domainSpan = document.createElement(\"span\")\n        domainSpan.className = \"network-domain\"\n        domainSpan.textContent = ` (${domain})`\n        urlDisplay.appendChild(domainSpan)\n      }\n\n      // Add timing/size info if available\n      const metaInfo = document.createElement(\"div\")\n      metaInfo.className = \"network-meta\"\n\n      const parts = []\n      if (item.transferSize) parts.push(this.formatBytes(item.transferSize))\n      if (item.duration) parts.push(`${item.duration}ms`)\n      if (item.startTime) parts.push(`@${item.startTime}ms`)\n\n      if (parts.length > 0) {\n        metaInfo.textContent = parts.join(\", \")\n      }\n\n      itemElement.appendChild(urlDisplay)\n      if (metaInfo.textContent) {\n        itemElement.appendChild(metaInfo)\n      }\n\n      listContainer.appendChild(itemElement)\n    })\n\n    return listContainer\n  }\n\n  /**\n   * Render individual network chain with proper indentation\n   */\n  renderNetworkChain(chain, depth) {\n    if (!chain || typeof chain !== \"object\") {\n      console.log(\"Invalid chain data:\", chain)\n      return document.createElement(\"div\")\n    }\n\n    const chainElement = document.createElement(\"div\")\n    chainElement.className = `network-chain-item depth-${depth}`\n\n    // Create the main item\n    const itemElement = document.createElement(\"div\")\n    itemElement.className = \"network-item\"\n\n    // Add tree connector\n    const connector = document.createElement(\"div\")\n    connector.className = \"tree-connector\"\n    connector.style.marginLeft = `${depth * 20}px`\n\n    // Add connector lines based on depth\n    if (depth > 0) {\n      connector.innerHTML = \"└─ \"\n    }\n\n    // Extract filename and domain\n    const url = chain.url || chain.href || \"Unknown\"\n    const filename = this.extractFilename(url)\n    const domain = this.extractDomain(url)\n\n    // Create URL display\n    const urlDisplay = document.createElement(\"span\")\n    urlDisplay.className = \"network-url\"\n\n    // Color code by domain\n    if (domain && domain.includes(\"mediavine.com\")) {\n      urlDisplay.classList.add(\"mediavine-domain\")\n    } else if (domain && domain.includes(\"googlesyndication.com\")) {\n      urlDisplay.classList.add(\"third-party\")\n    } else {\n      urlDisplay.classList.add(\"main-domain\")\n    }\n\n    // Truncate long filenames\n    const displayName = filename.length > 50 ? `...${filename.slice(-47)}` : filename\n    urlDisplay.textContent = displayName\n\n    // Add domain in parentheses if different from main\n    if (domain && !domain.includes(window.location.hostname)) {\n      const domainSpan = document.createElement(\"span\")\n      domainSpan.className = \"network-domain\"\n      domainSpan.textContent = ` (${domain})`\n      urlDisplay.appendChild(domainSpan)\n    }\n\n    // Add timing and size info\n    const metaInfo = document.createElement(\"span\")\n    metaInfo.className = \"network-meta\"\n\n    const timing = chain.navStartToEndTime || chain.duration || chain.endTime\n    const timingText = timing ? `${Math.round(timing)} ms` : \"N/A\"\n    const size = chain.transferSize ? this.formatBytes(chain.transferSize) : \"N/A\"\n\n    metaInfo.innerHTML = ` - <span class=\"network-timing\">${timingText}</span>, <span class=\"network-size\">${size}</span>`\n\n    // Combine elements\n    itemElement.appendChild(connector)\n    itemElement.appendChild(urlDisplay)\n    itemElement.appendChild(metaInfo)\n\n    chainElement.appendChild(itemElement)\n\n    // Render children recursively\n    if (chain.children && typeof chain.children === \"object\" && Object.keys(chain.children).length > 0) {\n      Object.entries(chain.children).forEach(([childId, childChain]) => {\n        const childElement = this.renderNetworkChain(childChain, depth + 1)\n        chainElement.appendChild(childElement)\n      })\n    }\n\n    return chainElement\n  }\n\n  /**\n   * Extract table data from PSI nested structure\n   */\n  extractTableData(details) {\n    if (!details) return null\n\n    // Handle PSI nested structure: details.items[0].items contains the actual data\n    if (details.items && Array.isArray(details.items) && details.items.length > 0) {\n      // Look for the first item that has table-like structure\n      for (const item of details.items) {\n        if (item.items && Array.isArray(item.items) && item.items.length > 0) {\n          // Check if this looks like table data (not checklist or node)\n          if (item.type !== \"checklist\" && item.type !== \"node\") {\n            return {\n              headings: item.headings || details.headings || [],\n              items: item.items,\n            }\n          }\n        }\n      }\n\n      // Fallback: use details.items directly if no nested structure found\n      const nonSpecialItems = details.items.filter(\n        (item) => item.type !== \"checklist\" && item.type !== \"node\" && !item.items,\n      )\n\n      if (nonSpecialItems.length > 0) {\n        return {\n          headings: details.headings || [],\n          items: nonSpecialItems,\n        }\n      }\n    }\n\n    return null\n  }\n\n  /**\n   * Render details table for insight data\n   */\n  renderDetailsTable(details, insight) {\n    const table = document.createElement(\"table\")\n    table.className = \"insight-table\"\n\n    // Create header\n    const thead = document.createElement(\"thead\")\n    const headerRow = document.createElement(\"tr\")\n\n    if (details.headings && details.headings.length > 0) {\n      details.headings.forEach((heading, index) => {\n        const th = document.createElement(\"th\")\n        // Safely extract string value from heading object\n        let headingText = \"Column\"\n        if (typeof heading === \"string\") {\n          headingText = heading\n        } else if (heading && typeof heading === \"object\") {\n          headingText = heading.label || heading.text || heading.key || \"Column\"\n        }\n\n        th.textContent = this.formatHeading(headingText)\n\n        // Add alignment classes based on column type\n        if (index === 0) {\n          th.classList.add(\"url-column\")\n        } else if (this.isNumericColumn(headingText)) {\n          th.classList.add(\"numeric-column\")\n        }\n\n        headerRow.appendChild(th)\n      })\n    } else {\n      // Default headers for forced reflow data\n      const sourceHeader = document.createElement(\"th\")\n      sourceHeader.textContent = \"Source\"\n      sourceHeader.classList.add(\"url-column\")\n      const timeHeader = document.createElement(\"th\")\n      timeHeader.textContent = \"Reflow Time\"\n      timeHeader.classList.add(\"numeric-column\")\n      headerRow.appendChild(sourceHeader)\n      headerRow.appendChild(timeHeader)\n    }\n\n    thead.appendChild(headerRow)\n    table.appendChild(thead)\n\n    // Create body\n    const tbody = document.createElement(\"tbody\")\n    details.items.forEach((item) => {\n      const row = this.renderTableRow(item, details.headings, insight)\n      tbody.appendChild(row)\n    })\n\n    table.appendChild(tbody)\n    return table\n  }\n\n  /**\n   * Check if a column should be treated as numeric\n   */\n  isNumericColumn(headingText) {\n    const numericKeywords = [\"transfer\", \"savings\", \"time\", \"size\", \"bytes\", \"ms\", \"kb\", \"mb\", \"duration\", \"score\"]\n    return numericKeywords.some((keyword) => headingText.toLowerCase().includes(keyword))\n  }\n\n  /**\n   * Render table row for insight item\n   */\n  renderTableRow(item, headings, insight) {\n    const row = document.createElement(\"tr\")\n\n    if (headings && headings.length > 0) {\n      headings.forEach((heading, index) => {\n        const td = document.createElement(\"td\")\n        // Safely extract key from heading object\n        let key = \"unknown\"\n        if (typeof heading === \"string\") {\n          key = heading\n        } else if (heading && typeof heading === \"object\") {\n          key = heading.key || heading.text || heading.label || \"unknown\"\n        }\n        const value = item[key]\n\n        // Apply column-specific styling\n        if (index === 0) {\n          td.className = \"url-cell\"\n          td.innerHTML = this.formatUrlCell(value, item)\n        } else if (this.isNumericColumn(key)) {\n          td.className = \"numeric-cell\"\n          td.innerHTML = this.formatNumericValue(value, key)\n        } else if (key === \"source\") {\n          td.className = \"source-cell\"\n          td.innerHTML = this.formatSourceCell(value, item)\n        } else if (key === \"reflowTime\" || key === \"time\" || key.includes(\"time\") || key.includes(\"Time\")) {\n          td.className = \"metric-value\"\n          td.innerHTML = this.formatTimeValue(value)\n        } else {\n          td.textContent = this.formatCellValue(value)\n        }\n\n        row.appendChild(td)\n      })\n    } else {\n      // Default formatting for forced reflow data\n      const sourceCell = document.createElement(\"td\")\n      sourceCell.className = \"source-cell\"\n      sourceCell.innerHTML = this.formatSourceCell(item.source || item.url, item)\n\n      const timeCell = document.createElement(\"td\")\n      timeCell.className = \"metric-value\"\n      timeCell.innerHTML = this.formatTimeValue(item.reflowTime || item.time || item.duration)\n\n      row.appendChild(sourceCell)\n      row.appendChild(timeCell)\n    }\n\n    return row\n  }\n\n  /**\n   * Format URL cell with better wrapping and tooltip\n   */\n  formatUrlCell(url, item) {\n    if (!url) {\n      return '<div class=\"unattributed\">Unattributed</div>'\n    }\n\n    const urlString = typeof url === \"object\" ? url.url || url.href || String(url) : String(url)\n    const filename = this.extractFilename(urlString)\n    const domain = this.extractDomain(urlString)\n\n    return `\n  <div class=\"url-container compact\">\n    <div class=\"url-filename tooltip-trigger\" data-tooltip=\"${this.escapeHtml(urlString)}\">\n      ${this.escapeHtml(filename)}${domain ? ` (${this.escapeHtml(domain)})` : \"\"}\n    </div>\n  </div>\n`\n  }\n\n  /**\n   * Format numeric values with proper alignment and units\n   */\n  formatNumericValue(value, key) {\n    if (value === undefined || value === null) {\n      return '<span class=\"numeric-na\">—</span>'\n    }\n\n    const numValue = Number.parseFloat(value)\n    if (isNaN(numValue)) {\n      return '<span class=\"numeric-na\">—</span>'\n    }\n\n    // Format based on the type of numeric value\n    if (key.toLowerCase().includes(\"bytes\") || key.toLowerCase().includes(\"size\")) {\n      return `<span class=\"numeric-bytes\">${this.formatBytes(numValue)}</span>`\n    } else if (key.toLowerCase().includes(\"time\") || key.toLowerCase().includes(\"ms\")) {\n      return `<span class=\"numeric-time\">${numValue.toFixed(1)}ms</span>`\n    } else if (key.toLowerCase().includes(\"savings\")) {\n      return `<span class=\"numeric-savings\">${this.formatBytes(numValue)}</span>`\n    } else {\n      return `<span class=\"numeric-value\">${numValue.toLocaleString()}</span>`\n    }\n  }\n\n  /**\n   * Format bytes into human readable format\n   */\n  formatBytes(bytes) {\n    if (bytes === 0) return \"0 B\"\n    const k = 1024\n    const sizes = [\"B\", \"KB\", \"MB\", \"GB\"]\n    const i = Math.floor(Math.log(bytes) / Math.log(k))\n    return Number.parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + \" \" + sizes[i]\n  }\n\n  /**\n   * Extract domain from URL\n   */\n  extractDomain(url) {\n    if (!url) return \"\"\n\n    try {\n      const urlObj = new URL(url)\n      return urlObj.hostname\n    } catch (e) {\n      return \"\"\n    }\n  }\n\n  /**\n   * Format source cell with URL and location\n   */\n  formatSourceCell(source, item) {\n    if (!source) {\n      return '<div class=\"unattributed\">Unattributed</div>'\n    }\n\n    // Handle PSI source object structure\n    if (typeof source === \"object\" && source.url) {\n      const filename = this.extractFilename(source.url)\n      const domain = this.extractDomain(source.url)\n\n      let html = `\n  <div class=\"url-container compact\">\n    <div class=\"url-filename tooltip-trigger\" data-tooltip=\"${this.escapeHtml(source.url || source)}\">\n      ${this.escapeHtml(filename)}${domain ? ` (${this.escapeHtml(domain)})` : \"\"}\n    </div>\n  </div>\n`\n\n      if (source.line !== undefined || source.column !== undefined) {\n        const line = source.line || 0\n        const column = source.column || 0\n        html += `<div class=\"source-location\">Line ${line}, Column ${column}</div>`\n      }\n\n      return html\n    }\n\n    // Handle string source\n    if (typeof source === \"string\") {\n      const filename = this.extractFilename(source)\n      const domain = this.extractDomain(source)\n\n      let html = `\n  <div class=\"url-container compact\">\n    <div class=\"url-filename tooltip-trigger\" data-tooltip=\"${this.escapeHtml(source.url || source)}\">\n      ${this.escapeHtml(filename)}${domain ? ` (${this.escapeHtml(domain)})` : \"\"}\n    </div>\n  </div>\n`\n\n      if (item.line !== undefined || item.column !== undefined) {\n        const line = item.line || 0\n        const column = item.column || 0\n        html += `<div class=\"source-location\">Line ${line}, Column ${column}</div>`\n      }\n\n      return html\n    }\n\n    return '<div class=\"unattributed\">Unattributed</div>'\n  }\n\n  /**\n   * Extract filename from URL for cleaner display\n   */\n  extractFilename(url) {\n    if (!url) return \"Unknown\"\n\n    try {\n      const urlObj = new URL(url)\n      const pathname = urlObj.pathname\n      const filename = pathname.split(\"/\").pop() || pathname\n      return filename || \"Unknown\"\n    } catch (e) {\n      // Handle relative URLs or malformed URLs\n      const parts = url.split(\"/\")\n      return parts[parts.length - 1] || url\n    }\n  }\n\n  /**\n   * Format time value with appropriate styling\n   */\n  formatTimeValue(time) {\n    if (time === undefined || time === null) {\n      return '<span class=\"reflow-time low\">N/A</span>'\n    }\n\n    const numTime = Number.parseFloat(time)\n    if (isNaN(numTime)) {\n      return '<span class=\"reflow-time low\">N/A</span>'\n    }\n\n    let className = \"low\"\n\n    if (numTime > 50) {\n      className = \"high\"\n    } else if (numTime > 16) {\n      className = \"medium\"\n    }\n\n    return `<span class=\"reflow-time ${className}\">${numTime.toFixed(2)}ms</span>`\n  }\n\n  /**\n   * Format cell value\n   */\n  formatCellValue(value) {\n    if (value === undefined || value === null) {\n      return \"N/A\"\n    }\n\n    if (typeof value === \"object\") {\n      return JSON.stringify(value)\n    }\n\n    return String(value)\n  }\n\n  /**\n   * Format insight title\n   */\n  formatInsightTitle(title) {\n    if (!title) return \"Performance Insight\"\n\n    // Convert kebab-case to title case\n    return title.replace(/-/g, \" \").replace(/\\b\\w/g, (l) => l.toUpperCase())\n  }\n\n  /**\n   * Format table heading\n   */\n  formatHeading(heading) {\n    // Ensure we have a string\n    if (!heading) {\n      return \"Column\"\n    }\n\n    if (typeof heading !== \"string\") {\n      return String(heading)\n    }\n\n    return heading\n      .replace(/([A-Z])/g, \" $1\")\n      .replace(/^./, (str) => str.toUpperCase())\n      .trim()\n  }\n\n  /**\n   * Toggle insight expansion\n   */\n  toggleInsight(item, index) {\n    const header = item.querySelector(\".insight-header\")\n    const content = item.querySelector(\".insight-content\")\n    const expandIcon = header.querySelector(\".insight-expand-icon\")\n\n    const isExpanded = item.classList.contains(\"expanded\")\n\n    if (isExpanded) {\n      item.classList.remove(\"expanded\")\n      header.classList.remove(\"expanded\")\n      header.setAttribute(\"aria-expanded\", \"false\")\n      this.expandedInsights.delete(index)\n    } else {\n      item.classList.add(\"expanded\")\n      header.classList.add(\"expanded\")\n      header.setAttribute(\"aria-expanded\", \"true\")\n      this.expandedInsights.add(index)\n\n      // Reinitialize tooltips for newly expanded content\n      setTimeout(() => this.initializeTooltips(), 100)\n    }\n  }\n\n  /**\n   * Render empty state\n   */\n  renderEmptyState(container) {\n    const emptyState = document.createElement(\"div\")\n    emptyState.className = \"psi-insights-empty\"\n    emptyState.innerHTML = `\n            <p>No performance insights available</p>\n            <small>Run a PageSpeed Insights analysis to see detailed performance recommendations</small>\n        `\n    container.appendChild(emptyState)\n  }\n\n  /**\n   * Render error state\n   */\n  renderError(container, error) {\n    const errorState = document.createElement(\"div\")\n    errorState.className = \"psi-insights-error\"\n    errorState.innerHTML = `\n            <p>Failed to load insights</p>\n            <small>${this.escapeHtml(error.message || \"Unknown error occurred\")}</small>\n        `\n    container.appendChild(errorState)\n  }\n\n  /**\n   * Render loading state\n   */\n  renderLoading(container) {\n    const loadingState = document.createElement(\"div\")\n    loadingState.className = \"psi-insights-loading\"\n    loadingState.textContent = \"Loading insights...\"\n    container.appendChild(loadingState)\n  }\n\n  /**\n   * Escape HTML to prevent XSS\n   */\n  escapeHtml(text) {\n    if (typeof text !== \"string\") return \"\"\n    const div = document.createElement(\"div\")\n    div.textContent = text\n    return div.innerHTML\n  }\n\n  processMarkdown(text) {\n    if (!text) return \"\"\n\n    // Convert markdown links [text](url) to HTML links\n    return text.replace(/\\[([^\\]]+)\\]$$([^)]+)$$/g, '<a href=\"$2\" class=\"insight-link\" target=\"_blank\">$1</a>')\n  }\n\n  getFilenameFromUrl(url) {\n    try {\n      const urlObj = new URL(url)\n      const pathname = urlObj.pathname\n      const filename = pathname.split(\"/\").pop()\n      return filename || urlObj.hostname\n    } catch {\n      return url\n    }\n  }\n\n  destroy() {\n    if (this.tooltipElement) {\n      this.tooltipElement.remove()\n    }\n  }\n}\n\n// Export singleton instance\nexport const insightsRenderer = new InsightsRenderer()\n","/**\n * Module for handling header display in the popup\n */\n\nimport { getHeaderColor, getContrastColor } from \"../../utils/formatters.js\"\n\n/**\n * Updates the header display with analysis results\n * @param {Object} headersData - Headers data object\n */\nexport function updateHeaderDisplay(headersData) {\n  const headerInfoContainer = document.getElementById(\"headerInfo\")\n\n  // Add margin if no button is present\n  if (headerInfoContainer) headerInfoContainer.style.marginTop = \"0px\"\n\n  const existingEmptyMsg = headerInfoContainer.querySelector(\".empty-state-message\")\n  if (existingEmptyMsg) existingEmptyMsg.remove()\n\n  const allHeaderValueSpans = headerInfoContainer.querySelectorAll(\".header-list li .header-value\")\n\n  // Reset all headers to default state\n  resetHeaderValues(allHeaderValueSpans)\n\n  if (headersData && Object.keys(headersData).length > 0) {\n    const hasAnyData = updateHeaderValues(allHeaderValueSpans, headersData)\n\n    if (!hasAnyData) {\n      showEmptyHeaderMessage(headerInfoContainer, \"All header information is N/A or analysis pending.\")\n    }\n  } else {\n    showEmptyHeaderMessage(headerInfoContainer, \"No header information available or analysis pending.\")\n  }\n\n  headerInfoContainer.style.display = \"block\"\n}\n\n/**\n * Resets all header values to default state\n * @param {NodeList} headerValueSpans - All header value span elements\n */\nfunction resetHeaderValues(headerValueSpans) {\n  headerValueSpans.forEach((spanElement) => {\n    spanElement.textContent = \"N/A\"\n    const defaultBgColor = getHeaderColor(\"\", \"N/A\")\n    spanElement.style.backgroundColor = defaultBgColor\n    spanElement.style.color = getContrastColor(defaultBgColor)\n    spanElement.style.display = \"inline-block\"\n    if (spanElement.id === \"adprovider\") {\n      spanElement.setAttribute(\"data-provider\", \"N/A\")\n    }\n  })\n}\n\n/**\n * Updates header values with actual data\n * @param {NodeList} headerValueSpans - All header value span elements\n * @param {Object} headersData - Headers data object\n * @returns {boolean} True if any data was found\n */\nfunction updateHeaderValues(headerValueSpans, headersData) {\n  let hasAnyData = false\n\n  headerValueSpans.forEach((spanElement) => {\n    const elementId = spanElement.id\n    let headerKeyToLookup = elementId\n\n    const keyMapping = {\n      perfmattersrucss: \"perfmattersRUCSS\",\n      perfmattersdelayjs: \"perfmattersDelayJS\",\n      adprovider: \"adProvider\",\n    }\n\n    if (keyMapping[elementId]) {\n      headerKeyToLookup = keyMapping[elementId]\n    }\n\n    const value = headersData[headerKeyToLookup]\n\n    if (value !== undefined && value !== null && String(value).trim() !== \"\") {\n      spanElement.textContent = String(value)\n      hasAnyData = true\n    } else {\n      spanElement.textContent = \"N/A\"\n    }\n\n    const bgColor = getHeaderColor(headerKeyToLookup, value)\n    spanElement.style.backgroundColor = bgColor\n    spanElement.style.color = getContrastColor(bgColor)\n\n    if (elementId === \"adprovider\") {\n      spanElement.setAttribute(\"data-provider\", value && String(value).trim() !== \"\" ? String(value) : \"N/A\")\n    }\n  })\n\n  return hasAnyData\n}\n\n/**\n * Shows an empty state message\n * @param {HTMLElement} container - The container element\n * @param {string} message - The message to show\n */\nfunction showEmptyHeaderMessage(container, message) {\n  if (!container.querySelector(\".empty-state-message\")) {\n    const p = document.createElement(\"p\")\n    p.textContent = message\n    p.className = \"empty-state-message\"\n    container.appendChild(p)\n  }\n}\n","/**\n * Module for handling image display in the popup\n */\n\n// Import the simplified helpers\nimport { sendMessageToContentScript, showElementFeedback } from \"../../utils/tab-helpers.js\"\n\n/**\n * Updates the image display with analysis results\n * @param {Array} images - Array of image data\n */\nexport function updateImageDisplay(images) {\n  const imageInfo = document.getElementById(\"imageInfo\")\n  const imageCountEl = document.getElementById(\"imageCount\")\n  const imageList = document.getElementById(\"imageList\")\n\n  // Add margin if no button is present\n  if (imageInfo) imageInfo.style.marginTop = \"0px\"\n\n  const totalImages = images.length\n  imageCountEl.textContent = `Found ${totalImages} preloaded image${totalImages !== 1 ? \"s\" : \"\"}`\n  imageList.innerHTML = \"\"\n\n  if (totalImages === 0) {\n    imageInfo.style.display = \"block\"\n    const p = document.createElement(\"p\")\n    p.textContent = \"No preloaded images detected on this page.\"\n    p.className = \"empty-state-message\"\n    imageList.appendChild(p)\n    return\n  }\n\n  images.forEach((image) => {\n    const li = createImageListItem(image)\n    imageList.appendChild(li)\n  })\n\n  imageInfo.style.display = \"block\"\n}\n\n/**\n * Creates a list item for an image\n * @param {Object} image - Image data object\n * @returns {HTMLElement} The created list item\n */\nfunction createImageListItem(image) {\n  const li = document.createElement(\"li\")\n  li.className = \"image-list-item\"\n  li.style.cursor = \"pointer\"\n  li.title = \"Click to highlight this image on the page\"\n\n  // Add click handler to highlight image on page\n  li.addEventListener(\"click\", async () => {\n    // Get the target tab ID (handles detached mode)\n    const targetTabId = await window.getTargetTabId()\n\n    if (!targetTabId) {\n      console.log(\"No target tab available for image highlighting\")\n      showElementFeedback(li, \"error\")\n      return\n    }\n\n    // Show immediate feedback\n    showElementFeedback(li, \"success\")\n\n    const response = await sendMessageToContentScript(targetTabId, {\n      action: \"highlightImage\",\n      imageUrl: image.url,\n    })\n\n    if (!response) {\n      console.log(\"Failed to highlight image\")\n    }\n  })\n\n  const imgContainer = createImageContainer(image)\n  const infoContainer = createImageInfoContainer(image)\n\n  li.appendChild(imgContainer)\n  li.appendChild(infoContainer)\n\n  return li\n}\n\n/**\n * Creates the image container with thumbnail\n * @param {Object} image - Image data object\n * @returns {HTMLElement} The image container\n */\nfunction createImageContainer(image) {\n  const imgContainer = document.createElement(\"div\")\n  imgContainer.className = \"img-container\"\n\n  const img = document.createElement(\"img\")\n  img.alt = image.url.substring(image.url.lastIndexOf(\"/\") + 1)\n  img.crossOrigin = \"anonymous\"\n\n  const fallbackIcon = document.createElement(\"div\")\n  fallbackIcon.className = \"fallback-icon\"\n  fallbackIcon.innerHTML =\n    '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><rect x=\"3\" y=\"3\" width=\"18\" height=\"18\" rx=\"2\" ry=\"2\"/><circle cx=\"8.5\" cy=\"8.5\" r=\"1.5\"/><polyline points=\"21 15 16 10 5 21\"/></svg>'\n\n  img.onload = () => {\n    img.style.display = \"block\"\n    fallbackIcon.style.display = \"none\"\n  }\n  img.onerror = () => {\n    img.style.display = \"none\"\n    fallbackIcon.style.display = \"flex\"\n  }\n  img.src = image.url\n\n  imgContainer.appendChild(img)\n  imgContainer.appendChild(fallbackIcon)\n\n  return imgContainer\n}\n\n/**\n * Creates the image info container with details and status indicators\n * @param {Object} image - Image data object\n * @returns {HTMLElement} The info container\n */\nfunction createImageInfoContainer(image) {\n  const infoContainer = document.createElement(\"div\")\n  infoContainer.className = \"info-container\"\n\n  const urlSpan = document.createElement(\"span\")\n  urlSpan.className = \"url\"\n  urlSpan.textContent = image.url\n  infoContainer.appendChild(urlSpan)\n\n  const detailsSpan = createImageDetailsSpan(image)\n  infoContainer.appendChild(detailsSpan)\n\n  const statusContainer = createImageStatusContainer(image)\n  infoContainer.appendChild(statusContainer)\n\n  return infoContainer\n}\n\n/**\n * Creates the details span for an image\n * @param {Object} image - Image data object\n * @returns {HTMLElement} The details span\n */\nfunction createImageDetailsSpan(image) {\n  const detailsSpan = document.createElement(\"span\")\n  detailsSpan.className = \"details\"\n  const details = []\n\n  // Add enhanced details\n  if (image.aboveFold !== undefined) {\n    details.push(image.aboveFold ? \"Above fold\" : \"Below fold\")\n  }\n  if (image.format) details.push(`Format: ${image.format}`)\n  if (image.fileSizeFormatted) details.push(`Size: ${image.fileSizeFormatted}`)\n  if (image.dimensions?.displayed) {\n    details.push(`${image.dimensions.displayed.width}×${image.dimensions.displayed.height}px`)\n  }\n  if (image.type) details.push(`Type: ${image.type}`)\n  if (image.loading && image.loading !== \"auto\") details.push(`Loading: ${image.loading}`)\n\n  detailsSpan.textContent = details.length > 0 ? details.join(\" | \") : \"No additional details\"\n  return detailsSpan\n}\n\n/**\n * Creates the status container with status indicators\n * @param {Object} image - Image data object\n * @returns {HTMLElement} The status container\n */\nfunction createImageStatusContainer(image) {\n  const statusContainer = document.createElement(\"div\")\n  statusContainer.className = \"status-container\"\n\n  // Early Hints indicator (highest priority)\n  if (image.earlyHints) {\n    const earlyHintsSticker = document.createElement(\"span\")\n    earlyHintsSticker.textContent = \"EARLY HINTS\"\n    earlyHintsSticker.className = \"status-sticker early-hints\"\n    statusContainer.appendChild(earlyHintsSticker)\n  }\n\n  // Critical Path indicator (most important)\n  if (image.isCritical !== undefined) {\n    const criticalSticker = document.createElement(\"span\")\n    criticalSticker.textContent = image.isCritical ? \"CRITICAL PATH\" : \"NON-CRITICAL\"\n    criticalSticker.className = image.isCritical ? \"status-sticker critical-path\" : \"status-sticker non-critical\"\n    statusContainer.appendChild(criticalSticker)\n  }\n\n  // Above/Below fold indicator\n  if (image.aboveFold !== undefined) {\n    const foldSticker = document.createElement(\"span\")\n    foldSticker.textContent = image.aboveFold ? \"ABOVE FOLD\" : \"BELOW FOLD\"\n    foldSticker.className = image.aboveFold ? \"status-sticker above-fold\" : \"status-sticker below-fold\"\n    statusContainer.appendChild(foldSticker)\n  }\n\n  return statusContainer\n}\n","/**\n * Formats a file size in bytes to a human-readable string\n * @param {number} bytes - The size in bytes\n * @returns {string} Formatted size string (e.g., \"1.5 KB\")\n */\nexport function formatFileSize(bytes) {\n  if (!bytes) return \"Unknown\"\n  if (bytes < 1024) return bytes + \" B\"\n  if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + \" KB\"\n  return (bytes / (1024 * 1024)).toFixed(1) + \" MB\"\n}\n\n/**\n * Gets the appropriate background color for a header value\n * @param {string} headerKey - The header key\n * @param {string} value - The header value\n * @returns {string} CSS color value\n */\nexport function getHeaderColor(headerKey, value) {\n  const lowerValue = typeof value === \"string\" ? value.toLowerCase().trim() : \"n/a\"\n  const saneKey = typeof headerKey === \"string\" ? headerKey.toLowerCase().replace(/-/g, \"\") : \"\"\n\n  switch (saneKey) {\n    case \"xbigscootscachestatus\":\n    case \"cfcachestatus\":\n      return getCacheStatusColor(lowerValue)\n    case \"xbigscootscacheplan\":\n      return getCachePlanColor(lowerValue)\n    case \"xbigscootscachemode\":\n    case \"xbigscootscachemodeo2o\":\n      return getEnabledDisabledColor(lowerValue === \"enabled\" || lowerValue === \"true\", lowerValue === \"n/a\")\n    case \"xezoiccdn\":\n      if (lowerValue === \"hit\") return \"var(--success-bg-strong)\"\n      if (lowerValue === \"n/a\" || lowerValue === \"\") return \"var(--neutral-bg)\"\n      return \"var(--error-bg-strong)\"\n    case \"xnpcfe\":\n      if (lowerValue && lowerValue !== \"n/a\" && lowerValue !== \"disabled\" && lowerValue !== \"inactive\")\n        return \"var(--success-bg-strong)\"\n      if (lowerValue === \"n/a\" || lowerValue === \"\") return \"var(--neutral-bg)\"\n      return \"var(--error-bg-strong)\"\n    case \"perfmattersrucss\":\n    case \"perfmattersdelayjs\":\n      return getEnabledDisabledColor(lowerValue === \"enabled\", lowerValue === \"n/a\")\n    case \"xhostedby\":\n      return lowerValue && lowerValue !== \"n/a\" && lowerValue.trim() !== \"\"\n        ? \"var(--info-bg-strong)\"\n        : \"var(--neutral-bg)\"\n    case \"contentencoding\":\n      return lowerValue && lowerValue !== \"n/a\" && lowerValue.trim() !== \"\"\n        ? \"var(--info-bg-strong)\"\n        : \"var(--neutral-bg)\"\n    case \"gtm\":\n    case \"ua\":\n    case \"ga4\":\n    case \"ga\":\n      return lowerValue && lowerValue !== \"n/a\" && lowerValue.trim() !== \"\"\n        ? \"var(--warning-bg-strong)\"\n        : \"var(--neutral-bg)\"\n    case \"adprovider\":\n      if (lowerValue === \"none detected\" || lowerValue === \"n/a\" || lowerValue === \"\") return \"var(--neutral-bg)\"\n      return \"var(--success-bg-strong)\"\n    default:\n      return \"var(--neutral-bg)\"\n  }\n}\n\n/**\n * Gets the color for a cache status value\n * @param {string} status - The cache status\n * @returns {string} CSS color value\n */\nfunction getCacheStatusColor(status) {\n  switch (status) {\n    case \"hit\":\n      return \"var(--success-bg-strong)\"\n    case \"miss\":\n      return \"var(--error-bg-strong)\"\n    case \"bypass\":\n      return \"var(--warning-bg-strong)\"\n    case \"dynamic\":\n      return \"var(--info-bg-strong)\"\n    default:\n      return \"var(--neutral-bg)\"\n  }\n}\n\n/**\n * Gets the color for a cache plan value\n * @param {string} plan - The cache plan\n * @returns {string} CSS color value\n */\nfunction getCachePlanColor(plan) {\n  switch (plan) {\n    case \"standard\":\n      return \"var(--plan-standard-bg)\"\n    case \"performance+\":\n      return \"var(--plan-performance-plus-bg)\"\n    default:\n      return \"var(--neutral-bg)\"\n  }\n}\n\n/**\n * Gets the color for enabled/disabled status\n * @param {boolean} isEnabled - Whether the feature is enabled\n * @param {boolean} isNA - Whether the value is N/A\n * @returns {string} CSS color value\n */\nfunction getEnabledDisabledColor(isEnabled, isNA = false) {\n  if (isNA) return \"var(--neutral-bg)\"\n  return isEnabled ? \"var(--success-bg-strong)\" : \"var(--error-bg-strong)\"\n}\n\n/**\n * Gets the appropriate text color for a background color\n * @param {string} bgColorHexOrVar - The background color\n * @returns {string} CSS color value for text\n */\nexport function getContrastColor(bgColorHexOrVar) {\n  let hexColor = bgColorHexOrVar\n  if (hexColor.startsWith(\"var(--\")) {\n    const varName = hexColor.match(/--([a-zA-Z0-9-]+)/)[0]\n    hexColor = getComputedStyle(document.documentElement).getPropertyValue(varName).trim()\n  }\n\n  if (!hexColor || !hexColor.startsWith(\"#\")) return \"var(--text-primary)\"\n  hexColor = hexColor.slice(1)\n\n  let r, g, b\n  if (hexColor.length === 3) {\n    r = Number.parseInt(hexColor[0] + hexColor[0], 16)\n    g = Number.parseInt(hexColor[1] + hexColor[1], 16)\n    b = Number.parseInt(hexColor[2] + hexColor[2], 16)\n  } else if (hexColor.length === 6) {\n    r = Number.parseInt(hexColor.substr(0, 2), 16)\n    g = Number.parseInt(hexColor.substr(2, 2), 16)\n    b = Number.parseInt(hexColor.substr(4, 2), 16)\n  } else {\n    return \"var(--text-primary)\"\n  }\n  if (isNaN(r) || isNaN(g) || isNaN(b)) return \"var(--text-primary)\"\n\n  const yiq = (r * 299 + g * 587 + b * 114) / 1000\n\n  if (bgColorHexOrVar.includes(\"-strong\") || bgColorHexOrVar === \"var(--plan-performance-plus-bg)\") {\n    return \"#ffffff\"\n  }\n  if (bgColorHexOrVar === \"var(--plan-standard-bg)\") return \"var(--text-primary)\"\n\n  return yiq >= 145 ? \"var(--text-primary)\" : \"#ffffff\"\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * Main popup script for the BigScoots Performance Debugger extension - Enhanced PSI support\n */\n\nconsole.log(\"=== POPUP STARTING ===\")\nconsole.log(\"DOM readyState:\", document.readyState)\nconsole.log(\"Chrome API available:\", typeof window.chrome !== \"undefined\")\nconsole.log(\"Window location:\", window.location.href)\n\n// Import display modules\nimport { updateImageDisplay } from \"./displays/image-display.js\"\nimport { updateFontDisplay } from \"./displays/font-display.js\"\nimport { updateHeaderDisplay } from \"./displays/header-display.js\"\nimport {\n  updateInsightsDisplay,\n  updateCLSDisplay,\n  updateLCPDisplay,\n  updateINPDisplay,\n  updateTTFBDisplay,\n  updatePSICLSDisplay,\n  updatePSILCPDisplay,\n  updatePSIINPDisplay,\n  updatePSITTFBDisplay,\n  updatePSIStatus,\n  updatePSILabCLSDisplay,\n  updatePSILabLCPDisplay,\n  resetDataAvailability,\n  handleCompletePSIResults,\n} from \"./displays/insights-display.js\"\n\n// Import management modules\nimport { setupTabSwitching } from \"./tab-manager.js\"\nimport { setupToggleManagement } from \"./toggle-manager.js\"\nimport {\n  detachPopup,\n  attachPopup,\n  isDetachedWindow,\n  applyDetachedModeStyles,\n  updateWindowControlButton,\n} from \"./window-state-manager.js\"\n\n// Import the tab helpers\nimport { getTargetTabId, getOriginalTabIdFromUrl, verifyTabExists } from \"../utils/tab-helpers.js\"\n\nconsole.log(\"All modules imported successfully\")\n\n// Declare chrome variable\n\n/**\n * Tab configuration\n */\nconst TABS = [\n  { id: \"imageAnalyzerTab\", contentId: \"imageAnalyzerContent\" },\n  { id: \"fontAnalyzerTab\", contentId: \"fontAnalyzerContent\" },\n  { id: \"headerAnalyzerTab\", contentId: \"headerAnalyzerContent\" },\n  { id: \"insightsTab\", contentId: \"insightsContent\" },\n  { id: \"perfmattersDebugTab\", contentId: \"perfmattersDebugContent\" },\n]\n\nconsole.log(\"Testing tab elements...\")\nTABS.forEach((tab) => {\n  const tabEl = document.getElementById(tab.id)\n  const contentEl = document.getElementById(tab.contentId)\n  console.log(`Tab ${tab.id}:`, !!tabEl, \"Content:\", !!contentEl)\n})\n\n// Store for cached data to persist across refreshes\nlet cachedAnalysisData = null\nlet isDetachedMode = false\nlet boundTabId = null // The tab this detached window is bound to\nlet boundTabUrl = null // The URL of the bound tab\nlet pollingInterval = null\n\n/**\n * Sends a message to content script with retry logic and better error handling\n * @param {number} tabId - Tab ID to send message to\n * @param {Object} message - Message to send\n * @param {Function} callback - Callback function\n * @param {number} retries - Number of retries remaining\n */\nfunction sendMessageWithRetry(tabId, message, callback, retries = 3) {\n  console.log(`Sending message to tab ${tabId}:`, message.action, `(${retries} retries left)`)\n\n  chrome.tabs.sendMessage(tabId, message, (response) => {\n    if (chrome.runtime.lastError) {\n      const errorMsg = chrome.runtime.lastError.message\n      console.error(`Message to tab ${tabId} failed:`, errorMsg)\n\n      // Check if it's a \"receiving end does not exist\" error\n      if (errorMsg.includes(\"Receiving end does not exist\") && retries > 0) {\n        console.log(`Content script not ready, retrying in 1s... (${retries} retries left)`)\n        setTimeout(() => {\n          sendMessageWithRetry(tabId, message, callback, retries - 1)\n        }, 1000)\n        return\n      }\n\n      console.log(`Message failed after retries: ${errorMsg}`)\n      if (callback) callback(null)\n      return\n    }\n\n    console.log(`Message to tab ${tabId} successful, response:`, response)\n    if (callback) callback(response)\n  })\n}\n\n/**\n * Verifies content script is injected and ready\n * @param {number} tabId - Tab ID to check\n * @returns {Promise<boolean>} True if content script is ready\n */\nasync function verifyContentScriptReady(tabId) {\n  console.log(`Verifying content script readiness for tab ${tabId}`)\n\n  return new Promise((resolve) => {\n    chrome.tabs.sendMessage(tabId, { action: \"ping\" }, (response) => {\n      if (chrome.runtime.lastError) {\n        console.log(`Content script not ready for tab ${tabId}:`, chrome.runtime.lastError.message)\n        resolve(false)\n      } else {\n        console.log(`Content script is ready for tab ${tabId}`)\n        resolve(true)\n      }\n    })\n  })\n}\n\n/**\n * Gets the correct tab ID for messaging, handling detached mode\n * @returns {Promise<number|null>} Tab ID or null if not available\n */\nasync function getTargetTabIdForMessaging() {\n  // Use the improved getTargetTabId function that auto-detects mode\n  const tabId = await getTargetTabId()\n  console.log(\"Target tab ID for messaging:\", tabId)\n  return tabId\n}\n\n/**\n * Initializes detached mode binding\n */\nasync function initializeDetachedMode() {\n  console.log(\"Initializing detached mode...\")\n\n  // Get original tab ID from URL\n  const originalTabId = await getOriginalTabIdFromUrl()\n  console.log(\"Original tab ID from URL:\", originalTabId)\n\n  if (!originalTabId) {\n    console.error(\"No original tab ID found in detached mode\")\n    return false\n  }\n\n  // Verify the tab still exists\n  const tabExists = await verifyTabExists(originalTabId)\n  if (!tabExists) {\n    console.error(\"Original tab no longer exists:\", originalTabId)\n    return false\n  }\n\n  // Set the bound tab ID\n  boundTabId = originalTabId\n  console.log(\"Detached mode: successfully bound to tab\", boundTabId)\n\n  // Get and store the tab URL\n  try {\n    const response = await new Promise((resolve) => {\n      chrome.runtime.sendMessage({ action: \"getTabUrl\", tabId: boundTabId }, (response) => {\n        if (chrome.runtime.lastError) {\n          resolve({ success: false, error: chrome.runtime.lastError.message })\n        } else {\n          resolve(response)\n        }\n      })\n    })\n\n    if (response.success) {\n      boundTabUrl = response.url\n      console.log(\"Bound tab URL:\", boundTabUrl)\n      updateCurrentUrlDisplay(boundTabUrl)\n    }\n  } catch (error) {\n    console.error(\"Error getting bound tab URL:\", error)\n  }\n\n  return true\n}\n\n/**\n * Updates the current URL display in the header\n * @param {string} url - The URL to display\n */\nfunction updateCurrentUrlDisplay(url) {\n  console.log(\"Updating URL display:\", url)\n  const currentUrlElement = document.getElementById(\"currentUrl\")\n  const currentUrlValue = document.getElementById(\"currentUrlValue\")\n\n  if (currentUrlElement && currentUrlValue && url) {\n    // Clean up the URL for display\n    let displayUrl = url\n    try {\n      const urlObj = new URL(url)\n\n      // Get hostname and pathname\n      displayUrl = urlObj.hostname\n\n      // Add pathname but remove trailing slash\n      let pathname = urlObj.pathname\n      if (pathname !== \"/\" && pathname.endsWith(\"/\")) {\n        pathname = pathname.slice(0, -1)\n      }\n\n      // Only add pathname if it's not just \"/\"\n      if (pathname !== \"/\") {\n        displayUrl += pathname\n      }\n\n      // Add search params if present\n      if (urlObj.search) {\n        displayUrl += urlObj.search\n      }\n    } catch (error) {\n      // If URL parsing fails, use the original URL\n      // Still try to remove trailing slash\n      if (displayUrl.endsWith(\"/\") && displayUrl.length > 1) {\n        displayUrl = displayUrl.slice(0, -1)\n      }\n    }\n\n    currentUrlValue.textContent = displayUrl\n    currentUrlElement.classList.add(\"visible\")\n\n    // Store the bound tab URL in detached mode\n    if (isDetachedMode) {\n      boundTabUrl = url\n    }\n  } else if (currentUrlElement) {\n    currentUrlElement.classList.remove(\"visible\")\n  }\n}\n\n/**\n * Updates the popup with analysis results\n */\nasync function updatePopupWithResults() {\n  console.log(\"=== updatePopupWithResults called ===\")\n\n  try {\n    // Show loading state - but don't fail if this doesn't work\n    resetDataAvailability()\n  } catch (error) {\n    console.log(\"Could not update loading state:\", error)\n  }\n\n  // Reset data availability when updating popup (new page/refresh)\n  resetDataAvailability()\n\n  // Clear any existing data displays immediately\n  showEmptyStates()\n\n  try {\n    if (isDetachedMode) {\n      console.log(\"Running in detached mode\")\n\n      if (!boundTabId) {\n        console.error(\"No bound tab ID in detached mode\")\n        showEmptyStates()\n        updateCurrentUrlDisplay(\"Tab not available\")\n        return\n      }\n\n      // Get analysis results for the bound tab\n      console.log(\"Requesting analysis results for bound tab:\", boundTabId)\n      chrome.runtime.sendMessage({ action: \"getAnalysisResults\", tabId: boundTabId }, (data) => {\n        if (chrome.runtime.lastError) {\n          console.log(\"Error getting analysis results:\", chrome.runtime.lastError)\n          return\n        }\n\n        console.log(\"Analysis results received for bound tab:\", data)\n        if (data && Object.keys(data).length > 0) {\n          // Verify the data is for the current URL\n          if (boundTabUrl && data.url && data.url !== boundTabUrl) {\n            console.log(\"Analysis data is for different URL, ignoring:\", data.url, \"vs\", boundTabUrl)\n            showEmptyStates()\n            return\n          }\n\n          console.log(\"Displaying analysis data for bound tab\")\n          cachedAnalysisData = data\n          displayAnalysisData(data)\n\n          // Also update performance metrics from cached data\n          updatePerformanceMetricsFromData(data)\n        } else {\n          console.log(\"No analysis data available for bound tab, requesting fresh analysis\")\n          sendMessageWithRetry(boundTabId, { action: \"requestAnalysis\" }, (response) => {\n            if (response) {\n              console.log(\"Fresh analysis requested successfully\")\n            }\n          })\n        }\n      })\n\n      // Get stored PSI results for the bound tab\n      chrome.runtime.sendMessage({ action: \"getPSIResults\", tabId: boundTabId }, (psiData) => {\n        if (chrome.runtime.lastError) {\n          console.log(\"Error getting PSI results:\", chrome.runtime.lastError)\n          return\n        }\n\n        if (psiData && (psiData.allFieldData || psiData.allLabData)) {\n          // Verify PSI data is for current URL\n          if (boundTabUrl && psiData.url && psiData.url !== boundTabUrl) {\n            console.log(\"PSI data is for different URL, ignoring:\", psiData.url, \"vs\", boundTabUrl)\n            return\n          }\n\n          console.log(\"Restoring PSI data from storage:\", psiData)\n\n          // Restore field data\n          if (psiData.allFieldData) {\n            restorePSIFieldData(psiData.allFieldData)\n          }\n\n          // Restore lab data\n          if (psiData.allLabData) {\n            restorePSILabData(psiData.allLabData)\n          }\n\n          // NEW: Restore PSI insights data for detached mode\n          if (psiData.completeData) {\n            console.log(\"Restoring PSI insights from storage in detached mode\")\n            handleCompletePSIResults(psiData.completeData)\n          }\n\n          updatePSIStatus({ status: \"success\", message: \"PSI data restored\" })\n        }\n      })\n\n      // Get current performance data with better error handling\n      console.log(\"Requesting current performance data for bound tab:\", boundTabId)\n      sendMessageWithRetry(boundTabId, { action: \"getCurrentPerformanceData\" }, (response) => {\n        if (response) {\n          console.log(\"Fresh performance data received:\", response)\n          updatePerformanceMetrics(response)\n\n          // Merge with cached data if available\n          if (cachedAnalysisData) {\n            const mergedData = {\n              cls: response.cls || cachedAnalysisData.cls,\n              lcp: response.lcp || cachedAnalysisData.lcp,\n              inp: response.inp || cachedAnalysisData.inp,\n              additionalMetrics: response.additionalMetrics || cachedAnalysisData.additionalMetrics,\n            }\n            updatePerformanceMetrics(mergedData)\n          }\n        } else {\n          console.log(\"No fresh performance data, using cached data if available\")\n          if (cachedAnalysisData) {\n            updatePerformanceMetricsFromData(cachedAnalysisData)\n          }\n        }\n      })\n\n      return\n    }\n\n    // Attached mode logic\n    console.log(\"Running in attached mode\")\n    chrome.tabs.query({ active: true, currentWindow: true }, (activeTabs) => {\n      if (chrome.runtime.lastError || !activeTabs || activeTabs.length === 0) {\n        console.log(\"No active tabs found in attached mode\")\n        showEmptyStates()\n        return\n      }\n\n      const currentTabId = activeTabs[0].id\n      const currentTab = activeTabs[0]\n\n      console.log(\"Current tab ID:\", currentTabId, \"URL:\", currentTab.url)\n\n      // Update URL display\n      if (currentTab.url) {\n        updateCurrentUrlDisplay(currentTab.url)\n      }\n\n      // Query stored analysis results from background script\n      console.log(\"Requesting analysis results for tab:\", currentTabId)\n      chrome.runtime.sendMessage({ action: \"getAnalysisResults\", tabId: currentTabId }, (data) => {\n        if (chrome.runtime.lastError) {\n          console.log(\"Error getting analysis results:\", chrome.runtime.lastError)\n          return\n        }\n\n        console.log(\"Analysis results received for tab\", currentTabId, \":\", data)\n        if (data && Object.keys(data).length > 0) {\n          // Verify the data is for the current URL\n          if (currentTab.url && data.url && data.url !== currentTab.url) {\n            console.log(\"Analysis data is for different URL, ignoring:\", data.url, \"vs\", currentTab.url)\n            showEmptyStates()\n            // Request fresh analysis for current URL\n            chrome.tabs.sendMessage(currentTabId, { action: \"requestAnalysis\" }, (response) => {\n              if (chrome.runtime.lastError) {\n                console.log(\"Content script not ready yet:\", chrome.runtime.lastError)\n              }\n            })\n            return\n          }\n\n          console.log(\"Received analysis data for current tab - displaying now\")\n          cachedAnalysisData = data\n          displayAnalysisData(data)\n\n          // Also update performance metrics from cached data\n          updatePerformanceMetricsFromData(data)\n        } else {\n          console.log(\"No analysis data available, requesting fresh analysis\")\n          chrome.tabs.sendMessage(currentTabId, { action: \"requestAnalysis\" }, (response) => {\n            if (chrome.runtime.lastError) {\n              console.log(\"Content script not ready yet:\", chrome.runtime.lastError)\n            } else {\n              console.log(\"Fresh analysis requested\")\n            }\n          })\n        }\n      })\n\n      // Get stored PSI results for the current tab\n      chrome.runtime.sendMessage({ action: \"getPSIResults\", tabId: currentTabId }, (psiData) => {\n        if (chrome.runtime.lastError) {\n          console.log(\"Error getting PSI results:\", chrome.runtime.lastError)\n          return\n        }\n\n        if (psiData && (psiData.allFieldData || psiData.allLabData)) {\n          // Verify PSI data is for current URL\n          if (currentTab.url && psiData.url && psiData.url !== currentTab.url) {\n            console.log(\"PSI data is for different URL, ignoring:\", psiData.url, \"vs\", currentTab.url)\n            return\n          }\n\n          console.log(\"Restoring PSI data from storage:\", psiData)\n\n          // Restore field data\n          if (psiData.allFieldData) {\n            restorePSIFieldData(psiData.allFieldData)\n          }\n\n          // Restore lab data\n          if (psiData.allLabData) {\n            restorePSILabData(psiData.allLabData)\n          }\n\n          // NEW: Restore PSI insights data\n          if (psiData.completeData) {\n            console.log(\"Restoring PSI insights from storage\")\n            handleCompletePSIResults(psiData.completeData)\n          }\n\n          updatePSIStatus({ status: \"success\", message: \"PSI data restored\" })\n        }\n      })\n\n      // Query content script for current performance data\n      console.log(\"Requesting current performance data for tab:\", currentTabId)\n      chrome.tabs.sendMessage(currentTabId, { action: \"getCurrentPerformanceData\" }, (response) => {\n        if (chrome.runtime.lastError) {\n          console.log(\"Content script message error:\", chrome.runtime.lastError)\n\n          // If we have cached performance data, use it\n          if (cachedAnalysisData) {\n            console.log(\"Using cached performance data from analysis results\")\n            updatePerformanceMetricsFromData(cachedAnalysisData)\n          }\n          return\n        }\n\n        console.log(\"Performance data received:\", response)\n        if (response) {\n          updatePerformanceMetrics(response)\n        } else {\n          console.log(\"No fresh performance data, using cached data if available\")\n          if (cachedAnalysisData) {\n            updatePerformanceMetricsFromData(cachedAnalysisData)\n          }\n        }\n      })\n    })\n  } catch (error) {\n    console.error(\"Error updating popup with results:\", error)\n\n    // Update error state\n    try {\n      const { updateInsightsState } = await import(\"./displays/insights-display.js\")\n      updateInsightsState({\n        isLoading: false,\n        hasError: true,\n        errorMessage: \"Failed to load performance data. Please refresh the page and try again.\",\n      })\n    } catch (importError) {\n      console.error(\"Could not update error state:\", importError)\n    }\n\n    showEmptyStates()\n  }\n}\n\n/**\n * Updates performance metrics from cached analysis data\n * @param {Object} data - Cached analysis data\n */\nfunction updatePerformanceMetricsFromData(data) {\n  console.log(\"=== updatePerformanceMetricsFromData called ===\")\n  console.log(\"Using cached data for performance metrics:\", data)\n\n  if (data.cls) {\n    console.log(\"Updating CLS from cached data:\", data.cls)\n    updateCLSDisplay(data.cls)\n  }\n\n  if (data.lcp) {\n    console.log(\"Updating LCP from cached data:\", data.lcp)\n    updateLCPDisplay(data.lcp)\n  }\n\n  if (data.inp) {\n    console.log(\"Updating INP from cached data:\", data.inp)\n    updateINPDisplay(data.inp)\n  }\n\n  if (data.additionalMetrics) {\n    console.log(\"Updating TTFB from cached data:\", data.additionalMetrics)\n    updateTTFBDisplay(data.additionalMetrics)\n  }\n}\n\n/**\n * Restores PSI field data for all metrics\n * @param {Object} allFieldData - All PSI field data\n */\nfunction restorePSIFieldData(allFieldData) {\n  console.log(\"Restoring PSI field data:\", allFieldData)\n\n  if (allFieldData.cls) {\n    updatePSICLSDisplay(allFieldData.cls)\n  }\n\n  if (allFieldData.lcp) {\n    updatePSILCPDisplay(allFieldData.lcp)\n  }\n\n  if (allFieldData.inp) {\n    updatePSIINPDisplay(allFieldData.inp)\n  }\n\n  if (allFieldData.ttfb) {\n    updatePSITTFBDisplay(allFieldData.ttfb)\n  }\n}\n\n/**\n * Restores PSI lab data for all metrics\n * @param {Object} allLabData - All PSI lab data\n */\nfunction restorePSILabData(allLabData) {\n  console.log(\"Restoring PSI lab data:\", allLabData)\n\n  if (allLabData.labCLS) {\n    updatePSILabCLSDisplay(allLabData.labCLS)\n  }\n\n  if (allLabData.labLCP) {\n    updatePSILabLCPDisplay(allLabData.labLCP)\n  }\n}\n\n/**\n * Displays analysis data in the UI\n * @param {Object} data - Analysis data to display\n */\nfunction displayAnalysisData(data) {\n  console.log(\"=== displayAnalysisData called ===\")\n  console.log(\"Data received:\", data)\n\n  if (data.images) {\n    console.log(\"Updating images:\", data.images.length)\n    updateImageDisplay(data.images)\n  } else {\n    console.log(\"No images data, showing empty state\")\n    updateImageDisplay([])\n  }\n\n  if (data.fonts) {\n    console.log(\"Updating fonts:\", data.fonts.length)\n    updateFontDisplay(data.fonts)\n  } else {\n    console.log(\"No fonts data, showing empty state\")\n    updateFontDisplay([])\n  }\n\n  if (data.headers) {\n    console.log(\"Updating headers\")\n    updateHeaderDisplay(data.headers)\n  } else {\n    console.log(\"No headers data, showing empty state\")\n    updateHeaderDisplay({})\n  }\n\n  console.log(\"Updating insights display\")\n  updateInsightsDisplay(data)\n}\n\n/**\n * Updates performance metrics\n * @param {Object} response - Performance data response\n */\nfunction updatePerformanceMetrics(response) {\n  console.log(\"=== updatePerformanceMetrics called ===\")\n  console.log(\"Performance data:\", response)\n\n  if (response.cls) {\n    console.log(\"Updating CLS display with fresh data\")\n    updateCLSDisplay(response.cls)\n  }\n  if (response.lcp) {\n    console.log(\"Updating LCP display with fresh data\")\n    updateLCPDisplay(response.lcp)\n  }\n  if (response.inp) {\n    console.log(\"Updating INP display with fresh data\")\n    updateINPDisplay(response.inp)\n  }\n  if (response.additionalMetrics) {\n    console.log(\"Updating TTFB display with fresh data\")\n    updateTTFBDisplay(response.additionalMetrics)\n  }\n}\n\n/**\n * Shows empty states for all displays\n */\nfunction showEmptyStates() {\n  console.log(\"=== Setting empty states ===\")\n  updateImageDisplay([])\n  updateFontDisplay([])\n  updateHeaderDisplay({})\n  updateInsightsDisplay({})\n}\n\n/**\n * Sets up periodic polling for performance data\n */\nfunction setupPeriodicPolling() {\n  console.log(\"Setting up periodic polling\")\n\n  // Clear existing interval if any\n  if (pollingInterval) {\n    clearInterval(pollingInterval)\n  }\n\n  pollingInterval = setInterval(async () => {\n    if (!isDetachedMode) {\n      return\n    }\n\n    if (boundTabId) {\n      const tabExists = await verifyTabExists(boundTabId)\n      if (!tabExists) {\n        console.log(\"Bound tab no longer exists:\", boundTabId)\n        showEmptyStates()\n        updateCurrentUrlDisplay(\"Tab closed or unavailable\")\n\n        // Clear the interval since tab is gone\n        if (pollingInterval) {\n          clearInterval(pollingInterval)\n          pollingInterval = null\n        }\n        return\n      }\n\n      chrome.tabs.sendMessage(boundTabId, { action: \"getCurrentPerformanceData\" }, (response) => {\n        if (chrome.runtime.lastError) {\n          console.log(\"Error polling bound tab:\", chrome.runtime.lastError)\n          return\n        }\n\n        if (response) {\n          updatePerformanceMetrics(response)\n        }\n      })\n    }\n  }, 3000) // Increased from 2000ms to 3000ms for better performance\n}\n\n// Add cleanup when window is closed\nwindow.addEventListener(\"beforeunload\", () => {\n  if (pollingInterval) {\n    clearInterval(pollingInterval)\n    pollingInterval = null\n  }\n})\n\n/**\n * Sets up message listeners for updates from content script\n */\nfunction setupMessageListeners() {\n  console.log(\"Setting up message listeners\")\n  chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n    console.log(\"Popup received message:\", message.action, \"from sender:\", sender)\n\n    // In detached mode, only process messages from the bound tab\n    if (isDetachedMode && boundTabId) {\n      if (sender.tab && sender.tab.id !== boundTabId) {\n        console.log(\"Ignoring message from non-bound tab:\", sender.tab.id, \"bound to:\", boundTabId)\n        return\n      }\n\n      // Special handling for tab URL changes\n      if (message.action === \"tabUrlChanged\" && message.tabId === boundTabId) {\n        console.log(\"Bound tab URL changed:\", message.url)\n        updateCurrentUrlDisplay(message.url)\n      }\n    }\n\n    // Process performance updates\n    if (message.action === \"updateCLS\") {\n      console.log(\"Received CLS update\")\n      updateCLSDisplay(message)\n    } else if (message.action === \"updateLCP\") {\n      console.log(\"Received LCP update\")\n      updateLCPDisplay(message)\n    } else if (message.action === \"updateINP\") {\n      console.log(\"Received INP update\")\n      updateINPDisplay(message)\n    } else if (message.action === \"updateAdditionalMetrics\") {\n      console.log(\"Received additional metrics update\")\n      updateTTFBDisplay(message.metrics)\n    } else if (message.action === \"analysisResults\") {\n      // Only process analysis results from the bound tab in detached mode\n      if (isDetachedMode && boundTabId) {\n        if (sender.tab && sender.tab.id === boundTabId) {\n          console.log(\"Received fresh analysis results from bound tab\")\n          cachedAnalysisData = message\n          displayAnalysisData(message)\n          // Also update performance metrics\n          updatePerformanceMetricsFromData(message)\n        }\n      } else if (!isDetachedMode) {\n        // In attached mode, process all analysis results\n        console.log(\"Received fresh analysis results in attached mode\")\n        cachedAnalysisData = message\n        displayAnalysisData(message)\n        // Also update performance metrics\n        updatePerformanceMetricsFromData(message)\n      }\n    }\n    // Enhanced PSI message handling\n    else if (message.action === \"updatePSICLS\") {\n      console.log(\"Received PSI CLS update\")\n      updatePSICLSDisplay(message.fieldData)\n    } else if (message.action === \"updatePSILCP\") {\n      console.log(\"Received PSI LCP update\")\n      updatePSILCPDisplay(message.fieldData)\n    } else if (message.action === \"updatePSIINP\") {\n      console.log(\"Received PSI INP update\")\n      updatePSIINPDisplay(message.fieldData)\n    } else if (message.action === \"updatePSITTFB\") {\n      console.log(\"Received PSI TTFB update\")\n      updatePSITTFBDisplay(message.fieldData)\n    } else if (message.action === \"updatePSILabCLS\") {\n      console.log(\"Received PSI Lab CLS update\")\n      updatePSILabCLSDisplay(message.labData)\n    } else if (message.action === \"updatePSILabLCP\") {\n      console.log(\"Received PSI Lab LCP update\")\n      updatePSILabLCPDisplay(message.labData)\n    } else if (message.action === \"updatePSIStatus\") {\n      console.log(\"Received PSI status update\")\n      updatePSIStatus(message)\n    } else if (message.action === \"completePSIResults\") {\n      console.log(\"Received complete PSI results for insights\")\n      handleCompletePSIResults(message.psiData)\n    }\n  })\n}\n\n/**\n * Sets up the detach/attach button functionality\n */\nasync function setupWindowControls() {\n  console.log(\"Setting up window controls\")\n  const windowControlsContainer = document.querySelector(\".window-controls\")\n  if (!windowControlsContainer) {\n    console.log(\"Window controls container not found\")\n    return\n  }\n\n  // Detect if we're in detached mode\n  isDetachedMode = await isDetachedWindow()\n  console.log(\"Window mode detected:\", isDetachedMode ? \"detached\" : \"attached\")\n\n  // Apply detached mode styles if needed\n  applyDetachedModeStyles(isDetachedMode)\n\n  const button = windowControlsContainer.querySelector(\".window-toggle-btn\")\n\n  if (button) {\n    // Update button icon and tooltip based on current state\n    updateWindowControlButton(isDetachedMode, button)\n\n    // Add click handler\n    button.addEventListener(\"click\", async () => {\n      button.disabled = true\n\n      try {\n        if (isDetachedMode) {\n          await attachPopup()\n        } else {\n          await detachPopup()\n        }\n      } catch (error) {\n        console.error(\"Error toggling window state:\", error)\n      } finally {\n        button.disabled = false\n      }\n    })\n  }\n}\n\n/**\n * Sets up resize handling for detached mode\n */\nfunction setupResizeHandling() {\n  if (isDetachedMode) {\n    window.addEventListener(\"resize\", () => {\n      // Reapply detached mode styles on resize\n      applyDetachedModeStyles(true)\n    })\n  }\n}\n\n/**\n * Refreshes toggle states when popup loads or mode changes\n */\nasync function refreshToggleStates() {\n  try {\n    // Get the target tab ID\n    const targetTabId = await getTargetTabIdForMessaging()\n\n    if (!targetTabId) {\n      console.log(\"No target tab available for refreshing toggle states\")\n      return\n    }\n\n    console.log(\"Refreshing toggle states for tab:\", targetTabId)\n\n    // Get current parameters for this tab\n    chrome.runtime.sendMessage({ action: \"getParameters\", tabId: targetTabId }, (parameters) => {\n      if (chrome.runtime.lastError) {\n        console.error(\"Error getting parameters for refresh:\", chrome.runtime.lastError)\n        return\n      }\n\n      // Ensure parameters is an array\n      if (!Array.isArray(parameters)) {\n        parameters = []\n      }\n\n      console.log(\"Refreshed parameters for tab\", targetTabId, \":\", parameters)\n\n      // Update toggle states\n      const perfmattersoff = document.getElementById(\"perfmattersoff\")\n      const perfmatterscssoff = document.getElementById(\"perfmatterscssoff\")\n      const perfmattersjsoff = document.getElementById(\"perfmattersjsoff\")\n      const nocache = document.getElementById(\"nocache\")\n\n      if (perfmattersoff) perfmattersoff.checked = parameters.includes(\"perfmattersoff\")\n      if (perfmatterscssoff) perfmatterscssoff.checked = parameters.includes(\"perfmatterscssoff\")\n      if (perfmattersjsoff) perfmattersjsoff.checked = parameters.includes(\"perfmattersjsoff\")\n      if (nocache) nocache.checked = parameters.includes(\"nocache\")\n\n      // Update toggle dependencies\n      if (window.updateToggleStates) {\n        window.updateToggleStates(true)\n      }\n    })\n  } catch (error) {\n    console.error(\"Error refreshing toggle states:\", error)\n  }\n}\n\n/**\n * Initializes the popup when DOM is loaded\n */\nasync function initializePopup() {\n  try {\n    console.log(\"=== STARTING POPUP INITIALIZATION ===\")\n\n    // Add debug logging\n    console.log(\"DOM elements check:\")\n    TABS.forEach((tab) => {\n      const tabEl = document.getElementById(tab.id)\n      const contentEl = document.getElementById(tab.contentId)\n      console.log(`Tab ${tab.id}:`, !!tabEl, \"Content:\", !!contentEl)\n      if (!tabEl) console.error(`Missing tab element: ${tab.id}`)\n      if (!contentEl) console.error(`Missing content element: ${tab.contentId}`)\n    })\n\n    // Detect mode first\n    isDetachedMode = await isDetachedWindow()\n    console.log(\"Initializing popup in mode:\", isDetachedMode ? \"detached\" : \"attached\")\n\n    // Initialize detached mode if needed\n    if (isDetachedMode) {\n      const success = await initializeDetachedMode()\n      if (!success) {\n        console.error(\"Failed to initialize detached mode\")\n        showEmptyStates()\n        return\n      }\n    }\n\n    // Make helper function globally available with the correct signature\n    window.getTargetTabId = async () => {\n      return await getTargetTabId()\n    }\n\n    // Set up tab switching FIRST\n    console.log(\"Setting up tab switching...\")\n    setupTabSwitching(TABS)\n\n    // Set up toggle management\n    console.log(\"Setting up toggle management...\")\n    setupToggleManagement()\n\n    // Make updateToggleStates globally available for refresh\n    const toggleManagerModule = await import(\"./toggle-manager.js\")\n    if (toggleManagerModule.updateToggleStates) {\n      window.updateToggleStates = toggleManagerModule.updateToggleStates\n    }\n\n    // Set up window controls\n    console.log(\"Setting up window controls...\")\n    await setupWindowControls()\n\n    // Set up resize handling for detached mode\n    setupResizeHandling()\n\n    // Set up message listeners BEFORE updating popup\n    console.log(\"Setting up message listeners...\")\n    setupMessageListeners()\n\n    // Update popup with initial results\n    console.log(\"Updating popup with initial results...\")\n    await updatePopupWithResults()\n\n    // Refresh toggle states after everything is loaded\n    console.log(\"Refreshing toggle states...\")\n    await refreshToggleStates()\n\n    // Set up periodic polling\n    console.log(\"Setting up periodic polling...\")\n    setupPeriodicPolling()\n\n    // Set up PSI analyze button\n    console.log(\"Setting up PSI analyze button...\")\n    // PSI button is now set up in insights-display.js\n\n    console.log(\"=== POPUP INITIALIZATION COMPLETE ===\")\n  } catch (error) {\n    console.error(\"=== POPUP INITIALIZATION FAILED ===\")\n    console.error(\"Error:\", error)\n    console.error(\"Error stack:\", error.stack)\n\n    // Try to show empty states as fallback\n    try {\n      showEmptyStates()\n    } catch (fallbackError) {\n      console.error(\"Even fallback failed:\", fallbackError)\n    }\n  }\n}\n\n// Initialize when DOM is ready\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  console.log(\"DOM content loaded, initializing popup\")\n  initializePopup()\n})\n\n// Also try immediate initialization if DOM is already ready\nif (document.readyState !== \"loading\") {\n  console.log(\"DOM already ready, initializing immediately...\")\n  initializePopup()\n}\n\nconsole.log(\"=== POPUP SETUP COMPLETE ===\")\n"],"names":[],"sourceRoot":""}