{"version":3,"file":"content.js","mappings":";;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AAAA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC1WA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACtKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AClDA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC3QA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AAIA;AAOA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;;;;;;;;;;ACnHA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC7UA;;AAQA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACrNA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAGA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AAEA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AClSA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAGA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;;;;;;ACtJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAUA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA","sources":["webpack://new-bs-helper-extension/./src/content/analyzers/psi-analyzer.js","webpack://new-bs-helper-extension/./src/content/analyzers/font-analyzer.js","webpack://new-bs-helper-extension/./src/utils/messaging.js","webpack://new-bs-helper-extension/./src/content/performance/lcp-monitor.js","webpack://new-bs-helper-extension/./src/utils/dom-helpers.js","webpack://new-bs-helper-extension/./src/content/performance/cls-monitor.js","webpack://new-bs-helper-extension/./src/content/analyzers/image-analyzer.js","webpack://new-bs-helper-extension/./src/content/performance/inp-monitor.js","webpack://new-bs-helper-extension/./src/content/performance/additional-metrics.js","webpack://new-bs-helper-extension/./src/utils/formatters.js","webpack://new-bs-helper-extension/webpack/bootstrap","webpack://new-bs-helper-extension/webpack/runtime/define property getters","webpack://new-bs-helper-extension/webpack/runtime/hasOwnProperty shorthand","webpack://new-bs-helper-extension/webpack/runtime/make namespace object","webpack://new-bs-helper-extension/./src/content/index.js"],"sourcesContent":["/**\n * PageSpeed Insights API analyzer - Enhanced for all Core Web Vitals\n */\n\nimport { safeSendMessage } from \"../../utils/messaging.js\"\n\n// PSI API configuration\nconst PSI_API_BASE_URL = \"https://psi-api-worker-staging.cache-warmer-getjoinus.workers.dev/\"\n\n/**\n * Fetches PageSpeed Insights data for the current page\n * @returns {Promise<Object|null>} PSI data or null if failed\n */\nexport async function fetchPSIData() {\n  try {\n    const currentUrl = window.location.href\n    const apiUrl = `${PSI_API_BASE_URL}?url=${encodeURIComponent(currentUrl)}`\n\n    console.log(\"Fetching PSI data for:\", currentUrl)\n\n    const response = await fetch(apiUrl)\n\n    if (!response.ok) {\n      throw new Error(`PSI API request failed: ${response.status} ${response.statusText}`)\n    }\n\n    const data = await response.json()\n\n    // Handle API-level errors (when API returns error in response body)\n    if (data.status === \"failed\" || data.status === \"error\") {\n      const errorMessage = data.message || \"Unknown error occurred\"\n      const errorDetails = data.error ? ` (${data.error.type}: ${data.error.code})` : \"\"\n      throw new Error(`${errorMessage}${errorDetails}`)\n    }\n\n    if (data.status !== \"success\") {\n      throw new Error(`PSI API error: ${data.message || \"Unknown error\"}`)\n    }\n\n    console.log(\"PSI data fetched successfully:\", data)\n    return data\n  } catch (error) {\n    console.error(\"Error fetching PSI data:\", error)\n    // Re-throw with a more user-friendly message if it's a generic error\n    if (error.message.includes(\"[object Object]\")) {\n      throw new Error(\"Failed to analyze page with PageSpeed Insights. Please try again.\")\n    }\n    throw error\n  }\n}\n\n/**\n * Extracts all Core Web Vitals field data from PSI response\n * @param {Object} psiData - PSI API response data\n * @returns {Object|null} All CWV field data or null if not available\n */\nexport function extractAllFieldData(psiData) {\n  try {\n    if (!psiData || !psiData.data || !psiData.data.loadingExperience) {\n      return null\n    }\n\n    const loadingExperience = psiData.data.loadingExperience\n    const metrics = loadingExperience.metrics\n\n    if (!metrics) {\n      return null\n    }\n\n    const fieldData = {\n      id: loadingExperience.id,\n      overallCategory: loadingExperience.overall_category,\n    }\n\n    // Extract CLS data\n    if (metrics.CUMULATIVE_LAYOUT_SHIFT_SCORE) {\n      fieldData.cls = {\n        percentile: metrics.CUMULATIVE_LAYOUT_SHIFT_SCORE.percentile,\n        category: metrics.CUMULATIVE_LAYOUT_SHIFT_SCORE.category,\n        distributions: metrics.CUMULATIVE_LAYOUT_SHIFT_SCORE.distributions,\n        // Convert percentile to actual CLS value (percentile is in hundredths)\n        value: metrics.CUMULATIVE_LAYOUT_SHIFT_SCORE.percentile / 100,\n      }\n    }\n\n    // Extract LCP data\n    if (metrics.LARGEST_CONTENTFUL_PAINT_MS) {\n      fieldData.lcp = {\n        percentile: metrics.LARGEST_CONTENTFUL_PAINT_MS.percentile,\n        category: metrics.LARGEST_CONTENTFUL_PAINT_MS.category,\n        distributions: metrics.LARGEST_CONTENTFUL_PAINT_MS.distributions,\n        value: metrics.LARGEST_CONTENTFUL_PAINT_MS.percentile, // Already in ms\n      }\n    }\n\n    // Extract INP data\n    if (metrics.INTERACTION_TO_NEXT_PAINT) {\n      fieldData.inp = {\n        percentile: metrics.INTERACTION_TO_NEXT_PAINT.percentile,\n        category: metrics.INTERACTION_TO_NEXT_PAINT.category,\n        distributions: metrics.INTERACTION_TO_NEXT_PAINT.distributions,\n        value: metrics.INTERACTION_TO_NEXT_PAINT.percentile, // Already in ms\n      }\n    }\n\n    // Extract TTFB data\n    if (metrics.EXPERIMENTAL_TIME_TO_FIRST_BYTE) {\n      fieldData.ttfb = {\n        percentile: metrics.EXPERIMENTAL_TIME_TO_FIRST_BYTE.percentile,\n        category: metrics.EXPERIMENTAL_TIME_TO_FIRST_BYTE.category,\n        distributions: metrics.EXPERIMENTAL_TIME_TO_FIRST_BYTE.distributions,\n        value: metrics.EXPERIMENTAL_TIME_TO_FIRST_BYTE.percentile, // Already in ms\n      }\n    }\n\n    // Extract FCP data (bonus metric)\n    if (metrics.FIRST_CONTENTFUL_PAINT_MS) {\n      fieldData.fcp = {\n        percentile: metrics.FIRST_CONTENTFUL_PAINT_MS.percentile,\n        category: metrics.FIRST_CONTENTFUL_PAINT_MS.category,\n        distributions: metrics.FIRST_CONTENTFUL_PAINT_MS.distributions,\n        value: metrics.FIRST_CONTENTFUL_PAINT_MS.percentile, // Already in ms\n      }\n    }\n\n    return fieldData\n  } catch (error) {\n    console.error(\"Error extracting field data:\", error)\n    return null\n  }\n}\n\n/**\n * Extracts Lab data from PSI response - Only CLS and LCP (TTFB not available in lab)\n * @param {Object} psiData - PSI API response data\n * @returns {Object|null} Lab data or null if not available\n */\nexport function extractLabData(psiData) {\n  try {\n    console.log(\"🧪 [PSI Lab] Attempting to extract lab data from:\", psiData)\n\n    // Check multiple possible paths for lab data in PSI response\n    let metrics = null\n\n    // Path 1: Direct metrics in data\n    if (psiData?.data?.metrics) {\n      metrics = psiData.data.metrics\n      console.log(\"🧪 [PSI Lab] Found metrics in data.metrics:\", metrics)\n    }\n\n    // Path 2: Lighthouse result audits (standard Lighthouse structure)\n    else if (psiData?.data?.lighthouseResult?.audits) {\n      const audits = psiData.data.lighthouseResult.audits\n      console.log(\"🧪 [PSI Lab] Found lighthouse audits:\", Object.keys(audits))\n\n      // Convert audits to metrics format\n      metrics = {}\n      if (audits[\"cumulative-layout-shift\"]) {\n        metrics.CLS = audits[\"cumulative-layout-shift\"]\n      }\n      if (audits[\"largest-contentful-paint\"]) {\n        metrics.LCP = audits[\"largest-contentful-paint\"]\n      }\n      // Note: TTFB is not available in lab data as it's a server-side metric\n    }\n\n    // Path 3: Check if metrics are nested elsewhere\n    else if (psiData?.data?.labData) {\n      metrics = psiData.data.labData\n      console.log(\"🧪 [PSI Lab] Found metrics in data.labData:\", metrics)\n    }\n\n    if (!metrics) {\n      console.log(\"🧪 [PSI Lab] No lab metrics found in PSI response\")\n      console.log(\"🧪 [PSI Lab] Available data keys:\", Object.keys(psiData?.data || {}))\n      return null\n    }\n\n    const labData = {}\n\n    // Extract CLS lab data\n    if (metrics.CLS) {\n      labData.cls = {\n        numericValue: metrics.CLS.numericValue,\n        displayValue: metrics.CLS.displayValue,\n        score: metrics.CLS.score,\n        value: metrics.CLS.numericValue, // Use numericValue as the main value\n      }\n      console.log(\"🧪 [PSI Lab] Extracted CLS lab data:\", labData.cls)\n    }\n\n    // Extract LCP lab data\n    if (metrics.LCP) {\n      labData.lcp = {\n        numericValue: metrics.LCP.numericValue,\n        displayValue: metrics.LCP.displayValue,\n        score: metrics.LCP.score,\n        value: metrics.LCP.numericValue, // Use numericValue as the main value\n      }\n      console.log(\"🧪 [PSI Lab] Extracted LCP lab data:\", labData.lcp)\n    }\n\n    // Note: TTFB is intentionally excluded from lab data as it's not available in Lighthouse lab environment\n\n    console.log(\"🧪 [PSI Lab] Final extracted lab data (CLS & LCP only):\", labData)\n    return Object.keys(labData).length > 0 ? labData : null\n  } catch (error) {\n    console.error(\"🧪 [PSI Lab] Error extracting lab data:\", error)\n    return null\n  }\n}\n\n/**\n * Analyzes PSI data and sends to popup - Enhanced for all CWV with proper error handling\n * @returns {Promise<boolean>} Success status\n */\nexport async function analyzePSIData() {\n  try {\n    // Show loading state\n    safeSendMessage({\n      action: \"updatePSIStatus\",\n      status: \"loading\",\n      message: \"Fetching PageSpeed Insights data...\",\n    })\n\n    const psiData = await fetchPSIData()\n\n    console.log(\"🔍 [PSI API] RAW API Response:\", JSON.stringify(psiData, null, 2))\n\n    // Extract all field data and lab data\n    const allFieldData = extractAllFieldData(psiData)\n    const labData = extractLabData(psiData)\n\n    console.log(\"🌍 [PSI] Extracted field data:\", allFieldData)\n    console.log(\"🧪 [PSI] Extracted lab data:\", labData)\n\n    // Store PSI data in background for persistence\n    safeSendMessage({\n      action: \"storePSIResults\",\n      psiData: {\n        allFieldData: allFieldData,\n        labData: labData,\n        timestamp: Date.now(),\n        url: window.location.href,\n        rawData: psiData.data, // Store raw data for future use\n      },\n    })\n\n    // Send complete PSI data for insights processing\n    safeSendMessage({\n      action: \"completePSIResults\",\n      psiData: psiData,\n    })\n\n    // Send individual field metric updates\n    if (allFieldData) {\n      // Update CLS\n      if (allFieldData.cls) {\n        safeSendMessage({\n          action: \"updatePSICLS\",\n          fieldData: allFieldData.cls,\n          status: \"success\",\n        })\n      }\n\n      // Update LCP\n      if (allFieldData.lcp) {\n        safeSendMessage({\n          action: \"updatePSILCP\",\n          fieldData: allFieldData.lcp,\n          status: \"success\",\n        })\n      }\n\n      // Update INP\n      if (allFieldData.inp) {\n        safeSendMessage({\n          action: \"updatePSIINP\",\n          fieldData: allFieldData.inp,\n          status: \"success\",\n        })\n      }\n\n      // Update TTFB\n      if (allFieldData.ttfb) {\n        safeSendMessage({\n          action: \"updatePSITTFB\",\n          fieldData: allFieldData.ttfb,\n          status: \"success\",\n        })\n      }\n    }\n\n    // Send individual lab metric updates (only CLS and LCP available in lab)\n    if (labData) {\n      console.log(\"🧪 [PSI] Sending lab data updates:\", labData)\n\n      // Update CLS Lab\n      if (labData.cls) {\n        console.log(\"🧪 [PSI] Sending CLS lab update:\", labData.cls)\n        safeSendMessage({\n          action: \"updatePSILabCLS\",\n          labData: labData.cls,\n          status: \"success\",\n        })\n      }\n\n      // Update LCP Lab\n      if (labData.lcp) {\n        console.log(\"🧪 [PSI] Sending LCP lab update:\", labData.lcp)\n        safeSendMessage({\n          action: \"updatePSILabLCP\",\n          labData: labData.lcp,\n          status: \"success\",\n        })\n      }\n\n      // Note: TTFB lab data is not sent as it's not available in Lighthouse lab environment\n    } else {\n      console.log(\"🧪 [PSI] No lab data available to send\")\n    }\n\n    // Send success status LAST to ensure button updates correctly\n    safeSendMessage({\n      action: \"updatePSIStatus\",\n      status: \"success\",\n      message: \"PSI data loaded successfully\",\n    })\n\n    console.log(\"✅ [PSI] Analysis completed successfully\")\n    return true\n  } catch (error) {\n    console.error(\"Error analyzing PSI data:\", error)\n\n    // Extract user-friendly error message\n    let userMessage = \"Analysis failed. Please try again.\"\n    if (error.message) {\n      // Check for specific error types\n      if (error.message.includes(\"hosting requirements\")) {\n        userMessage = \"This site doesn't meet hosting requirements for analysis.\"\n      } else if (error.message.includes(\"403\")) {\n        userMessage = \"Access denied. Site may not be eligible for analysis.\"\n      } else if (error.message.includes(\"404\")) {\n        userMessage = \"Page not found or not accessible for analysis.\"\n      } else if (error.message.includes(\"500\")) {\n        userMessage = \"Server error occurred. Please try again later.\"\n      } else if (error.message.includes(\"network\") || error.message.includes(\"fetch\")) {\n        userMessage = \"Network error. Please check your connection and try again.\"\n      } else {\n        // Use the error message if it's user-friendly\n        userMessage = error.message\n      }\n    }\n\n    safeSendMessage({\n      action: \"updatePSIStatus\",\n      status: \"error\",\n      message: `Error analyzing PSI data: ${error.message}`,\n      userMessage: userMessage,\n    })\n    return false\n  }\n}\n","import { formatFileSize } from \"../../utils/formatters.js\"\n\n/**\n * Gets all loaded and preloaded fonts on the page\n * @returns {Promise<Array>} Array of font data\n */\nexport function getLoadedAndPreloadedFonts() {\n  return new Promise((resolve) => {\n    const fontResources = performance.getEntriesByType(\"resource\").filter((entry) => {\n      const loadedWithinThreeSeconds = entry.startTime < 3000\n      const isFontResource =\n        entry.initiatorType === \"css\" &&\n        (entry.name.includes(\"/fonts/\") || entry.name.match(/\\.(woff2?|ttf|otf|eot)($|\\?)/i))\n      return loadedWithinThreeSeconds && isFontResource\n    })\n\n    const preloadedFonts = Array.from(document.querySelectorAll('link[rel=\"preload\"][as=\"font\"]')).map((el) => ({\n      url: el.href,\n      fetchpriority: el.getAttribute(\"fetchpriority\") || null,\n      type: el.getAttribute(\"type\") || null,\n      crossorigin: el.getAttribute(\"crossorigin\") || null,\n    }))\n\n    // Get Early Hints fonts from performance navigation timing\n    const earlyHintsFonts = getEarlyHintsFonts()\n\n    const uniqueFonts = new Map()\n\n    fontResources.forEach((resource) => {\n      const preloadedFont = preloadedFonts.find((pf) => pf.url === resource.name)\n      const isEarlyHints = earlyHintsFonts.includes(resource.name)\n\n      uniqueFonts.set(resource.name, {\n        url: resource.name,\n        loadTime: Math.round(resource.startTime),\n        preloaded: !!preloadedFont,\n        earlyHints: isEarlyHints,\n        fetchpriority: preloadedFont?.fetchpriority || null,\n        type: getFontType(resource.name),\n        crossorigin: preloadedFont?.crossorigin || null,\n        fileSize: resource.transferSize || null,\n        fileSizeFormatted: resource.transferSize ? formatFileSize(resource.transferSize) : null,\n      })\n    })\n\n    preloadedFonts.forEach((pf) => {\n      if (!uniqueFonts.has(pf.url)) {\n        const isEarlyHints = earlyHintsFonts.includes(pf.url)\n        uniqueFonts.set(pf.url, {\n          url: pf.url,\n          loadTime: 0,\n          preloaded: true,\n          earlyHints: isEarlyHints,\n          fetchpriority: pf.fetchpriority,\n          type: getFontType(pf.url),\n          crossorigin: pf.crossorigin,\n          fileSize: null,\n          fileSizeFormatted: null,\n        })\n      }\n    })\n\n    // Add fonts that are only in Early Hints but not yet loaded\n    earlyHintsFonts.forEach((fontUrl) => {\n      if (!uniqueFonts.has(fontUrl)) {\n        uniqueFonts.set(fontUrl, {\n          url: fontUrl,\n          loadTime: 0,\n          preloaded: false,\n          earlyHints: true,\n          fetchpriority: null,\n          type: getFontType(fontUrl),\n          crossorigin: null,\n          fileSize: null,\n          fileSizeFormatted: null,\n        })\n      }\n    })\n\n    const allFonts = Array.from(uniqueFonts.values()).sort((a, b) => a.loadTime - b.loadTime)\n    resolve(allFonts)\n  })\n}\n\n/**\n * Gets fonts from Early Hints headers\n * @returns {Array} Array of font URLs from Early Hints\n */\nfunction getEarlyHintsFonts() {\n  const earlyHintsFonts = []\n\n  try {\n    // Check if there are any Early Hints in the performance navigation timing\n    const navigation = performance.getEntriesByType(\"navigation\")[0]\n\n    // Try to get Early Hints from server timing or other available APIs\n    // This is a simplified detection - in practice, Early Hints detection\n    // might require server-side cooperation or different detection methods\n\n    // Check for preload links that might have been sent via Early Hints\n    const preloadLinks = document.querySelectorAll('link[rel=\"preload\"][as=\"font\"]')\n    preloadLinks.forEach((link) => {\n      // If the link was added very early (before DOM ready), it might be from Early Hints\n      if (link.href && link.href.match(/\\.(woff2?|ttf|otf|eot)($|\\?)/i)) {\n        // Additional heuristics could be added here to better detect Early Hints\n        // For now, we'll mark fonts with specific patterns as potentially from Early Hints\n        if (isLikelyEarlyHints(link)) {\n          earlyHintsFonts.push(link.href)\n        }\n      }\n    })\n\n    // Alternative: Check for fonts loaded very early in the page lifecycle\n    const veryEarlyFonts = performance.getEntriesByType(\"resource\").filter((entry) => {\n      return (\n        entry.startTime < 100 && // Loaded within first 100ms\n        entry.name.match(/\\.(woff2?|ttf|otf|eot)($|\\?)/i) &&\n        entry.initiatorType === \"link\"\n      ) // Likely from a preload link\n    })\n\n    veryEarlyFonts.forEach((font) => {\n      if (!earlyHintsFonts.includes(font.name)) {\n        earlyHintsFonts.push(font.name)\n      }\n    })\n  } catch (error) {\n    console.debug(\"Early Hints detection failed:\", error)\n  }\n\n  return earlyHintsFonts\n}\n\n/**\n * Heuristic to determine if a preload link might be from Early Hints\n * @param {HTMLLinkElement} link - The link element\n * @returns {boolean} Whether the link is likely from Early Hints\n */\nfunction isLikelyEarlyHints(link) {\n  // Check if the link has attributes commonly used with Early Hints\n  const hasEarlyHintsAttributes =\n    link.hasAttribute(\"crossorigin\") && link.hasAttribute(\"type\") && link.type.includes(\"font/\")\n\n  // Check if it's in the document head (Early Hints are typically added there)\n  const isInHead = link.closest(\"head\") !== null\n\n  // Additional checks could include timing analysis, server headers, etc.\n  return hasEarlyHintsAttributes && isInHead\n}\n\n/**\n * Gets the font type from a URL\n * @param {string} url - The font URL\n * @returns {string} The font type\n */\nfunction getFontType(url) {\n  const extension = url.split(\".\").pop().split(\"?\")[0].toLowerCase()\n  const typeMap = {\n    woff2: \"WOFF2\",\n    woff: \"WOFF\",\n    ttf: \"TTF\",\n    otf: \"OTF\",\n    eot: \"EOT\",\n    svg: \"SVG\",\n  }\n  return typeMap[extension] || \"Unknown\"\n}\n","/**\n * Safely sends a message to the extension runtime\n * @param {Object} message - The message to send\n * @param {Function} callback - Optional callback function\n */\nexport function safeSendMessage(message, callback) {\n  try {\n    chrome.runtime.sendMessage(message, (response) => {\n      if (chrome.runtime.lastError) {\n        return\n      }\n      if (callback) callback(response)\n    })\n  } catch (error) {\n    // Extension context invalidated or other error\n    console.debug(\"Message sending failed:\", error)\n  }\n}\n\n/**\n * Sends a message to a specific tab\n * @param {number} tabId - The ID of the tab to send the message to\n * @param {Object} message - The message to send\n * @param {Function} callback - Optional callback function\n */\nexport function sendMessageToTab(tabId, message, callback) {\n  try {\n    chrome.tabs.sendMessage(tabId, message, (response) => {\n      if (chrome.runtime.lastError) {\n        return\n      }\n      if (callback) callback(response)\n    })\n  } catch (error) {\n    console.debug(\"Tab message sending failed:\", error)\n  }\n}\n\n/**\n * Sets up a listener for messages from content scripts or popup\n * @param {Object} handlers - Object mapping action names to handler functions\n */\nexport function setupMessageListener(handlers) {\n  chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n    const action = message.action\n    if (handlers[action]) {\n      handlers[action](message, sender, sendResponse)\n    }\n    return true // Keep the message channel open for async responses\n  })\n}\n","import { safeSendMessage } from \"../../utils/messaging.js\"\n\n// LCP monitoring variables\nlet lcpValue = 0\nlet lcpElement = null\nlet lcpElementInfo = null\n\n/**\n * Initializes LCP (Largest Contentful Paint) monitoring\n */\nexport function initializeLCPMonitoring() {\n  if (!window.PerformanceObserver) return\n\n  try {\n    const observer = new PerformanceObserver((entryList) => {\n      const entries = entryList.getEntries()\n      const lastEntry = entries[entries.length - 1]\n\n      if (lastEntry) {\n        lcpValue = lastEntry.startTime\n        lcpElement = lastEntry.element\n\n        console.log(\"LCP detected:\", lcpValue, \"ms, element:\", lcpElement)\n\n        if (lcpElement) {\n          lcpElementInfo = extractElementInfo(lcpElement)\n          console.log(\"LCP element info extracted:\", lcpElementInfo)\n\n          safeSendMessage({\n            action: \"updateLCP\",\n            value: lcpValue,\n            element: lcpElementInfo,\n            rating: lcpValue < 2500 ? \"good\" : lcpValue < 4000 ? \"needs-improvement\" : \"poor\",\n          })\n        } else {\n          // Send LCP data even without element info\n          console.log(\"LCP detected but no element info available\")\n          safeSendMessage({\n            action: \"updateLCP\",\n            value: lcpValue,\n            element: null,\n            rating: lcpValue < 2500 ? \"good\" : lcpValue < 4000 ? \"needs-improvement\" : \"poor\",\n          })\n        }\n      }\n    })\n\n    observer.observe({ type: \"largest-contentful-paint\", buffered: true })\n\n    // Send initial data after a delay\n    setTimeout(() => {\n      console.log(\"Sending initial LCP data:\", lcpValue, lcpElementInfo)\n      safeSendMessage({\n        action: \"updateLCP\",\n        value: lcpValue,\n        element: lcpElementInfo,\n        rating: lcpValue < 2500 ? \"good\" : lcpValue < 4000 ? \"needs-improvement\" : \"poor\",\n      })\n    }, 2000)\n  } catch (error) {\n    console.log(\"LCP monitoring error:\", error)\n  }\n}\n\n/**\n * Extracts comprehensive information from the LCP element\n * @param {HTMLElement} element - The LCP element\n * @returns {Object} Detailed element information\n */\nfunction extractElementInfo(element) {\n  const rect = element.getBoundingClientRect()\n  const computedStyle = window.getComputedStyle(element)\n\n  // Get all classes as an array\n  const classList = Array.from(element.classList)\n\n  // Extract background image if present\n  const backgroundImage = computedStyle.backgroundImage\n  let backgroundImageUrl = null\n  if (backgroundImage && backgroundImage !== \"none\") {\n    const match = backgroundImage.match(/url$$['\"]?([^'\"]+)['\"]?$$/)\n    backgroundImageUrl = match ? match[1] : null\n  }\n\n  // Determine the primary source URL\n  let primarySource = element.src || backgroundImageUrl || null\n\n  // For picture elements, get the actual displayed source\n  if (element.tagName.toLowerCase() === \"img\" && element.currentSrc) {\n    primarySource = element.currentSrc\n  }\n\n  // Get parent information for context\n  const parentInfo = element.parentElement\n    ? {\n        tagName: element.parentElement.tagName.toLowerCase(),\n        classList: Array.from(element.parentElement.classList),\n        id: element.parentElement.id || null,\n      }\n    : null\n\n  // Generate element selector for easier identification\n  const selector = generateElementSelector(element)\n\n  const elementInfo = {\n    tagName: element.tagName.toLowerCase(),\n    id: element.id || null,\n    classList: classList,\n    classString: classList.join(\" \") || null,\n    selector: selector,\n    src: element.src || null,\n    currentSrc: element.currentSrc || null,\n    backgroundImageUrl: backgroundImageUrl,\n    primarySource: primarySource,\n    alt: element.alt || null,\n    title: element.title || null,\n    textContent: element.textContent ? element.textContent.substring(0, 200) : null,\n    dimensions: {\n      width: element.offsetWidth,\n      height: element.offsetHeight,\n      naturalWidth: element.naturalWidth || null,\n      naturalHeight: element.naturalHeight || null,\n    },\n    position: {\n      top: element.offsetTop,\n      left: element.offsetLeft,\n      viewportTop: rect.top,\n      viewportLeft: rect.left,\n    },\n    styles: {\n      objectFit: computedStyle.objectFit,\n      objectPosition: computedStyle.objectPosition,\n      backgroundSize: computedStyle.backgroundSize,\n      backgroundPosition: computedStyle.backgroundPosition,\n    },\n    parent: parentInfo,\n    attributes: extractRelevantAttributes(element),\n    preview: primarySource, // Use primary source for preview\n  }\n\n  return elementInfo\n}\n\n/**\n * Generates a CSS selector for the element\n * @param {HTMLElement} element - The element\n * @returns {string} CSS selector\n */\nfunction generateElementSelector(element) {\n  if (element.id) {\n    return `#${element.id}`\n  }\n\n  let selector = element.tagName.toLowerCase()\n\n  if (element.classList.length > 0) {\n    selector += \".\" + Array.from(element.classList).join(\".\")\n  }\n\n  // Add nth-child if no unique identifier\n  if (!element.id && element.classList.length === 0) {\n    const siblings = Array.from(element.parentElement?.children || [])\n    const index = siblings.indexOf(element) + 1\n    selector += `:nth-child(${index})`\n  }\n\n  return selector\n}\n\n/**\n * Extracts relevant attributes from the element\n * @param {HTMLElement} element - The element\n * @returns {Object} Relevant attributes\n */\nfunction extractRelevantAttributes(element) {\n  const relevantAttrs = [\"loading\", \"decoding\", \"fetchpriority\", \"sizes\", \"srcset\", \"data-src\", \"data-lazy\"]\n  const attributes = {}\n\n  relevantAttrs.forEach((attr) => {\n    if (element.hasAttribute(attr)) {\n      attributes[attr] = element.getAttribute(attr)\n    }\n  })\n\n  return attributes\n}\n\n/**\n * Highlights the LCP element on the page\n * @returns {boolean} True if element was highlighted\n */\nexport function highlightLCPElement() {\n  if (!lcpElement) return false\n\n  // Remove existing highlights\n  removeLCPHighlight()\n\n  const highlight = document.createElement(\"div\")\n  highlight.id = \"bigscoots-lcp-highlight\"\n  highlight.style.cssText = `\n    position: absolute;\n    pointer-events: none;\n    z-index: 999999;\n    border: 3px solid #007aff;\n    background: rgba(0, 122, 255, 0.1);\n    box-shadow: 0 0 0 2px rgba(0, 122, 255, 0.3), 0 0 20px rgba(0, 122, 255, 0.5);\n    animation: bigscoots-lcp-pulse 2s infinite;\n    border-radius: 4px;\n  `\n\n  if (!document.getElementById(\"bigscoots-lcp-highlight-styles\")) {\n    const style = document.createElement(\"style\")\n    style.id = \"bigscoots-lcp-highlight-styles\"\n    style.textContent = `\n      @keyframes bigscoots-lcp-pulse {\n        0% { box-shadow: 0 0 0 2px rgba(0, 122, 255, 0.3), 0 0 20px rgba(0, 122, 255, 0.5); }\n        50% { box-shadow: 0 0 0 6px rgba(0, 122, 255, 0.5), 0 0 30px rgba(0, 122, 255, 0.8); }\n        100% { box-shadow: 0 0 0 2px rgba(0, 122, 255, 0.3), 0 0 20px rgba(0, 122, 255, 0.5); }\n      }\n    `\n    document.head.appendChild(style)\n  }\n\n  const rect = lcpElement.getBoundingClientRect()\n  const scrollTop = window.pageYOffset || document.documentElement.scrollTop\n  const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft\n\n  highlight.style.top = rect.top + scrollTop - 3 + \"px\"\n  highlight.style.left = rect.left + scrollLeft - 3 + \"px\"\n  highlight.style.width = rect.width + 6 + \"px\"\n  highlight.style.height = rect.height + 6 + \"px\"\n\n  document.body.appendChild(highlight)\n\n  lcpElement.scrollIntoView({\n    behavior: \"smooth\",\n    block: \"center\",\n    inline: \"center\",\n  })\n\n  setTimeout(() => {\n    removeLCPHighlight()\n  }, 5000)\n\n  return true\n}\n\n/**\n * Removes LCP element highlight\n */\nfunction removeLCPHighlight() {\n  const existingHighlight = document.getElementById(\"bigscoots-lcp-highlight\")\n  if (existingHighlight) {\n    existingHighlight.remove()\n  }\n}\n\n/**\n * Gets the current LCP data\n * @returns {Object} Current LCP data\n */\nexport function getCurrentLCPData() {\n  return {\n    value: lcpValue,\n    element: lcpElementInfo,\n    rating: lcpValue < 2500 ? \"good\" : lcpValue < 4000 ? \"needs-improvement\" : \"poor\",\n  }\n}\n","/**\n * Checks if an image is above the fold (visible in the viewport)\n * @param {HTMLImageElement} img - The image element to check\n * @returns {boolean} True if the image is above the fold\n */\nexport function isImageAboveFold(img) {\n  const rect = img.getBoundingClientRect()\n  const viewportHeight = window.innerHeight || document.documentElement.clientHeight\n  return rect.top < viewportHeight && rect.bottom > 0\n}\n\n/**\n * Gets the dimensions of an image\n * @param {HTMLImageElement} img - The image element\n * @returns {Object} Object containing natural and displayed dimensions\n */\nexport function getImageDimensions(img) {\n  return {\n    natural: {\n      width: img.naturalWidth || 0,\n      height: img.naturalHeight || 0,\n    },\n    displayed: {\n      width: img.offsetWidth || 0,\n      height: img.offsetHeight || 0,\n    },\n  }\n}\n\n/**\n * Determines if an image is on the critical rendering path\n * @param {HTMLImageElement} img - The image element\n * @param {Object} dimensions - The image dimensions\n * @returns {boolean} True if the image is on the critical path\n */\nexport function isCriticalPathImage(img, dimensions) {\n  const rect = img.getBoundingClientRect()\n  const viewportHeight = window.innerHeight || document.documentElement.clientHeight\n  const viewportWidth = window.innerWidth || document.documentElement.clientWidth\n\n  const isAboveFold = rect.top < viewportHeight && rect.bottom > 0\n  const isSignificantSize = dimensions.displayed.width >= 150 || dimensions.displayed.height >= 150\n  const takesViewportSpace =\n    dimensions.displayed.width * dimensions.displayed.height > viewportWidth * viewportHeight * 0.02\n\n  const isLikelyHero =\n    rect.top < viewportHeight * 0.6 &&\n    (dimensions.displayed.width > viewportWidth * 0.3 || dimensions.displayed.height > viewportHeight * 0.3)\n\n  const isLikelyLogo =\n    img.alt &&\n    (img.alt.toLowerCase().includes(\"logo\") ||\n      img.alt.toLowerCase().includes(\"brand\") ||\n      img.className.toLowerCase().includes(\"logo\") ||\n      img.id.toLowerCase().includes(\"logo\"))\n\n  return isAboveFold && (isSignificantSize || isLikelyHero || isLikelyLogo) && takesViewportSpace\n}\n\n/**\n * Gets the format of an image from its URL\n * @param {string} url - The image URL\n * @returns {string} The image format\n */\nexport function getImageFormat(url) {\n  const extension = url.split(\".\").pop().split(\"?\")[0].toLowerCase()\n  const formatMap = {\n    jpg: \"JPEG\",\n    jpeg: \"JPEG\",\n    png: \"PNG\",\n    gif: \"GIF\",\n    webp: \"WebP\",\n    avif: \"AVIF\",\n    svg: \"SVG\",\n  }\n  return formatMap[extension] || \"Unknown\"\n}\n\n/**\n * Analyzes image optimization issues\n * @param {HTMLImageElement} img - The image element\n * @param {Object} dimensions - The image dimensions\n * @returns {Array} Array of optimization issues\n */\nexport function analyzeImageOptimization(img, dimensions) {\n  const issues = []\n  const { natural, displayed } = dimensions\n\n  if (natural.width > displayed.width * 2 || natural.height > displayed.height * 2) {\n    const wastedPixels = natural.width * natural.height - displayed.width * displayed.height\n    issues.push({\n      type: \"oversized\",\n      severity: \"high\",\n      message: `Image is ${Math.round(wastedPixels / 1000)}K pixels larger than needed`,\n    })\n  }\n\n  const format = getImageFormat(img.src)\n  if ([\"JPEG\", \"PNG\"].includes(format)) {\n    issues.push({\n      type: \"format\",\n      severity: \"low\",\n      message: `Consider modern formats like WebP or AVIF instead of ${format}`,\n    })\n  }\n\n  if (isCriticalPathImage(img, dimensions) && img.getAttribute(\"loading\") === \"lazy\") {\n    issues.push({\n      type: \"loading\",\n      severity: \"high\",\n      message: \"Critical image should not use lazy loading\",\n    })\n  }\n\n  return issues\n}\n","import { safeSendMessage } from \"../../utils/messaging.js\"\n\n// CLS monitoring variables\nlet clsValue = 0\nconst clsEntries = []\nlet largestShiftElement = null\nlet largestShiftValue = 0\n\n/**\n * Initializes CLS (Cumulative Layout Shift) monitoring\n */\nexport function initializeCLSMonitoring() {\n  if (!window.PerformanceObserver) return\n\n  try {\n    const observer = new PerformanceObserver((entryList) => {\n      for (const entry of entryList.getEntries()) {\n        if (!entry.hadRecentInput) {\n          clsValue += entry.value\n\n          // Find the element that caused the largest shift\n          if (entry.sources && entry.sources.length > 0) {\n            const largestSource = entry.sources.reduce((largest, source) => {\n              const sourceShift = calculateShiftValue(source)\n              const largestShift = calculateShiftValue(largest)\n              return sourceShift > largestShift ? source : largest\n            })\n\n            if (entry.value > largestShiftValue) {\n              largestShiftValue = entry.value\n              largestShiftElement = largestSource.node\n            }\n          }\n\n          const entryData = {\n            value: entry.value,\n            startTime: entry.startTime,\n            sources: entry.sources\n              ? entry.sources.map((source) => ({\n                  node: source.node ? source.node.tagName : \"unknown\",\n                  currentRect: source.currentRect,\n                  previousRect: source.previousRect,\n                  shiftValue: calculateShiftValue(source),\n                }))\n              : [],\n          }\n\n          clsEntries.push(entryData)\n\n          // Extract element info if we have the largest shift element\n          let elementInfo = null\n          if (largestShiftElement) {\n            elementInfo = extractCLSElementInfo(largestShiftElement, largestShiftValue)\n            console.log(\"CLS element extracted:\", elementInfo)\n          } else {\n            console.log(\"No largest shift element found\")\n          }\n\n          console.log(\"CLS detected:\", clsValue, \"element:\", largestShiftElement, \"info:\", elementInfo)\n\n          safeSendMessage({\n            action: \"updateCLS\",\n            value: clsValue,\n            entries: clsEntries,\n            element: elementInfo,\n            rating: clsValue < 0.1 ? \"good\" : clsValue < 0.25 ? \"needs-improvement\" : \"poor\",\n          })\n        }\n      }\n    })\n\n    observer.observe({ type: \"layout-shift\", buffered: true })\n\n    setTimeout(() => {\n      let elementInfo = null\n      if (largestShiftElement) {\n        elementInfo = extractCLSElementInfo(largestShiftElement, largestShiftValue)\n      }\n\n      safeSendMessage({\n        action: \"updateCLS\",\n        value: clsValue,\n        entries: clsEntries,\n        element: elementInfo,\n        rating: clsValue < 0.1 ? \"good\" : clsValue < 0.25 ? \"needs-improvement\" : \"poor\",\n      })\n    }, 1000)\n  } catch (error) {\n    // Silent error handling\n  }\n}\n\n/**\n * Calculates the shift value for a layout shift source\n * @param {Object} source - Layout shift source\n * @returns {number} Shift value\n */\nfunction calculateShiftValue(source) {\n  if (!source.currentRect || !source.previousRect) return 0\n\n  const currentRect = source.currentRect\n  const previousRect = source.previousRect\n\n  // Calculate the distance moved\n  const deltaX = Math.abs(currentRect.x - previousRect.x)\n  const deltaY = Math.abs(currentRect.y - previousRect.y)\n\n  // Calculate the area affected\n  const area = Math.max(currentRect.width * currentRect.height, previousRect.width * previousRect.height)\n\n  // Simple shift calculation (distance * area factor)\n  return (deltaX + deltaY) * (area / (window.innerWidth * window.innerHeight))\n}\n\n/**\n * Extracts comprehensive information from the CLS element\n * @param {HTMLElement} element - The element that caused layout shift\n * @param {number} shiftValue - The shift value for this element\n * @returns {Object} Detailed element information\n */\nfunction extractCLSElementInfo(element, shiftValue) {\n  if (!element || !element.getBoundingClientRect) {\n    console.log(\"Invalid element for CLS extraction:\", element)\n    return null\n  }\n\n  try {\n    const rect = element.getBoundingClientRect()\n    const computedStyle = window.getComputedStyle(element)\n\n    // Get all classes as an array\n    const classList = Array.from(element.classList || [])\n\n    // Extract background image if present\n    const backgroundImage = computedStyle.backgroundImage\n    let backgroundImageUrl = null\n    if (backgroundImage && backgroundImage !== \"none\") {\n      const match = backgroundImage.match(/url$$['\"]?([^'\"]+)['\"]?$$/)\n      backgroundImageUrl = match ? match[1] : null\n    }\n\n    // Determine the primary source URL\n    let primarySource = element.src || backgroundImageUrl || null\n\n    // For picture elements, get the actual displayed source\n    if (element.tagName && element.tagName.toLowerCase() === \"img\" && element.currentSrc) {\n      primarySource = element.currentSrc\n    }\n\n    // Generate element selector for easier identification\n    const selector = generateCLSElementSelector(element)\n\n    const elementInfo = {\n      tagName: element.tagName ? element.tagName.toLowerCase() : \"unknown\",\n      id: element.id || null,\n      classList: classList,\n      classString: classList.join(\" \") || null,\n      selector: selector,\n      src: element.src || null,\n      currentSrc: element.currentSrc || null,\n      backgroundImageUrl: backgroundImageUrl,\n      primarySource: primarySource,\n      alt: element.alt || null,\n      title: element.title || null,\n      textContent: element.textContent ? element.textContent.substring(0, 200) : null,\n      shiftValue: shiftValue,\n      dimensions: {\n        width: element.offsetWidth || 0,\n        height: element.offsetHeight || 0,\n        naturalWidth: element.naturalWidth || null,\n        naturalHeight: element.naturalHeight || null,\n      },\n      position: {\n        top: element.offsetTop || 0,\n        left: element.offsetLeft || 0,\n        viewportTop: rect.top,\n        viewportLeft: rect.left,\n      },\n      styles: {\n        position: computedStyle.position,\n        display: computedStyle.display,\n        float: computedStyle.float,\n        transform: computedStyle.transform,\n      },\n      attributes: extractRelevantCLSAttributes(element),\n      preview: primarySource, // Use primary source for preview\n    }\n\n    return elementInfo\n  } catch (e) {\n    console.error(\"Error extracting CLS element info:\", e)\n    return null\n  }\n}\n\n/**\n * Generates a CSS selector for the CLS element\n * @param {HTMLElement} element - The element\n * @returns {string} CSS selector\n */\nfunction generateCLSElementSelector(element) {\n  if (!element.tagName) return \"unknown\"\n\n  if (element.id) {\n    return `#${element.id}`\n  }\n\n  let selector = element.tagName.toLowerCase()\n\n  if (element.classList && element.classList.length > 0) {\n    selector += \".\" + Array.from(element.classList).join(\".\")\n  }\n\n  // Add nth-child if no unique identifier\n  if (!element.id && (!element.classList || element.classList.length === 0)) {\n    try {\n      const siblings = Array.from(element.parentElement?.children || [])\n      const index = siblings.indexOf(element) + 1\n      if (index > 0) {\n        selector += `:nth-child(${index})`\n      }\n    } catch (e) {\n      // Ignore errors\n    }\n  }\n\n  return selector\n}\n\n/**\n * Extracts relevant attributes from the CLS element\n * @param {HTMLElement} element - The element\n * @returns {Object} Relevant attributes\n */\nfunction extractRelevantCLSAttributes(element) {\n  const relevantAttrs = [\"loading\", \"decoding\", \"fetchpriority\", \"sizes\", \"srcset\", \"data-src\", \"data-lazy\", \"style\"]\n  const attributes = {}\n\n  relevantAttrs.forEach((attr) => {\n    if (element.hasAttribute && element.hasAttribute(attr)) {\n      attributes[attr] = element.getAttribute(attr)\n    }\n  })\n\n  return attributes\n}\n\n/**\n * Highlights the CLS element on the page\n * @returns {boolean} True if element was highlighted\n */\nexport function highlightCLSElement() {\n  if (!largestShiftElement) return false\n\n  // Remove existing highlights\n  removeCLSHighlight()\n\n  const highlight = document.createElement(\"div\")\n  highlight.id = \"bigscoots-cls-highlight\"\n  highlight.style.cssText = `\n    position: absolute;\n    pointer-events: none;\n    z-index: 999999;\n    border: 3px solid #ff9500;\n    background: rgba(255, 149, 0, 0.1);\n    box-shadow: 0 0 0 2px rgba(255, 149, 0, 0.3), 0 0 20px rgba(255, 149, 0, 0.5);\n    animation: bigscoots-cls-pulse 2s infinite;\n    border-radius: 4px;\n  `\n\n  if (!document.getElementById(\"bigscoots-cls-highlight-styles\")) {\n    const style = document.createElement(\"style\")\n    style.id = \"bigscoots-cls-highlight-styles\"\n    style.textContent = `\n      @keyframes bigscoots-cls-pulse {\n        0% { box-shadow: 0 0 0 2px rgba(255, 149, 0, 0.3), 0 0 20px rgba(255, 149, 0, 0.5); }\n        50% { box-shadow: 0 0 0 6px rgba(255, 149, 0, 0.5), 0 0 30px rgba(255, 149, 0, 0.8); }\n        100% { box-shadow: 0 0 0 2px rgba(255, 149, 0, 0.3), 0 0 20px rgba(255, 149, 0, 0.5); }\n      }\n    `\n    document.head.appendChild(style)\n  }\n\n  const rect = largestShiftElement.getBoundingClientRect()\n  const scrollTop = window.pageYOffset || document.documentElement.scrollTop\n  const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft\n\n  highlight.style.top = rect.top + scrollTop - 3 + \"px\"\n  highlight.style.left = rect.left + scrollLeft - 3 + \"px\"\n  highlight.style.width = rect.width + 6 + \"px\"\n  highlight.style.height = rect.height + 6 + \"px\"\n\n  document.body.appendChild(highlight)\n\n  largestShiftElement.scrollIntoView({\n    behavior: \"smooth\",\n    block: \"center\",\n    inline: \"center\",\n  })\n\n  setTimeout(() => {\n    removeCLSHighlight()\n  }, 5000)\n\n  return true\n}\n\n/**\n * Removes CLS element highlight\n */\nfunction removeCLSHighlight() {\n  const existingHighlight = document.getElementById(\"bigscoots-cls-highlight\")\n  if (existingHighlight) {\n    existingHighlight.remove()\n  }\n}\n\n/**\n * Gets the current CLS data\n * @returns {Object} Current CLS data\n */\nexport function getCurrentCLSData() {\n  let elementInfo = null\n  if (largestShiftElement) {\n    elementInfo = extractCLSElementInfo(largestShiftElement, largestShiftValue)\n  }\n\n  return {\n    value: clsValue,\n    entries: clsEntries,\n    element: elementInfo,\n    rating: clsValue < 0.1 ? \"good\" : clsValue < 0.25 ? \"needs-improvement\" : \"poor\",\n  }\n}\n","import {\n  getImageDimensions,\n  isImageAboveFold,\n  isCriticalPathImage,\n  getImageFormat,\n  analyzeImageOptimization,\n} from \"../../utils/dom-helpers.js\"\n\n/**\n * Gets all preloaded images on the page\n * @returns {Promise<Array>} Array of preloaded image data\n */\nexport function getPreloadedImages() {\n  const uniqueImages = new Map()\n\n  // Get performance entries for images\n  const imageEntries = performance.getEntriesByType(\"resource\").filter((entry) => {\n    return entry.initiatorType === \"img\" || entry.name.match(/\\.(jpg|jpeg|png|gif|webp|avif|svg)(\\?.*)?$/i)\n  })\n\n  document.querySelectorAll('link[rel=\"preload\"][as=\"image\"]').forEach((el) => {\n    const earlyHints = detectEarlyHintsFromImageLink(el)\n    uniqueImages.set(el.href, {\n      url: el.href,\n      fetchpriority: el.getAttribute(\"fetchpriority\") || null,\n      type: \"preload\",\n      earlyHints,\n    })\n  })\n\n  document.querySelectorAll(\"img[data-perfmatters-preload]\").forEach((el) => {\n    if (!uniqueImages.has(el.src)) {\n      const earlyHints = detectEarlyHintsFromImagePerformance(el.src, imageEntries)\n      uniqueImages.set(el.src, {\n        url: el.src,\n        fetchpriority: el.getAttribute(\"fetchpriority\") || null,\n        type: \"perfmatters\",\n        earlyHints,\n      })\n    }\n  })\n\n  document.querySelectorAll('img[loading=\"eager\"]').forEach((el) => {\n    if (!uniqueImages.has(el.src)) {\n      const earlyHints = detectEarlyHintsFromImagePerformance(el.src, imageEntries)\n      uniqueImages.set(el.src, {\n        url: el.src,\n        fetchpriority: el.getAttribute(\"fetchpriority\") || null,\n        type: \"eager\",\n        earlyHints,\n      })\n    }\n  })\n\n  return Promise.resolve(\n    Array.from(uniqueImages.values()).map((resource) => {\n      const imgElement = document.querySelector(`img[src=\"${resource.url}\"]`)\n\n      if (imgElement) {\n        const dimensions = getImageDimensions(imgElement)\n        const aboveFold = isImageAboveFold(imgElement)\n        const isCritical = isCriticalPathImage(imgElement, dimensions)\n        const format = getImageFormat(resource.url)\n        const issues = analyzeImageOptimization(imgElement, dimensions)\n\n        return {\n          ...resource,\n          dimensions,\n          aboveFold,\n          isCritical,\n          format,\n          issues,\n          loading: imgElement.getAttribute(\"loading\") || \"auto\",\n          decoding: imgElement.getAttribute(\"decoding\") || \"auto\",\n          fetchpriority: imgElement.getAttribute(\"fetchpriority\") || null,\n        }\n      }\n\n      return {\n        ...resource,\n        aboveFold: false,\n        isCritical: false,\n        format: getImageFormat(resource.url),\n        issues: [{ type: \"missing\", severity: \"low\", message: \"Image not found in DOM\" }],\n      }\n    }),\n  )\n}\n\n/**\n * Detects Early Hints from image preload link element\n * @param {HTMLLinkElement} link - Link element\n * @returns {boolean} True if likely from Early Hints\n */\nfunction detectEarlyHintsFromImageLink(link) {\n  // Check for Early Hints indicators in link attributes\n  return (\n    link.hasAttribute(\"as\") &&\n    link.getAttribute(\"as\") === \"image\" &&\n    link.hasAttribute(\"rel\") &&\n    link.getAttribute(\"rel\") === \"preload\"\n  )\n}\n\n/**\n * Detects Early Hints from image performance entries\n * @param {string} imageUrl - Image URL\n * @param {Array} imageEntries - Performance entries for images\n * @returns {boolean} True if likely loaded via Early Hints\n */\nfunction detectEarlyHintsFromImagePerformance(imageUrl, imageEntries) {\n  const entry = imageEntries.find((e) => e.name === imageUrl)\n  if (!entry) return false\n\n  // Early Hints characteristics for images:\n  // 1. Very early start time (within first 200ms for images)\n  // 2. Link initiator type\n  // 3. Fast response time\n  return entry.startTime < 200 && entry.initiatorType === \"link\" && entry.responseEnd - entry.responseStart < 100\n}\n\n/**\n * Highlights an image on the page\n * @param {string} imageUrl - The URL of the image to highlight\n * @returns {boolean} True if image was found and highlighted\n */\nexport function highlightImageOnPage(imageUrl) {\n  removeImageHighlights()\n\n  const images = document.querySelectorAll(\"img\")\n  let targetImage = null\n\n  for (const img of images) {\n    if (img.src === imageUrl || img.currentSrc === imageUrl) {\n      targetImage = img\n      break\n    }\n  }\n\n  if (!targetImage) {\n    const allElements = document.querySelectorAll(\"*\")\n    for (const element of allElements) {\n      const computedStyle = window.getComputedStyle(element)\n      const backgroundImage = computedStyle.backgroundImage\n      if (backgroundImage && backgroundImage.includes(imageUrl)) {\n        targetImage = element\n        break\n      }\n    }\n  }\n\n  if (targetImage) {\n    const highlight = document.createElement(\"div\")\n    highlight.id = \"bigscoots-image-highlight\"\n    highlight.style.cssText = `\n      position: absolute;\n      pointer-events: none;\n      z-index: 999999;\n      border: 3px solid #ff4444;\n      background: rgba(255, 68, 68, 0.1);\n      box-shadow: 0 0 0 2px rgba(255, 68, 68, 0.3), 0 0 20px rgba(255, 68, 68, 0.5);\n      animation: bigscoots-pulse 2s infinite;\n      border-radius: 4px;\n    `\n\n    if (!document.getElementById(\"bigscoots-highlight-styles\")) {\n      const style = document.createElement(\"style\")\n      style.id = \"bigscoots-highlight-styles\"\n      style.textContent = `\n        @keyframes bigscoots-pulse {\n          0% { box-shadow: 0 0 0 2px rgba(255, 68, 68, 0.3), 0 0 20px rgba(255, 68, 68, 0.5); }\n          50% { box-shadow: 0 0 0 6px rgba(255, 68, 68, 0.5), 0 0 30px rgba(255, 68, 68, 0.8); }\n          100% { box-shadow: 0 0 0 2px rgba(255, 68, 68, 0.3), 0 0 20px rgba(255, 68, 68, 0.5); }\n        }\n      `\n      document.head.appendChild(style)\n    }\n\n    const rect = targetImage.getBoundingClientRect()\n    const scrollTop = window.pageYOffset || document.documentElement.scrollTop\n    const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft\n\n    highlight.style.top = rect.top + scrollTop - 3 + \"px\"\n    highlight.style.left = rect.left + scrollLeft - 3 + \"px\"\n    highlight.style.width = rect.width + 6 + \"px\"\n    highlight.style.height = rect.height + 6 + \"px\"\n\n    document.body.appendChild(highlight)\n\n    targetImage.scrollIntoView({\n      behavior: \"smooth\",\n      block: \"center\",\n      inline: \"center\",\n    })\n\n    setTimeout(() => {\n      removeImageHighlights()\n    }, 5000)\n\n    return true\n  }\n\n  return false\n}\n\n/**\n * Removes image highlights from the page\n */\nfunction removeImageHighlights() {\n  const existingHighlight = document.getElementById(\"bigscoots-image-highlight\")\n  if (existingHighlight) {\n    existingHighlight.remove()\n  }\n}\n","import { safeSendMessage } from \"../../utils/messaging.js\"\n\n// Use a unique namespace to avoid conflicts\nconst INP_NAMESPACE = \"bigscoots_inp_\" + Date.now()\n\n// Initialize INP data with persistence\nfunction getINPData() {\n  if (!window[INP_NAMESPACE]) {\n    window[INP_NAMESPACE] = {\n      maxINP: 0,\n      interactions: new Map(),\n      inpEntries: [],\n      isInitialized: false,\n      lastSentValue: null,\n    }\n  }\n  return window[INP_NAMESPACE]\n}\n\n/**\n * Initializes INP (Interaction to Next Paint) monitoring\n */\nexport function initializeINPMonitoring() {\n  const inpData = getINPData()\n\n  // Prevent multiple initializations\n  if (inpData.isInitialized) {\n    console.log(\"INP monitoring already initialized, sending cached data\")\n    sendCurrentINPData()\n    return\n  }\n\n  if (!window.PerformanceObserver) {\n    initializeManualINPTracking()\n    return\n  }\n\n  if (!PerformanceObserver.supportedEntryTypes || !PerformanceObserver.supportedEntryTypes.includes(\"event\")) {\n    initializeManualINPTracking()\n    return\n  }\n\n  try {\n    function processEntry(entry) {\n      if (!entry.interactionId) return\n\n      const inpData = getINPData()\n      const interactionId = entry.interactionId\n      const duration = entry.duration\n\n      const existing = inpData.interactions.get(interactionId)\n      if (!existing || duration > existing) {\n        inpData.interactions.set(interactionId, duration)\n\n        // Capture element details for the interaction\n        let elementDetails = null\n        if (entry.target) {\n          elementDetails = captureElementDetails(entry.target)\n        }\n\n        const entryDetails = {\n          interactionId,\n          duration: Math.round(duration),\n          startTime: entry.startTime,\n          name: entry.name,\n          target: entry.target ? entry.target.tagName : \"unknown\",\n          timestamp: Date.now(),\n          element: elementDetails, // Add element details\n        }\n\n        if (duration > inpData.maxINP) {\n          inpData.maxINP = duration\n          inpData.inpEntries.unshift(entryDetails)\n          if (inpData.inpEntries.length > 10) {\n            inpData.inpEntries.pop()\n          }\n\n          const rating = duration < 200 ? \"good\" : duration < 500 ? \"needs-improvement\" : \"poor\"\n          const currentValue = Math.round(duration)\n\n          // Only send if value actually changed\n          if (inpData.lastSentValue !== currentValue) {\n            inpData.lastSentValue = currentValue\n\n            safeSendMessage({\n              action: \"updateINP\",\n              value: currentValue,\n              entries: [...inpData.inpEntries], // Send copy to avoid reference issues\n              rating: rating,\n              status: \"measured\",\n            })\n          }\n        }\n      }\n    }\n\n    const observer = new PerformanceObserver((list) => {\n      for (const entry of list.getEntries()) {\n        processEntry(entry)\n      }\n    })\n\n    observer.observe({\n      type: \"event\",\n      buffered: true,\n      durationThreshold: 0,\n    })\n\n    inpData.isInitialized = true\n\n    // Send initial state after longer delay to allow for existing interactions\n    setTimeout(() => {\n      sendCurrentINPData()\n    }, 3000) // Increased delay\n  } catch (error) {\n    console.log(\"PerformanceObserver failed, falling back to manual tracking\")\n    initializeManualINPTracking()\n  }\n}\n\n/**\n * Initializes manual INP tracking as fallback\n */\nfunction initializeManualINPTracking() {\n  const inpData = getINPData()\n\n  if (inpData.isInitialized) {\n    sendCurrentINPData()\n    return\n  }\n\n  const interactionEvents = [\"pointerdown\", \"click\", \"keydown\"]\n\n  interactionEvents.forEach((eventType) => {\n    document.addEventListener(\n      eventType,\n      (event) => {\n        const startTime = performance.now()\n\n        requestAnimationFrame(() => {\n          const duration = performance.now() - startTime\n          const inpData = getINPData()\n\n          if (duration > inpData.maxINP) {\n            inpData.maxINP = duration\n\n            const entryDetails = {\n              duration: Math.round(duration),\n              startTime,\n              name: eventType,\n              target: event.target ? event.target.tagName : \"unknown\",\n              method: \"manual\",\n              timestamp: Date.now(),\n            }\n\n            inpData.inpEntries.unshift(entryDetails)\n            if (inpData.inpEntries.length > 10) {\n              inpData.inpEntries.pop()\n            }\n\n            const rating = duration < 200 ? \"good\" : duration < 500 ? \"needs-improvement\" : \"poor\"\n            const currentValue = Math.round(duration)\n\n            // Only send if value actually changed\n            if (inpData.lastSentValue !== currentValue) {\n              inpData.lastSentValue = currentValue\n\n              safeSendMessage({\n                action: \"updateINP\",\n                value: currentValue,\n                entries: [...inpData.inpEntries],\n                rating: rating,\n                status: \"measured\",\n              })\n            }\n          }\n        })\n      },\n      { passive: true, capture: true },\n    )\n  })\n\n  inpData.isInitialized = true\n\n  setTimeout(() => {\n    sendCurrentINPData()\n  }, 3000)\n}\n\n/**\n * Sends current INP data without resetting\n */\nfunction sendCurrentINPData() {\n  const inpData = getINPData()\n\n  const currentData = {\n    action: \"updateINP\",\n    value: inpData.maxINP > 0 ? Math.round(inpData.maxINP) : null,\n    entries: [...inpData.inpEntries],\n    rating: inpData.maxINP < 200 ? \"good\" : inpData.maxINP < 500 ? \"needs-improvement\" : \"poor\",\n    status: inpData.maxINP > 0 ? \"measured\" : \"waiting\",\n  }\n\n  safeSendMessage(currentData)\n}\n\n/**\n * Gets the current INP data\n * @returns {Object} Current INP data\n */\nexport function getCurrentINPData() {\n  const inpData = getINPData()\n\n  return {\n    value: inpData.maxINP > 0 ? Math.round(inpData.maxINP) : null,\n    entries: [...inpData.inpEntries],\n    rating: inpData.maxINP < 200 ? \"good\" : inpData.maxINP < 500 ? \"needs-improvement\" : \"poor\",\n    status: inpData.maxINP > 0 ? \"measured\" : \"waiting\",\n  }\n}\n\n/**\n * Captures detailed information about an element\n * @param {Element} element - The DOM element to analyze\n * @returns {Object} Element details\n */\nfunction captureElementDetails(element) {\n  if (!element) return null\n\n  try {\n    const rect = element.getBoundingClientRect()\n    const computedStyle = window.getComputedStyle(element)\n\n    return {\n      tagName: element.tagName,\n      id: element.id || null,\n      classList: element.classList ? Array.from(element.classList) : [],\n      dimensions: {\n        width: Math.round(rect.width),\n        height: Math.round(rect.height),\n      },\n      position: {\n        left: Math.round(rect.left),\n        top: Math.round(rect.top),\n      },\n      selector: generateSelector(element),\n      textContent: element.textContent ? element.textContent.trim().substring(0, 100) : null,\n    }\n  } catch (error) {\n    console.log(\"Error capturing element details:\", error)\n    return {\n      tagName: element.tagName || \"UNKNOWN\",\n      error: \"Could not capture details\",\n    }\n  }\n}\n\n/**\n * Generates a CSS selector for an element\n * @param {Element} element - The DOM element\n * @returns {string} CSS selector\n */\nfunction generateSelector(element) {\n  if (!element) return \"\"\n\n  try {\n    if (element.id) {\n      return `#${element.id}`\n    }\n\n    let selector = element.tagName.toLowerCase()\n\n    if (element.classList.length > 0) {\n      selector += \".\" + Array.from(element.classList).join(\".\")\n    }\n\n    // Add nth-child if needed for uniqueness\n    const parent = element.parentElement\n    if (parent) {\n      const siblings = Array.from(parent.children).filter((child) => child.tagName === element.tagName)\n      if (siblings.length > 1) {\n        const index = siblings.indexOf(element) + 1\n        selector += `:nth-child(${index})`\n      }\n    }\n\n    return selector\n  } catch (error) {\n    return element.tagName ? element.tagName.toLowerCase() : \"unknown\"\n  }\n}\n","import { safeSendMessage } from \"../../utils/messaging.js\"\n\n// Performance metrics storage\nconst performanceMetrics = {}\n\n/**\n * Initializes additional performance metrics monitoring\n */\nexport function initializeAdditionalMetrics() {\n  const navigation = performance.getEntriesByType(\"navigation\")[0]\n  if (navigation) {\n    performanceMetrics.ttfb = Math.round(navigation.responseStart - navigation.requestStart)\n    performanceMetrics.domLoad = Math.round(navigation.domContentLoadedEventEnd - navigation.navigationStart)\n    performanceMetrics.pageLoad = Math.round(navigation.loadEventEnd - navigation.navigationStart)\n  }\n\n  try {\n    const observer = new PerformanceObserver((entryList) => {\n      for (const entry of entryList.getEntries()) {\n        if (entry.name === \"first-contentful-paint\") {\n          performanceMetrics.fcp = Math.round(entry.startTime)\n          safeSendMessage({\n            action: \"updateAdditionalMetrics\",\n            metrics: performanceMetrics,\n          })\n        }\n      }\n    })\n\n    observer.observe({ type: \"paint\", buffered: true })\n  } catch (error) {\n    // Silent error handling\n  }\n\n  setTimeout(() => {\n    safeSendMessage({\n      action: \"updateAdditionalMetrics\",\n      metrics: performanceMetrics,\n    })\n  }, 1500)\n}\n\n/**\n * Gets the current additional metrics data\n * @returns {Object} Current additional metrics data\n */\nexport function getCurrentAdditionalMetrics() {\n  return performanceMetrics\n}\n","/**\n * Formats a file size in bytes to a human-readable string\n * @param {number} bytes - The size in bytes\n * @returns {string} Formatted size string (e.g., \"1.5 KB\")\n */\nexport function formatFileSize(bytes) {\n  if (!bytes) return \"Unknown\"\n  if (bytes < 1024) return bytes + \" B\"\n  if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + \" KB\"\n  return (bytes / (1024 * 1024)).toFixed(1) + \" MB\"\n}\n\n/**\n * Gets the appropriate background color for a header value\n * @param {string} headerKey - The header key\n * @param {string} value - The header value\n * @returns {string} CSS color value\n */\nexport function getHeaderColor(headerKey, value) {\n  const lowerValue = typeof value === \"string\" ? value.toLowerCase().trim() : \"n/a\"\n  const saneKey = typeof headerKey === \"string\" ? headerKey.toLowerCase().replace(/-/g, \"\") : \"\"\n\n  switch (saneKey) {\n    case \"xbigscootscachestatus\":\n    case \"cfcachestatus\":\n      return getCacheStatusColor(lowerValue)\n    case \"xbigscootscacheplan\":\n      return getCachePlanColor(lowerValue)\n    case \"xbigscootscachemode\":\n    case \"xbigscootscachemodeo2o\":\n      return getEnabledDisabledColor(lowerValue === \"enabled\" || lowerValue === \"true\", lowerValue === \"n/a\")\n    case \"xezoiccdn\":\n      if (lowerValue === \"hit\") return \"var(--success-bg-strong)\"\n      if (lowerValue === \"n/a\" || lowerValue === \"\") return \"var(--neutral-bg)\"\n      return \"var(--error-bg-strong)\"\n    case \"xnpcfe\":\n      if (lowerValue && lowerValue !== \"n/a\" && lowerValue !== \"disabled\" && lowerValue !== \"inactive\")\n        return \"var(--success-bg-strong)\"\n      if (lowerValue === \"n/a\" || lowerValue === \"\") return \"var(--neutral-bg)\"\n      return \"var(--error-bg-strong)\"\n    case \"perfmattersrucss\":\n    case \"perfmattersdelayjs\":\n      return getEnabledDisabledColor(lowerValue === \"enabled\", lowerValue === \"n/a\")\n    case \"xhostedby\":\n      return lowerValue && lowerValue !== \"n/a\" && lowerValue.trim() !== \"\"\n        ? \"var(--info-bg-strong)\"\n        : \"var(--neutral-bg)\"\n    case \"contentencoding\":\n      return lowerValue && lowerValue !== \"n/a\" && lowerValue.trim() !== \"\"\n        ? \"var(--info-bg-strong)\"\n        : \"var(--neutral-bg)\"\n    case \"gtm\":\n    case \"ua\":\n    case \"ga4\":\n    case \"ga\":\n      return lowerValue && lowerValue !== \"n/a\" && lowerValue.trim() !== \"\"\n        ? \"var(--warning-bg-strong)\"\n        : \"var(--neutral-bg)\"\n    case \"adprovider\":\n      if (lowerValue === \"none detected\" || lowerValue === \"n/a\" || lowerValue === \"\") return \"var(--neutral-bg)\"\n      return \"var(--success-bg-strong)\"\n    default:\n      return \"var(--neutral-bg)\"\n  }\n}\n\n/**\n * Gets the color for a cache status value\n * @param {string} status - The cache status\n * @returns {string} CSS color value\n */\nfunction getCacheStatusColor(status) {\n  switch (status) {\n    case \"hit\":\n      return \"var(--success-bg-strong)\"\n    case \"miss\":\n      return \"var(--error-bg-strong)\"\n    case \"bypass\":\n      return \"var(--warning-bg-strong)\"\n    case \"dynamic\":\n      return \"var(--info-bg-strong)\"\n    default:\n      return \"var(--neutral-bg)\"\n  }\n}\n\n/**\n * Gets the color for a cache plan value\n * @param {string} plan - The cache plan\n * @returns {string} CSS color value\n */\nfunction getCachePlanColor(plan) {\n  switch (plan) {\n    case \"standard\":\n      return \"var(--plan-standard-bg)\"\n    case \"performance+\":\n      return \"var(--plan-performance-plus-bg)\"\n    default:\n      return \"var(--neutral-bg)\"\n  }\n}\n\n/**\n * Gets the color for enabled/disabled status\n * @param {boolean} isEnabled - Whether the feature is enabled\n * @param {boolean} isNA - Whether the value is N/A\n * @returns {string} CSS color value\n */\nfunction getEnabledDisabledColor(isEnabled, isNA = false) {\n  if (isNA) return \"var(--neutral-bg)\"\n  return isEnabled ? \"var(--success-bg-strong)\" : \"var(--error-bg-strong)\"\n}\n\n/**\n * Gets the appropriate text color for a background color\n * @param {string} bgColorHexOrVar - The background color\n * @returns {string} CSS color value for text\n */\nexport function getContrastColor(bgColorHexOrVar) {\n  let hexColor = bgColorHexOrVar\n  if (hexColor.startsWith(\"var(--\")) {\n    const varName = hexColor.match(/--([a-zA-Z0-9-]+)/)[0]\n    hexColor = getComputedStyle(document.documentElement).getPropertyValue(varName).trim()\n  }\n\n  if (!hexColor || !hexColor.startsWith(\"#\")) return \"var(--text-primary)\"\n  hexColor = hexColor.slice(1)\n\n  let r, g, b\n  if (hexColor.length === 3) {\n    r = Number.parseInt(hexColor[0] + hexColor[0], 16)\n    g = Number.parseInt(hexColor[1] + hexColor[1], 16)\n    b = Number.parseInt(hexColor[2] + hexColor[2], 16)\n  } else if (hexColor.length === 6) {\n    r = Number.parseInt(hexColor.substr(0, 2), 16)\n    g = Number.parseInt(hexColor.substr(2, 2), 16)\n    b = Number.parseInt(hexColor.substr(4, 2), 16)\n  } else {\n    return \"var(--text-primary)\"\n  }\n  if (isNaN(r) || isNaN(g) || isNaN(b)) return \"var(--text-primary)\"\n\n  const yiq = (r * 299 + g * 587 + b * 114) / 1000\n\n  if (bgColorHexOrVar.includes(\"-strong\") || bgColorHexOrVar === \"var(--plan-performance-plus-bg)\") {\n    return \"#ffffff\"\n  }\n  if (bgColorHexOrVar === \"var(--plan-standard-bg)\") return \"var(--text-primary)\"\n\n  return yiq >= 145 ? \"var(--text-primary)\" : \"#ffffff\"\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// Import performance monitoring modules\nimport { initializeCLSMonitoring, getCurrentCLSData, highlightCLSElement } from \"./performance/cls-monitor.js\"\nimport { initializeLCPMonitoring, getCurrentLCPData, highlightLCPElement } from \"./performance/lcp-monitor.js\"\nimport { initializeINPMonitoring, getCurrentINPData } from \"./performance/inp-monitor.js\"\nimport { initializeAdditionalMetrics, getCurrentAdditionalMetrics } from \"./performance/additional-metrics.js\"\n\n// Import analyzer modules\nimport { getPreloadedImages, highlightImageOnPage } from \"./analyzers/image-analyzer.js\"\nimport { getLoadedAndPreloadedFonts } from \"./analyzers/font-analyzer.js\"\nimport { analyzePSIData } from \"./analyzers/psi-analyzer.js\"\n\n// Import utilities\nimport { safeSendMessage } from \"../utils/messaging.js\"\n\n// Declare chrome variable to avoid undeclared variable error\n\nconsole.log(\"=== CONTENT SCRIPT STARTING ===\")\nconsole.log(\"URL:\", window.location.href)\nconsole.log(\"Domain:\", window.location.hostname)\n\n/**\n * Checks if the extension should run on the current domain\n * @returns {boolean} True if the extension should run\n */\nfunction shouldRunOnDomain() {\n  const excludedDomains = [\"portal.bigscoots.com\", \"wpo-admin.bigscoots.com\", \"wpo.bigscoots.com\"]\n\n  // Check exact domain matches\n  if (excludedDomains.some((domain) => window.location.hostname === domain)) {\n    console.log(\"Domain excluded:\", window.location.hostname)\n    return false\n  }\n\n  // Check if domain ends with bigscoots-wpo.com\n  if (window.location.hostname.endsWith(\"bigscoots-wpo.com\")) {\n    console.log(\"BigScoots WPO domain excluded:\", window.location.hostname)\n    return false\n  }\n\n  console.log(\"Domain allowed:\", window.location.hostname)\n  return true\n}\n\n/**\n * Gets headers from the current page\n * @returns {Promise<Object>} Headers object\n */\nfunction getHeaders() {\n  console.log(\"Fetching headers...\")\n  return fetch(window.location.href, {\n    method: \"GET\",\n    cache: \"no-store\",\n    credentials: \"include\",\n  })\n    .then((response) => {\n      console.log(\"Headers response received\")\n      const headers = {}\n      ;[\n        \"x-bigscoots-cache-status\",\n        \"cf-cache-status\",\n        \"x-hosted-by\",\n        \"x-bigscoots-cache-plan\",\n        \"content-encoding\",\n        \"x-bigscoots-cache-mode\",\n        \"x-ezoic-cdn\",\n        \"x-np-cfe\",\n      ].forEach((header) => {\n        headers[header] = response.headers.get(header) || \"N/A\"\n      })\n\n      headers[\"x-bigscoots-cache-mode (O2O)\"] = headers[\"x-bigscoots-cache-mode\"] !== \"N/A\" ? \"Enabled\" : \"Disabled\"\n      headers[\"x-np-cfe\"] = headers[\"x-np-cfe\"] !== \"N/A\" ? \"Nerdpress active\" : headers[\"x-np-cfe\"]\n\n      console.log(\"Headers processed:\", headers)\n      return headers\n    })\n    .catch((error) => {\n      console.error(\"Error fetching headers:\", error)\n      return {}\n    })\n}\n\n/**\n * Analyzes the page source code for various optimizations\n * @returns {Object} Source code analysis results\n */\nfunction analyzeSourceCode() {\n  console.log(\"Analyzing source code...\")\n  const html = document.documentElement.outerHTML\n  const perfmattersRUCSS = html.includes(\"data-pmdelayedstyle\") ? \"enabled\" : \"disabled\"\n  const perfmattersDelayJS = html.includes(\"pmdelayedscript\") ? \"enabled\" : \"disabled\"\n\n  const patterns = {\n    gtm: /GTM-\\w+/g,\n    ua: /UA-\\d+-\\d+/g,\n    ga4: /G-[A-Z0-9]{9,}/g,\n    ga: /GA-[A-Z0-9]+/g,\n  }\n\n  const matches = Object.fromEntries(\n    Object.entries(patterns).map(([key, pattern]) => [key, [...new Set(html.match(pattern) || [])]]),\n  )\n\n  const result = {\n    perfmattersRUCSS,\n    perfmattersDelayJS,\n    gtm: matches.gtm.join(\", \"),\n    ua: matches.ua.join(\", \"),\n    ga4: matches.ga4.join(\", \"),\n    ga: matches.ga.join(\", \"),\n    adProvider: detectAdProvider(),\n  }\n\n  console.log(\"Source code analysis complete:\", result)\n  return result\n}\n\n/**\n * Detects ad providers on the page\n * @returns {string} Detected ad provider or \"None detected\"\n */\nfunction detectAdProvider() {\n  const html = document.documentElement.outerHTML\n  const scripts = Array.from(document.scripts).map((script) => script.src)\n\n  const adProviders = {\n    Mediavine: {\n      domains: [\"scripts.mediavine.com\", \"ads.mediavine.com\"],\n      patterns: [\"window.mediavineDomain\", \"__mediavineMachine\"],\n      enabled: false,\n    },\n    \"AdThrive/Raptive\": {\n      domains: [\"ads.adthrive.com\", \"cdn.adthrive.com\"],\n      patterns: [\"window.adthrive\", \"adthrive.config\"],\n      enabled: false,\n    },\n    Ezoic: {\n      domains: [\"www.ezojs.com\", \"ezoic.com\", \"ezoic.net\"],\n      patterns: [\"ezstandalone\", \"ez_ad_units\"],\n      enabled: false,\n    },\n    \"Google AdSense\": {\n      domains: [\"pagead2.googlesyndication.com\", \"adsbygoogle\"],\n      patterns: [\"adsbygoogle.push\", \"(adsbygoogle\"],\n      enabled: false,\n    },\n  }\n\n  Object.keys(adProviders).forEach((provider) => {\n    const hasDomain = adProviders[provider].domains.some((domain) => scripts.some((src) => src && src.includes(domain)))\n    const hasPattern = adProviders[provider].patterns.some((pattern) => html.includes(pattern))\n    if (hasDomain || hasPattern) {\n      adProviders[provider].enabled = true\n    }\n  })\n\n  const detectedProviders = Object.keys(adProviders).filter((provider) => adProviders[provider].enabled)\n  return detectedProviders.join(\", \") || \"None detected\"\n}\n\n/**\n * Highlights the INP element on the page\n * @returns {boolean} Success status\n */\nfunction highlightINPElement() {\n  console.log(\"highlightINPElement called\")\n\n  try {\n    const inpData = getCurrentINPData()\n    console.log(\"Current INP data:\", inpData)\n\n    if (!inpData.entries || inpData.entries.length === 0) {\n      console.log(\"No INP entries available for highlighting\")\n      return false\n    }\n\n    // Get the latest (highest INP) entry\n    const latestEntry = inpData.entries[0]\n    console.log(\"Latest INP entry:\", latestEntry)\n\n    if (!latestEntry.element || !latestEntry.element.selector) {\n      console.log(\"No element selector available for highlighting\")\n      return false\n    }\n\n    // Try to find the element using the selector\n    let targetElement = null\n    try {\n      targetElement = document.querySelector(latestEntry.element.selector)\n    } catch (error) {\n      console.log(\"Error with selector, trying alternative methods:\", error)\n    }\n\n    // Fallback: try to find by ID or class\n    if (!targetElement && latestEntry.element.id) {\n      targetElement = document.getElementById(latestEntry.element.id)\n    }\n\n    if (!targetElement && latestEntry.element.classList && latestEntry.element.classList.length > 0) {\n      targetElement = document.querySelector(`.${latestEntry.element.classList[0]}`)\n    }\n\n    if (!targetElement) {\n      console.log(\"Could not find INP element to highlight\")\n      return false\n    }\n\n    console.log(\"Found INP element to highlight:\", targetElement)\n\n    // Create highlight overlay\n    const highlight = document.createElement(\"div\")\n    highlight.id = \"bigscoots-inp-highlight\"\n    highlight.style.cssText = `\n      position: fixed !important;\n      pointer-events: none !important;\n      z-index: 999999 !important;\n      border: 3px solid #ff6b35 !important;\n      background: rgba(255, 107, 53, 0.1) !important;\n      border-radius: 4px !important;\n      box-shadow: 0 0 0 2px rgba(255, 107, 53, 0.3) !important;\n      transition: all 0.3s ease !important;\n    `\n\n    // Position the highlight\n    const rect = targetElement.getBoundingClientRect()\n    highlight.style.left = `${rect.left - 3}px`\n    highlight.style.top = `${rect.top - 3}px`\n    highlight.style.width = `${rect.width + 6}px`\n    highlight.style.height = `${rect.height + 6}px`\n\n    // Remove any existing highlights\n    const existingHighlight = document.getElementById(\"bigscoots-inp-highlight\")\n    if (existingHighlight) {\n      existingHighlight.remove()\n    }\n\n    // Add the highlight\n    document.body.appendChild(highlight)\n\n    // Scroll element into view\n    targetElement.scrollIntoView({\n      behavior: \"smooth\",\n      block: \"center\",\n      inline: \"center\",\n    })\n\n    // Add pulsing animation\n    let pulseCount = 0\n    const pulseInterval = setInterval(() => {\n      if (pulseCount >= 6) {\n        clearInterval(pulseInterval)\n        return\n      }\n\n      highlight.style.transform = pulseCount % 2 === 0 ? \"scale(1.05)\" : \"scale(1)\"\n      pulseCount++\n    }, 300)\n\n    // Remove highlight after 3 seconds\n    setTimeout(() => {\n      if (highlight && highlight.parentNode) {\n        highlight.remove()\n      }\n    }, 3000)\n\n    console.log(\"INP element highlighted successfully\")\n    return true\n  } catch (error) {\n    console.error(\"Error highlighting INP element:\", error)\n    return false\n  }\n}\n\n/**\n * Runs the main analysis of the page\n */\nasync function runAnalysis() {\n  console.log(\"=== STARTING PAGE ANALYSIS ===\")\n\n  if (!shouldRunOnDomain()) {\n    console.log(\"Extension should not run on this domain, exiting\")\n    return\n  }\n\n  console.log(\"Initializing performance monitoring...\")\n  // Initialize performance monitoring\n  initializeCLSMonitoring()\n  initializeLCPMonitoring()\n  initializeINPMonitoring()\n  initializeAdditionalMetrics()\n\n  console.log(\"Running analysis promises...\")\n  // Run analysis\n  try {\n    const [images, fonts, headers, sourceCodeInfo] = await Promise.all([\n      getPreloadedImages(),\n      getLoadedAndPreloadedFonts(),\n      getHeaders(),\n      Promise.resolve(analyzeSourceCode()),\n    ])\n\n    console.log(\"Analysis results:\")\n    console.log(\"- Images:\", images.length)\n    console.log(\"- Fonts:\", fonts.length)\n    console.log(\"- Headers:\", Object.keys(headers).length)\n    console.log(\"- Source code info:\", sourceCodeInfo)\n\n    const analysisData = {\n      images,\n      fonts,\n      headers: { ...headers, ...sourceCodeInfo },\n      cls: getCurrentCLSData(),\n      lcp: getCurrentLCPData(),\n      inp: getCurrentINPData(),\n      additionalMetrics: getCurrentAdditionalMetrics(),\n    }\n\n    console.log(\"Sending analysis results to background...\")\n    safeSendMessage({\n      action: \"analysisResults\",\n      ...analysisData,\n    })\n\n    console.log(\"Sending badge update...\")\n    safeSendMessage({\n      action: \"updateBadge\",\n      hostedBy: headers[\"x-hosted-by\"] || \"N/A\",\n      cacheStatus: headers[\"x-bigscoots-cache-status\"] || headers[\"cf-cache-status\"] || \"N/A\",\n    })\n\n    console.log(\"=== PAGE ANALYSIS COMPLETE ===\")\n  } catch (error) {\n    console.error(\"Error during analysis:\", error)\n  }\n}\n\n// Initialize the extension\nconsole.log(\"Starting content script initialization...\")\nrunAnalysis()\n\n// Set up message listener with proper async handling\nchrome.runtime.onMessage.addListener((request, sender, sendResponse) => {\n  console.log(\"Content script received message:\", request.action)\n\n  // Handle ping requests to verify content script is ready\n  if (request.action === \"ping\") {\n    console.log(\"Content script ping received - responding immediately\")\n    sendResponse({ ready: true })\n    return false // Synchronous response, don't keep channel open\n  }\n\n  if (request.action === \"getCurrentPerformanceData\") {\n    const data = {\n      cls: getCurrentCLSData(),\n      lcp: getCurrentLCPData(),\n      inp: getCurrentINPData(),\n      additionalMetrics: getCurrentAdditionalMetrics(),\n    }\n    console.log(\"Sending current performance data:\", data)\n    sendResponse(data)\n    return false // Synchronous response\n  } else if (request.action === \"highlightImage\") {\n    const success = highlightImageOnPage(request.imageUrl)\n    sendResponse({ success })\n    return false // Synchronous response\n  } else if (request.action === \"highlightLCPElement\") {\n    const success = highlightLCPElement()\n    sendResponse({ success })\n    return false // Synchronous response\n  } else if (request.action === \"highlightCLSElement\") {\n    const success = highlightCLSElement()\n    sendResponse({ success })\n    return false // Synchronous response\n  } else if (request.action === \"highlightINPElement\") {\n    const success = highlightINPElement()\n    sendResponse({ success })\n    return false // Synchronous response\n  } else if (request.action === \"requestAnalysis\") {\n    console.log(\"Fresh analysis requested\")\n    // Re-run the analysis when requested\n    runAnalysis()\n    sendResponse({ success: true })\n    return false // Synchronous response\n  } else if (request.action === \"analyzePSI\") {\n    // Handle PSI analysis request - this is async\n    console.log(\"Received PSI analysis request\")\n\n    // Execute PSI analysis asynchronously\n    const handlePSIAnalysis = async () => {\n      try {\n        console.log(\"Starting PSI analysis...\")\n        const success = await analyzePSIData()\n        console.log(\"PSI analysis completed:\", success)\n        sendResponse({ success: true })\n      } catch (error) {\n        console.error(\"PSI analysis error:\", error)\n        sendResponse({ success: false, error: error.message })\n      }\n    }\n\n    // Start the async operation\n    handlePSIAnalysis()\n\n    return true // Keep message channel open for async response\n  }\n\n  return false // Don't keep channel open for unhandled messages\n})\n\nconsole.log(\"=== CONTENT SCRIPT SETUP COMPLETE ===\")\n"],"names":[],"sourceRoot":""}